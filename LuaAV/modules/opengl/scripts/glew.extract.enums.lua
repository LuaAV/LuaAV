---------------------------------------------------------------
-- Bootstrapping functions required to coalesce paths
local
function exec(cmd, echo)
	echo = echo or true
	if(echo) then
		print(cmd)
		print("")
	end
	local res = io.popen(cmd):read("*a")
	return res:sub(1, res:len()-1)
end

local
function stripfilename(filename)
	return string.match(filename, "(.+)/[^/]*%.%w+$")
end

local
function strippath(filename)
	return string.match(filename, ".+/([^/]*%.%w+)$")
end

local
function stripextension(filename)
	local idx = filename:match(".+()%.%w+$")
	if(idx) then
		return filename:sub(1, idx-1)
	else
		return filename
	end
end

local
function addmodulepath(path)
	-- add to package paths (if not already present)
	if not string.find(package.path, path, 0, true) then
		package.path = string.format("%s/?.lua;%s", path, package.path)
		package.path = string.format("%s/?/init.lua;%s", path, package.path)
		package.cpath = string.format("%s/?.so;%s", path, package.cpath)
	end
end

local
function setup_modulepath()
	if(arg) then
		local pwd = exec("pwd")
		local root = arg[0]
		if(root and stripfilename(root)) then 
			root = stripfilename(root) .. "/"
		else 
			root = "" 
		end
		
		local script_path
		local path
	
		if(root:sub(1, 1) == "/") then
			script_path = root
			path = string.format("%s%s", root, "modules")
		else
			script_path = string.format("%s/%s", pwd, root)
			path = string.format("%s/%s%s", pwd, root, "modules")
		end
		addmodulepath(path)
		
		return script_path:sub(1, script_path:len()-1)
	else
		return script.path
	end
end
---------------------------------------------------------------
-- Script Initialization
local script = {}
script.path = setup_modulepath()

local format = string.format
local floor = math.floor

local glew_h = script.path.."/../src/glew/GL/glew.h"
local lua_opengl_enums_h = script.path.."/../include/lua_opengl_enums.h"
local src = io.open(glew_h):read("*a")

local ignore = {
	["TIMEOUT_IGNORED"] = true
}

local enums = {}
local current_section
for line in src:gmatch("([^\n]+)\n") do
	local section = line:match("/%*%s+%-+%s+GL_([%w_]+)%s+%-+%s+%*/")
	if(section) then
		current_section = section
	end
	if(current_section) then
		local enum = 	line:match("#define%s+GL_([%w_]+)%s[%dx]+") or 
						line:match("#define%s+GL_([%w_]+)%sGL_[%w_]+")
		if(enum ~= current_section and not ignore[enum]) then
			enums[#enums+1] = enum
		end
	end
end

local enum_header_code_template = [[
/* DO NOT EDIT THIS FILE: automatically generated by glew.extract.enums.lua */

#ifndef LUA_OPENGL_ENUMS_H
#define LUA_OPENGL_ENUMS_H 1

#include "lua_opengl_config.h"

#define ENUM_ENTRY(name)	{#name, GL_##name}

typedef struct _gl_enum {
	const char *name;
	GLenum value;
} t_gl_enum;

static const t_gl_enum gl_enums[] = {
	%s
	{ NULL, NULL }
};

#endif // LUA_OPENGL_ENUMS_H
]]

print("#enums: "..#enums)
local enum_list = ""
for i, enum in ipairs(enums) do
	enum_list = format("%s\n\tENUM_ENTRY(%s),", enum_list, enum)
end
local enum_header_code = format(enum_header_code_template, enum_list)
io.open(lua_opengl_enums_h, "w"):write(enum_header_code)
