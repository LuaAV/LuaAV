/*
Gaigen 2.5 Test Suite
*/
/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage c2ga documentation
 *
 * c2ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _C2GA_H_
#define _C2GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
namespace c2ga {

// group: 1
#define GROUP_0 1
// group: no, e1, e2, ni
#define GROUP_1 2
// group: no^e1, no^e2, e1^e2, no^ni, e1^ni, e2^ni
#define GROUP_2 4
// group: no^e1^e2, no^e1^ni, no^e2^ni, e1^e2^ni
#define GROUP_3 8
// group: no^e1^e2^ni
#define GROUP_4 16
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16


/// The dimension of the space:
extern const int c2ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int c2ga_nbGroups;

/// The constants for the groups in an array:
extern const int c2ga_groups[];

/// The constants for the grades in an array:
extern const int c2ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool c2ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int c2ga_groupSize[5];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int c2ga_mvSize[32];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *c2ga_basisVectorNames[4];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int c2ga_basisElements[16][5];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double c2ga_basisElementSignByIndex[16];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double c2ga_basisElementSignByBitmap[16];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int c2ga_basisElementIndexByBitmap[16];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int c2ga_basisElementBitmapByIndex[16];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int c2ga_basisElementGradeByBitmap[16];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int c2ga_basisElementGroupByBitmap[16];
class mv;
class no_t;
class e1_t;
class e2_t;
class ni_t;
class noni_t;
class I2_t;
class I4_t;
class I4i_t;
class vectorE2GA;
class bivectorE2GA;
class rotorE2GA;
class normalizedPoint;
class dualCircle;
class freeVector;
class freeBivector;
class circle;
class line;
class pseudoscalar;
class normalizedTranslator;
class translator;
class evenVersor;
class oddVersor;
class om;
class grade1OM_E2GA;
class grade1OM;
class flatPointOM;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:no, e1, e2, ni  (grade 1).
/// group 2:no^e1, no^e2, e1^e2, no^ni, e1^ni, e2^ni  (grade 2).
/// group 3:no^e1^e2, no^e1^ni, no^e2^ni, e1^e2^ni  (grade 3).
/// group 4:no^e1^e2^ni  (grade 4).
/// 
/// 16 doubles are allocated inside the struct.
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates
	double m_c[16]; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  {set();}

	/// Copy constructor.
	inline mv(const mv&A)  {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

	/// Converts a no_t to a mv.
	inline mv(const no_t&A)  {set(A);}
	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  {set(A);}
	/// Converts a ni_t to a mv.
	inline mv(const ni_t&A)  {set(A);}
	/// Converts a noni_t to a mv.
	inline mv(const noni_t&A)  {set(A);}
	/// Converts a I2_t to a mv.
	inline mv(const I2_t&A)  {set(A);}
	/// Converts a I4_t to a mv.
	inline mv(const I4_t&A)  {set(A);}
	/// Converts a I4i_t to a mv.
	inline mv(const I4i_t&A)  {set(A);}
	/// Converts a vectorE2GA to a mv.
	inline mv(const vectorE2GA&A)  {set(A);}
	/// Converts a bivectorE2GA to a mv.
	inline mv(const bivectorE2GA&A)  {set(A);}
	/// Converts a rotorE2GA to a mv.
	inline mv(const rotorE2GA&A)  {set(A);}
	/// Converts a normalizedPoint to a mv.
	inline mv(const normalizedPoint&A)  {set(A);}
	/// Converts a dualCircle to a mv.
	inline mv(const dualCircle&A)  {set(A);}
	/// Converts a freeVector to a mv.
	inline mv(const freeVector&A)  {set(A);}
	/// Converts a freeBivector to a mv.
	inline mv(const freeBivector&A)  {set(A);}
	/// Converts a circle to a mv.
	inline mv(const circle&A)  {set(A);}
	/// Converts a line to a mv.
	inline mv(const line&A)  {set(A);}
	/// Converts a pseudoscalar to a mv.
	inline mv(const pseudoscalar&A)  {set(A);}
	/// Converts a normalizedTranslator to a mv.
	inline mv(const normalizedTranslator&A)  {set(A);}
	/// Converts a translator to a mv.
	inline mv(const translator&A)  {set(A);}
	/// Converts a evenVersor to a mv.
	inline mv(const evenVersor&A)  {set(A);}
	/// Converts a oddVersor to a mv.
	inline mv(const oddVersor&A)  {set(A);}


	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const no_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const ni_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const noni_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I4_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I4i_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vectorE2GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivectorE2GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const rotorE2GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const dualCircle &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const freeVector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const freeBivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const circle &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const line &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pseudoscalar &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedTranslator &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const translator &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const evenVersor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const oddVersor &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of no_t A
	void set(const no_t &A);
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of ni_t A
	void set(const ni_t &A);
	/// Sets this mv to the value of noni_t A
	void set(const noni_t &A);
	/// Sets this mv to the value of I2_t A
	void set(const I2_t &A);
	/// Sets this mv to the value of I4_t A
	void set(const I4_t &A);
	/// Sets this mv to the value of I4i_t A
	void set(const I4i_t &A);
	/// Sets this mv to the value of vectorE2GA A
	void set(const vectorE2GA &A);
	/// Sets this mv to the value of bivectorE2GA A
	void set(const bivectorE2GA &A);
	/// Sets this mv to the value of rotorE2GA A
	void set(const rotorE2GA &A);
	/// Sets this mv to the value of normalizedPoint A
	void set(const normalizedPoint &A);
	/// Sets this mv to the value of dualCircle A
	void set(const dualCircle &A);
	/// Sets this mv to the value of freeVector A
	void set(const freeVector &A);
	/// Sets this mv to the value of freeBivector A
	void set(const freeBivector &A);
	/// Sets this mv to the value of circle A
	void set(const circle &A);
	/// Sets this mv to the value of line A
	void set(const line &A);
	/// Sets this mv to the value of pseudoscalar A
	void set(const pseudoscalar &A);
	/// Sets this mv to the value of normalizedTranslator A
	void set(const normalizedTranslator &A);
	/// Sets this mv to the value of translator A
	void set(const translator &A);
	/// Sets this mv to the value of evenVersor A
	void set(const evenVersor &A);
	/// Sets this mv to the value of oddVersor A
	void set(const oddVersor &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[c2ga_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the no coordinate of this mv.
	inline double get_no() const {
		return (m_gu & 2) ? m_c[c2ga_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the e1 coordinate of this mv.
	inline double get_e1() const {
		return (m_gu & 2) ? m_c[c2ga_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the e2 coordinate of this mv.
	inline double get_e2() const {
		return (m_gu & 2) ? m_c[c2ga_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the ni coordinate of this mv.
	inline double get_ni() const {
		return (m_gu & 2) ? m_c[c2ga_mvSize[m_gu & 1] + 3] : 0.0;
	}
	/// Returns the no_e1 coordinate of this mv.
	inline double get_no_e1() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the no_e2 coordinate of this mv.
	inline double get_no_e2() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline double get_e1_e2() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the no_ni coordinate of this mv.
	inline double get_no_ni() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 3] : 0.0;
	}
	/// Returns the e1_ni coordinate of this mv.
	inline double get_e1_ni() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 4] : 0.0;
	}
	/// Returns the e2_ni coordinate of this mv.
	inline double get_e2_ni() const {
		return (m_gu & 4) ? m_c[c2ga_mvSize[m_gu & 3] + 5] : 0.0;
	}
	/// Returns the no_e1_e2 coordinate of this mv.
	inline double get_no_e1_e2() const {
		return (m_gu & 8) ? m_c[c2ga_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns the no_e1_ni coordinate of this mv.
	inline double get_no_e1_ni() const {
		return (m_gu & 8) ? m_c[c2ga_mvSize[m_gu & 7] + 1] : 0.0;
	}
	/// Returns the no_e2_ni coordinate of this mv.
	inline double get_no_e2_ni() const {
		return (m_gu & 8) ? m_c[c2ga_mvSize[m_gu & 7] + 2] : 0.0;
	}
	/// Returns the e1_e2_ni coordinate of this mv.
	inline double get_e1_e2_ni() const {
		return (m_gu & 8) ? m_c[c2ga_mvSize[m_gu & 7] + 3] : 0.0;
	}
	/// Returns the no_e1_e2_ni coordinate of this mv.
	inline double get_no_e1_e2_ni() const {
		return (m_gu & 16) ? m_c[c2ga_mvSize[m_gu & 15] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[c2ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the no coordinate of this mv.
	inline void set_no(double val)  {
		reserveGroup_1();
		m_c[c2ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(double val)  {
		reserveGroup_1();
		m_c[c2ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(double val)  {
		reserveGroup_1();
		m_c[c2ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the ni coordinate of this mv.
	inline void set_ni(double val)  {
		reserveGroup_1();
		m_c[c2ga_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the no_e1 coordinate of this mv.
	inline void set_no_e1(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the no_e2 coordinate of this mv.
	inline void set_no_e2(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the no_ni coordinate of this mv.
	inline void set_no_ni(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the e1_ni coordinate of this mv.
	inline void set_e1_ni(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the e2_ni coordinate of this mv.
	inline void set_e2_ni(double val)  {
		reserveGroup_2();
		m_c[c2ga_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the no_e1_e2 coordinate of this mv.
	inline void set_no_e1_e2(double val)  {
		reserveGroup_3();
		m_c[c2ga_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the no_e1_ni coordinate of this mv.
	inline void set_no_e1_ni(double val)  {
		reserveGroup_3();
		m_c[c2ga_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the no_e2_ni coordinate of this mv.
	inline void set_no_e2_ni(double val)  {
		reserveGroup_3();
		m_c[c2ga_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the e1_e2_ni coordinate of this mv.
	inline void set_e1_e2_ni(double val)  {
		reserveGroup_3();
		m_c[c2ga_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the no_e1_e2_ni coordinate of this mv.
	inline void set_no_e1_e2_ni(double val)  {
		reserveGroup_4();
		m_c[c2ga_mvSize[m_gu & 15] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[5], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[16]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c2ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c2ga_mvSize[groupUsageBelow];
			for (int i = c2ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c2ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c2ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c2ga_mvSize[groupUsageBelow];
			for (int i = c2ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c2ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c2ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c2ga_mvSize[groupUsageBelow];
			for (int i = c2ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c2ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c2ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c2ga_mvSize[groupUsageBelow];
			for (int i = c2ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c2ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + c2ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type no_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class no_t
{
public:
public:

	/// Floating point type used by no_t 
	typedef double Float;
	/// Array indices of no_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new no_t with variable coordinates set to 0.
	inline no_t() {set();}

	/// Copy constructor.
	inline no_t(const no_t &A) {set(A);}



	/// Constructs a new no_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline no_t(mv &A, int filler) {set(A);}


	/// Assignment operator (no_t).
	inline no_t &operator=(const no_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline no_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const no_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class no_t

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef double Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef double Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline double get_e2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type ni_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - ni = 1
/// 
/// 
class ni_t
{
public:
public:

	/// Floating point type used by ni_t 
	typedef double Float;
	/// Array indices of ni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new ni_t with variable coordinates set to 0.
	inline ni_t() {set();}

	/// Copy constructor.
	inline ni_t(const ni_t &A) {set(A);}



	/// Constructs a new ni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline ni_t(mv &A, int filler) {set(A);}


	/// Assignment operator (ni_t).
	inline ni_t &operator=(const ni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline ni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const ni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the ni coordinate.
	inline double get_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class ni_t

/// This class can hold a specialized multivector of type noni_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^ni = 1
/// 
/// 
class noni_t
{
public:
public:

	/// Floating point type used by noni_t 
	typedef double Float;
	/// Array indices of noni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new noni_t with variable coordinates set to 0.
	inline noni_t() {set();}

	/// Copy constructor.
	inline noni_t(const noni_t &A) {set(A);}



	/// Constructs a new noni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline noni_t(mv &A, int filler) {set(A);}


	/// Assignment operator (noni_t).
	inline noni_t &operator=(const noni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline noni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const noni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class noni_t

/// This class can hold a specialized multivector of type I2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1^e2 = 1
/// 
/// 
class I2_t
{
public:
public:

	/// Floating point type used by I2_t 
	typedef double Float;
	/// Array indices of I2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I2_t with variable coordinates set to 0.
	inline I2_t() {set();}

	/// Copy constructor.
	inline I2_t(const I2_t &A) {set(A);}



	/// Constructs a new I2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I2_t).
	inline I2_t &operator=(const I2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I2_t

/// This class can hold a specialized multivector of type I4_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^e1^e2^ni = 1
/// 
/// 
class I4_t
{
public:
public:

	/// Floating point type used by I4_t 
	typedef double Float;
	/// Array indices of I4_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I4_t with variable coordinates set to 0.
	inline I4_t() {set();}

	/// Copy constructor.
	inline I4_t(const I4_t &A) {set(A);}



	/// Constructs a new I4_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I4_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I4_t).
	inline I4_t &operator=(const I4_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I4_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I4_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I4_t

/// This class can hold a specialized multivector of type I4i_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^e1^e2^ni = -1
/// 
/// 
class I4i_t
{
public:
public:

	/// Floating point type used by I4i_t 
	typedef double Float;
	/// Array indices of I4i_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I4i_t with variable coordinates set to 0.
	inline I4i_t() {set();}

	/// Copy constructor.
	inline I4i_t(const I4i_t &A) {set(A);}



	/// Constructs a new I4i_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I4i_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I4i_t).
	inline I4i_t &operator=(const I4i_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I4i_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I4i_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return -1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I4i_t

/// This class can hold a specialized multivector of type vectorE2GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vectorE2GA
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
public:

	/// Floating point type used by vectorE2GA 
	typedef double Float;
	/// Array indices of vectorE2GA coordinates.
	typedef enum {
		/// index of coordinate for e1 in vectorE2GA
		E1 = 0, 
		/// index of coordinate for e2 in vectorE2GA
		E2 = 1, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2
	} CoordinateOrder;

	/// Constructs a new vectorE2GA with variable coordinates set to 0.
	inline vectorE2GA() {set();}

	/// Copy constructor.
	inline vectorE2GA(const vectorE2GA &A) {set(A);}



	/// Constructs a new vectorE2GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vectorE2GA(mv &A, int filler) {set(A);}

	/// Constructs a new vectorE2GA. Coordinate values come from 'A'.
	inline vectorE2GA(const CoordinateOrder co, const double A[2]) {set(co, A);}
	
	/// Constructs a new vectorE2GA with each coordinate specified.
	inline vectorE2GA(const CoordinateOrder co,  double e1, double e2) {
		set(co, e1, e2);
	}

	/// Assignment operator (vectorE2GA).
	inline vectorE2GA &operator=(const vectorE2GA &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vectorE2GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vectorE2GA &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[2]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class vectorE2GA

/// This class can hold a specialized multivector of type bivectorE2GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2  (array index: E1_E2 = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivectorE2GA
{
public:
	/// The e1^e2 coordinate.
	double m_e1_e2;
public:

	/// Floating point type used by bivectorE2GA 
	typedef double Float;
	/// Array indices of bivectorE2GA coordinates.
	typedef enum {
		/// index of coordinate for e1^e2 in bivectorE2GA
		E1_E2 = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2
	} CoordinateOrder;

	/// Constructs a new bivectorE2GA with variable coordinates set to 0.
	inline bivectorE2GA() {set();}

	/// Copy constructor.
	inline bivectorE2GA(const bivectorE2GA &A) {set(A);}



	/// Constructs a new bivectorE2GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivectorE2GA(mv &A, int filler) {set(A);}

	/// Constructs a new bivectorE2GA. Coordinate values come from 'A'.
	inline bivectorE2GA(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new bivectorE2GA with each coordinate specified.
	inline bivectorE2GA(const CoordinateOrder co,  double e1_e2) {
		set(co, e1_e2);
	}

	/// Assignment operator (bivectorE2GA).
	inline bivectorE2GA &operator=(const bivectorE2GA &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivectorE2GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivectorE2GA &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class bivectorE2GA

/// This class can hold a specialized multivector of type rotorE2GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^e2  (array index: E1_E2 = 1)
/// 
/// The type has no constant coordinates.
/// 
/// 
class rotorE2GA
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^e2 coordinate.
	double m_e1_e2;
public:

	/// Floating point type used by rotorE2GA 
	typedef double Float;
	/// Array indices of rotorE2GA coordinates.
	typedef enum {
		/// index of coordinate for 1 in rotorE2GA
		SCALAR = 0, 
		/// index of coordinate for e1^e2 in rotorE2GA
		E1_E2 = 1, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1e2
	} CoordinateOrder;

	/// Constructs a new rotorE2GA with variable coordinates set to 0.
	inline rotorE2GA() {set();}

	/// Copy constructor.
	inline rotorE2GA(const rotorE2GA &A) {set(A);}


	/// Constructs a new rotorE2GA with scalar value 'scalar'.
	inline rotorE2GA(double scalar) {set(scalar);}

	/// Constructs a new rotorE2GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline rotorE2GA(mv &A, int filler) {set(A);}

	/// Constructs a new rotorE2GA. Coordinate values come from 'A'.
	inline rotorE2GA(const CoordinateOrder co, const double A[2]) {set(co, A);}
	
	/// Constructs a new rotorE2GA with each coordinate specified.
	inline rotorE2GA(const CoordinateOrder co,  double scalar, double e1_e2) {
		set(co, scalar, e1_e2);
	}

	/// Assignment operator (rotorE2GA).
	inline rotorE2GA &operator=(const rotorE2GA &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline rotorE2GA &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline rotorE2GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const rotorE2GA &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[2]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_e2);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
}; // end of class rotorE2GA

/// This class can hold a specialized multivector of type normalizedPoint.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate ni  (array index: NI = 2)
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class normalizedPoint
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The ni coordinate.
	double m_ni;
public:

	/// Floating point type used by normalizedPoint 
	typedef double Float;
	/// Array indices of normalizedPoint coordinates.
	typedef enum {
		/// index of coordinate for e1 in normalizedPoint
		E1 = 0, 
		/// index of coordinate for e2 in normalizedPoint
		E2 = 1, 
		/// index of coordinate for ni in normalizedPoint
		NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_ni
	} CoordinateOrder;

	/// Constructs a new normalizedPoint with variable coordinates set to 0.
	inline normalizedPoint() {set();}

	/// Copy constructor.
	inline normalizedPoint(const normalizedPoint &A) {set(A);}



	/// Constructs a new normalizedPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedPoint(mv &A, int filler) {set(A);}

	/// Constructs a new normalizedPoint. Coordinate values come from 'A'.
	inline normalizedPoint(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new normalizedPoint with each coordinate specified.
	inline normalizedPoint(const CoordinateOrder co,  double e1, double e2, double ni) {
		set(co, e1, e2, ni);
	}

	/// Assignment operator (normalizedPoint).
	inline normalizedPoint &operator=(const normalizedPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline normalizedPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the no coordinate.
	inline double get_no() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class normalizedPoint

/// This class can hold a specialized multivector of type dualCircle.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no  (array index: NO = 0)
///   - coordinate e1  (array index: E1 = 1)
///   - coordinate e2  (array index: E2 = 2)
///   - coordinate ni  (array index: NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class dualCircle
{
public:
	/// The no coordinate.
	double m_no;
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The ni coordinate.
	double m_ni;
public:

	/// Floating point type used by dualCircle 
	typedef double Float;
	/// Array indices of dualCircle coordinates.
	typedef enum {
		/// index of coordinate for no in dualCircle
		NO = 0, 
		/// index of coordinate for e1 in dualCircle
		E1 = 1, 
		/// index of coordinate for e2 in dualCircle
		E2 = 2, 
		/// index of coordinate for ni in dualCircle
		NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_no_e1_e2_ni
	} CoordinateOrder;

	/// Constructs a new dualCircle with variable coordinates set to 0.
	inline dualCircle() {set();}

	/// Copy constructor.
	inline dualCircle(const dualCircle &A) {set(A);}



	/// Constructs a new dualCircle from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline dualCircle(mv &A, int filler) {set(A);}

	/// Constructs a new dualCircle. Coordinate values come from 'A'.
	inline dualCircle(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new dualCircle with each coordinate specified.
	inline dualCircle(const CoordinateOrder co,  double no, double e1, double e2, double ni) {
		set(co, no, e1, e2, ni);
	}

	/// Assignment operator (dualCircle).
	inline dualCircle &operator=(const dualCircle &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline dualCircle &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const dualCircle &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no, double e1, double e2, double ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return m_no;}
	/// Sets the no coordinate.
	inline void set_no(double no) { m_no = no;}
	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class dualCircle

/// This class can hold a specialized multivector of type freeVector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
/// 
/// The type has no constant coordinates.
/// 
/// 
class freeVector
{
public:
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
public:

	/// Floating point type used by freeVector 
	typedef double Float;
	/// Array indices of freeVector coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in freeVector
		E1_NI = 0, 
		/// index of coordinate for e2^ni in freeVector
		E2_NI = 1, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni
	} CoordinateOrder;

	/// Constructs a new freeVector with variable coordinates set to 0.
	inline freeVector() {set();}

	/// Copy constructor.
	inline freeVector(const freeVector &A) {set(A);}



	/// Constructs a new freeVector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline freeVector(mv &A, int filler) {set(A);}

	/// Constructs a new freeVector. Coordinate values come from 'A'.
	inline freeVector(const CoordinateOrder co, const double A[2]) {set(co, A);}
	
	/// Constructs a new freeVector with each coordinate specified.
	inline freeVector(const CoordinateOrder co,  double e1_ni, double e2_ni) {
		set(co, e1_ni, e2_ni);
	}

	/// Assignment operator (freeVector).
	inline freeVector &operator=(const freeVector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline freeVector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const freeVector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[2]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_ni, double e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class freeVector

/// This class can hold a specialized multivector of type freeBivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class freeBivector
{
public:
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
public:

	/// Floating point type used by freeBivector 
	typedef double Float;
	/// Array indices of freeBivector coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^ni in freeBivector
		E1_E2_NI = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2ni
	} CoordinateOrder;

	/// Constructs a new freeBivector with variable coordinates set to 0.
	inline freeBivector() {set();}

	/// Copy constructor.
	inline freeBivector(const freeBivector &A) {set(A);}



	/// Constructs a new freeBivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline freeBivector(mv &A, int filler) {set(A);}

	/// Constructs a new freeBivector. Coordinate values come from 'A'.
	inline freeBivector(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new freeBivector with each coordinate specified.
	inline freeBivector(const CoordinateOrder co,  double e1_e2_ni) {
		set(co, e1_e2_ni);
	}

	/// Assignment operator (freeBivector).
	inline freeBivector &operator=(const freeBivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline freeBivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const freeBivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class freeBivector

/// This class can hold a specialized multivector of type circle.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1^e2  (array index: NO_E1_E2 = 0)
///   - coordinate no^e1^ni  (array index: NO_E1_NI = 1)
///   - coordinate no^e2^ni  (array index: NO_E2_NI = 2)
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class circle
{
public:
	/// The no^e1^e2 coordinate.
	double m_no_e1_e2;
	/// The no^e1^ni coordinate.
	double m_no_e1_ni;
	/// The no^e2^ni coordinate.
	double m_no_e2_ni;
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
public:

	/// Floating point type used by circle 
	typedef double Float;
	/// Array indices of circle coordinates.
	typedef enum {
		/// index of coordinate for no^e1^e2 in circle
		NO_E1_E2 = 0, 
		/// index of coordinate for no^e1^ni in circle
		NO_E1_NI = 1, 
		/// index of coordinate for no^e2^ni in circle
		NO_E2_NI = 2, 
		/// index of coordinate for e1^e2^ni in circle
		E1_E2_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1e2_noe1ni_noe2ni_e1e2ni
	} CoordinateOrder;

	/// Constructs a new circle with variable coordinates set to 0.
	inline circle() {set();}

	/// Copy constructor.
	inline circle(const circle &A) {set(A);}



	/// Constructs a new circle from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline circle(mv &A, int filler) {set(A);}

	/// Constructs a new circle. Coordinate values come from 'A'.
	inline circle(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new circle with each coordinate specified.
	inline circle(const CoordinateOrder co,  double no_e1_e2, double no_e1_ni, double no_e2_ni, double e1_e2_ni) {
		set(co, no_e1_e2, no_e1_ni, no_e2_ni, e1_e2_ni);
	}

	/// Assignment operator (circle).
	inline circle &operator=(const circle &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline circle &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const circle &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no_e1_e2, double no_e1_ni, double no_e2_ni, double e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2 coordinate.
	inline double get_no_e1_e2() const { return m_no_e1_e2;}
	/// Sets the no^e1^e2 coordinate.
	inline void set_no_e1_e2(double no_e1_e2) { m_no_e1_e2 = no_e1_e2;}
	/// Returns the no^e1^ni coordinate.
	inline double get_no_e1_ni() const { return m_no_e1_ni;}
	/// Sets the no^e1^ni coordinate.
	inline void set_no_e1_ni(double no_e1_ni) { m_no_e1_ni = no_e1_ni;}
	/// Returns the no^e2^ni coordinate.
	inline double get_no_e2_ni() const { return m_no_e2_ni;}
	/// Sets the no^e2^ni coordinate.
	inline void set_no_e2_ni(double no_e2_ni) { m_no_e2_ni = no_e2_ni;}
	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class circle

/// This class can hold a specialized multivector of type line.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 0)
///   - coordinate -1*no^e1^ni  (array index: E1_NO_NI = 1)
///   - coordinate -1*no^e2^ni  (array index: E2_NO_NI = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class line
{
public:
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
	/// The -1*no^e1^ni coordinate.
	double m_e1_no_ni;
	/// The -1*no^e2^ni coordinate.
	double m_e2_no_ni;
public:

	/// Floating point type used by line 
	typedef double Float;
	/// Array indices of line coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^ni in line
		E1_E2_NI = 0, 
		/// index of coordinate for -1*no^e1^ni in line
		E1_NO_NI = 1, 
		/// index of coordinate for -1*no^e2^ni in line
		E2_NO_NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2ni_e1noni_e2noni
	} CoordinateOrder;

	/// Constructs a new line with variable coordinates set to 0.
	inline line() {set();}

	/// Copy constructor.
	inline line(const line &A) {set(A);}



	/// Constructs a new line from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline line(mv &A, int filler) {set(A);}

	/// Constructs a new line. Coordinate values come from 'A'.
	inline line(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new line with each coordinate specified.
	inline line(const CoordinateOrder co,  double e1_e2_ni, double e1_no_ni, double e2_no_ni) {
		set(co, e1_e2_ni, e1_no_ni, e2_no_ni);
	}

	/// Assignment operator (line).
	inline line &operator=(const line &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline line &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const line &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_ni, double e1_no_ni, double e2_no_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the -1*no^e1^ni coordinate.
	inline double get_e1_no_ni() const { return m_e1_no_ni;}
	/// Sets the -1*no^e1^ni coordinate.
	inline void set_e1_no_ni(double e1_no_ni) { m_e1_no_ni = e1_no_ni;}
	/// Returns the -1*no^e2^ni coordinate.
	inline double get_e2_no_ni() const { return m_e2_no_ni;}
	/// Sets the -1*no^e2^ni coordinate.
	inline void set_e2_no_ni(double e2_no_ni) { m_e2_no_ni = e2_no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class line

/// This class can hold a specialized multivector of type pseudoscalar.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pseudoscalar
{
public:
	/// The no^e1^e2^ni coordinate.
	double m_no_e1_e2_ni;
public:

	/// Floating point type used by pseudoscalar 
	typedef double Float;
	/// Array indices of pseudoscalar coordinates.
	typedef enum {
		/// index of coordinate for no^e1^e2^ni in pseudoscalar
		NO_E1_E2_NI = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1e2ni
	} CoordinateOrder;

	/// Constructs a new pseudoscalar with variable coordinates set to 0.
	inline pseudoscalar() {set();}

	/// Copy constructor.
	inline pseudoscalar(const pseudoscalar &A) {set(A);}



	/// Constructs a new pseudoscalar from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pseudoscalar(mv &A, int filler) {set(A);}

	/// Constructs a new pseudoscalar. Coordinate values come from 'A'.
	inline pseudoscalar(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new pseudoscalar with each coordinate specified.
	inline pseudoscalar(const CoordinateOrder co,  double no_e1_e2_ni) {
		set(co, no_e1_e2_ni);
	}

	/// Assignment operator (pseudoscalar).
	inline pseudoscalar &operator=(const pseudoscalar &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pseudoscalar &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pseudoscalar &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no_e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return m_no_e1_e2_ni;}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(double no_e1_e2_ni) { m_no_e1_e2_ni = no_e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class pseudoscalar

/// This class can hold a specialized multivector of type normalizedTranslator.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
/// 
/// The constant non-zero coordinates are:
///   - 1 = 1
/// 
/// 
class normalizedTranslator
{
public:
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
public:

	/// Floating point type used by normalizedTranslator 
	typedef double Float;
	/// Array indices of normalizedTranslator coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in normalizedTranslator
		E1_NI = 0, 
		/// index of coordinate for e2^ni in normalizedTranslator
		E2_NI = 1, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni
	} CoordinateOrder;

	/// Constructs a new normalizedTranslator with variable coordinates set to 0.
	inline normalizedTranslator() {set();}

	/// Copy constructor.
	inline normalizedTranslator(const normalizedTranslator &A) {set(A);}


	/// Constructs a new normalizedTranslator with scalar value 'scalar'.
	inline normalizedTranslator(double scalar) {set(scalar);}

	/// Constructs a new normalizedTranslator from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedTranslator(mv &A, int filler) {set(A);}

	/// Constructs a new normalizedTranslator. Coordinate values come from 'A'.
	inline normalizedTranslator(const CoordinateOrder co, const double A[2]) {set(co, A);}
	
	/// Constructs a new normalizedTranslator with each coordinate specified.
	inline normalizedTranslator(const CoordinateOrder co,  double e1_ni, double e2_ni) {
		set(co, e1_ni, e2_ni);
	}

	/// Assignment operator (normalizedTranslator).
	inline normalizedTranslator &operator=(const normalizedTranslator &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline normalizedTranslator &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline normalizedTranslator &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedTranslator &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[2]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_ni, double e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the 1 coordinate.
	inline double get_scalar() const { return 1.0;}
}; // end of class normalizedTranslator

/// This class can hold a specialized multivector of type translator.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^ni  (array index: E1_NI = 1)
///   - coordinate e2^ni  (array index: E2_NI = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class translator
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
public:

	/// Floating point type used by translator 
	typedef double Float;
	/// Array indices of translator coordinates.
	typedef enum {
		/// index of coordinate for 1 in translator
		SCALAR = 0, 
		/// index of coordinate for e1^ni in translator
		E1_NI = 1, 
		/// index of coordinate for e2^ni in translator
		E2_NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1ni_e2ni
	} CoordinateOrder;

	/// Constructs a new translator with variable coordinates set to 0.
	inline translator() {set();}

	/// Copy constructor.
	inline translator(const translator &A) {set(A);}


	/// Constructs a new translator with scalar value 'scalar'.
	inline translator(double scalar) {set(scalar);}

	/// Constructs a new translator from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline translator(mv &A, int filler) {set(A);}

	/// Constructs a new translator. Coordinate values come from 'A'.
	inline translator(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new translator with each coordinate specified.
	inline translator(const CoordinateOrder co,  double scalar, double e1_ni, double e2_ni) {
		set(co, scalar, e1_ni, e2_ni);
	}

	/// Assignment operator (translator).
	inline translator &operator=(const translator &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline translator &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline translator &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const translator &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_ni, double e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
}; // end of class translator

/// This class can hold a specialized multivector of type evenVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate no^e1  (array index: NO_E1 = 1)
///   - coordinate no^e2  (array index: NO_E2 = 2)
///   - coordinate e1^e2  (array index: E1_E2 = 3)
///   - coordinate e1^ni  (array index: E1_NI = 4)
///   - coordinate e2^ni  (array index: E2_NI = 5)
///   - coordinate no^ni  (array index: NO_NI = 6)
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class evenVersor
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The no^e1 coordinate.
	double m_no_e1;
	/// The no^e2 coordinate.
	double m_no_e2;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The no^ni coordinate.
	double m_no_ni;
	/// The no^e1^e2^ni coordinate.
	double m_no_e1_e2_ni;
public:

	/// Floating point type used by evenVersor 
	typedef double Float;
	/// Array indices of evenVersor coordinates.
	typedef enum {
		/// index of coordinate for 1 in evenVersor
		SCALAR = 0, 
		/// index of coordinate for no^e1 in evenVersor
		NO_E1 = 1, 
		/// index of coordinate for no^e2 in evenVersor
		NO_E2 = 2, 
		/// index of coordinate for e1^e2 in evenVersor
		E1_E2 = 3, 
		/// index of coordinate for e1^ni in evenVersor
		E1_NI = 4, 
		/// index of coordinate for e2^ni in evenVersor
		E2_NI = 5, 
		/// index of coordinate for no^ni in evenVersor
		NO_NI = 6, 
		/// index of coordinate for no^e1^e2^ni in evenVersor
		NO_E1_E2_NI = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_noe1_noe2_e1e2_e1ni_e2ni_noni_noe1e2ni
	} CoordinateOrder;

	/// Constructs a new evenVersor with variable coordinates set to 0.
	inline evenVersor() {set();}

	/// Copy constructor.
	inline evenVersor(const evenVersor &A) {set(A);}


	/// Constructs a new evenVersor with scalar value 'scalar'.
	inline evenVersor(double scalar) {set(scalar);}

	/// Constructs a new evenVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline evenVersor(mv &A, int filler) {set(A);}

	/// Constructs a new evenVersor. Coordinate values come from 'A'.
	inline evenVersor(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new evenVersor with each coordinate specified.
	inline evenVersor(const CoordinateOrder co,  double scalar, double no_e1, double no_e2, double e1_e2, double e1_ni, double e2_ni, double no_ni, double no_e1_e2_ni) {
		set(co, scalar, no_e1, no_e2, e1_e2, e1_ni, e2_ni, no_ni, no_e1_e2_ni);
	}

	/// Assignment operator (evenVersor).
	inline evenVersor &operator=(const evenVersor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline evenVersor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline evenVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const evenVersor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double no_e1, double no_e2, double e1_e2, double e1_ni, double e2_ni, double no_ni, double no_e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the no^e1 coordinate.
	inline double get_no_e1() const { return m_no_e1;}
	/// Sets the no^e1 coordinate.
	inline void set_no_e1(double no_e1) { m_no_e1 = no_e1;}
	/// Returns the no^e2 coordinate.
	inline double get_no_e2() const { return m_no_e2;}
	/// Sets the no^e2 coordinate.
	inline void set_no_e2(double no_e2) { m_no_e2 = no_e2;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return m_no_ni;}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(double no_ni) { m_no_ni = no_ni;}
	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return m_no_e1_e2_ni;}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(double no_e1_e2_ni) { m_no_e1_e2_ni = no_e1_e2_ni;}
}; // end of class evenVersor

/// This class can hold a specialized multivector of type oddVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no  (array index: NO = 0)
///   - coordinate e1  (array index: E1 = 1)
///   - coordinate e2  (array index: E2 = 2)
///   - coordinate ni  (array index: NI = 3)
///   - coordinate no^e1^e2  (array index: NO_E1_E2 = 4)
///   - coordinate no^e1^ni  (array index: NO_E1_NI = 5)
///   - coordinate no^e2^ni  (array index: NO_E2_NI = 6)
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class oddVersor
{
public:
	/// The no coordinate.
	double m_no;
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The ni coordinate.
	double m_ni;
	/// The no^e1^e2 coordinate.
	double m_no_e1_e2;
	/// The no^e1^ni coordinate.
	double m_no_e1_ni;
	/// The no^e2^ni coordinate.
	double m_no_e2_ni;
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
public:

	/// Floating point type used by oddVersor 
	typedef double Float;
	/// Array indices of oddVersor coordinates.
	typedef enum {
		/// index of coordinate for no in oddVersor
		NO = 0, 
		/// index of coordinate for e1 in oddVersor
		E1 = 1, 
		/// index of coordinate for e2 in oddVersor
		E2 = 2, 
		/// index of coordinate for ni in oddVersor
		NI = 3, 
		/// index of coordinate for no^e1^e2 in oddVersor
		NO_E1_E2 = 4, 
		/// index of coordinate for no^e1^ni in oddVersor
		NO_E1_NI = 5, 
		/// index of coordinate for no^e2^ni in oddVersor
		NO_E2_NI = 6, 
		/// index of coordinate for e1^e2^ni in oddVersor
		E1_E2_NI = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_no_e1_e2_ni_noe1e2_noe1ni_noe2ni_e1e2ni
	} CoordinateOrder;

	/// Constructs a new oddVersor with variable coordinates set to 0.
	inline oddVersor() {set();}

	/// Copy constructor.
	inline oddVersor(const oddVersor &A) {set(A);}



	/// Constructs a new oddVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline oddVersor(mv &A, int filler) {set(A);}

	/// Constructs a new oddVersor. Coordinate values come from 'A'.
	inline oddVersor(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new oddVersor with each coordinate specified.
	inline oddVersor(const CoordinateOrder co,  double no, double e1, double e2, double ni, double no_e1_e2, double no_e1_ni, double no_e2_ni, double e1_e2_ni) {
		set(co, no, e1, e2, ni, no_e1_e2, no_e1_ni, no_e2_ni, e1_e2_ni);
	}

	/// Assignment operator (oddVersor).
	inline oddVersor &operator=(const oddVersor &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline oddVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const oddVersor &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no, double e1, double e2, double ni, double no_e1_e2, double no_e1_ni, double no_e2_ni, double e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c2ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c2ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return m_no;}
	/// Sets the no coordinate.
	inline void set_no(double no) { m_no = no;}
	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the no^e1^e2 coordinate.
	inline double get_no_e1_e2() const { return m_no_e1_e2;}
	/// Sets the no^e1^e2 coordinate.
	inline void set_no_e1_e2(double no_e1_e2) { m_no_e1_e2 = no_e1_e2;}
	/// Returns the no^e1^ni coordinate.
	inline double get_no_e1_ni() const { return m_no_e1_ni;}
	/// Sets the no^e1^ni coordinate.
	inline void set_no_e1_ni(double no_e1_ni) { m_no_e1_ni = no_e1_ni;}
	/// Returns the no^e2^ni coordinate.
	inline double get_no_e2_ni() const { return m_no_e2_ni;}
	/// Sets the no^e2^ni coordinate.
	inline void set_no_e2_ni(double no_e2_ni) { m_no_e2_ni = no_e2_ni;}
	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class oddVersor

/// This class can hold a general outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: no, e1, e2, ni.
/// Domain grade 2: no^e1, no^e2, e1^e2, no^ni, e1^ni, e2^ni.
/// Domain grade 3: no^e1^e2, no^e1^ni, no^e2^ni, e1^e2^ni.
/// Domain grade 4: no^e1^e2^ni.
/// 
/// The range and domain are equal.
/// 
class om
{
public:
	/// Matrix for grade 1; the size is 4 x 4
	double m_m1[16];
	/// Matrix for grade 2; the size is 6 x 6
	double m_m2[36];
	/// Matrix for grade 3; the size is 4 x 4
	double m_m3[16];
	/// Matrix for grade 4; the size is 1 x 1
	double m_m4[1];
public:

	/// Floating point type used by om 
	typedef double Float;

	/// Constructs a new om, set to identity
	inline om() { setIdentity(); }

	/// Copy constructor.
	inline om(const om&M) { set(M); }

	/// Constructor from matrix
	inline om(const double *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline om(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini)
		{ set(ino, ie1, ie2, ini); }

	/// Converts a grade1OM_E2GA to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM_E2GA &M) { set(M); }
	
	/// Converts a grade1OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM &M) { set(M); }
	
	/// Converts a flatPointOM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const flatPointOM &M) { set(M); }
	

	/// Sets this to 'M'
	inline om &operator=(const om &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to grade1OM_E2GA.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM_E2GA &M) { set(M); return *this; }
	
	/// Sets this om to grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM &M) { set(M); return *this; }
	
	/// Sets this om to flatPointOM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const flatPointOM &M) { set(M); return *this; }
	

	/// Sets this om to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const om &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini);

	/// Sets this om to a grade1OM_E2GA.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM_E2GA &M);
	
	/// Sets this om to a grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM &M);
	
	/// Sets this om to a flatPointOM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const flatPointOM &M);
	
	private:
	void set_0();
	void set_1();
	void set_2();
	void set_3();
	void set_grade_2_0();
	void set_grade_2_1();
	void set_grade_2_2();
	void set_grade_2_3();
	void set_grade_2_4();
	void set_grade_2_5();
	void set_grade_3_0();
	void set_grade_3_1();
	void set_grade_3_2();
	void set_grade_3_3();
	void set_grade_4_0();
	public:
}; // end of om

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2.
/// Domain grade 2: .
/// Domain grade 3: .
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class grade1OM_E2GA
{
public:
	/// Matrix for grade 1; the size is 2 x 2
	double m_m1[4];
public:

	/// Floating point type used by grade1OM_E2GA 
	typedef double Float;

	/// Constructs a new grade1OM_E2GA, set to identity
	inline grade1OM_E2GA() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM_E2GA(const grade1OM_E2GA&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM_E2GA(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM_E2GA(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM_E2GA(const vectorE2GA &ie1, const vectorE2GA &ie2)
		{ set(ie1, ie2); }

	/// Converts a om to a grade1OM_E2GA.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM_E2GA(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM_E2GA &operator=(const grade1OM_E2GA &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM_E2GA.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM_E2GA &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM_E2GA to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM_E2GA &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vectorE2GA &ie1, const vectorE2GA &ie2);

	/// Sets this grade1OM_E2GA to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM_E2GA

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: no, e1, e2, ni.
/// Domain grade 2: .
/// Domain grade 3: .
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class grade1OM
{
public:
	/// Matrix for grade 1; the size is 4 x 4
	double m_m1[16];
public:

	/// Floating point type used by grade1OM 
	typedef double Float;

	/// Constructs a new grade1OM, set to identity
	inline grade1OM() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM(const grade1OM&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini)
		{ set(ino, ie1, ie2, ini); }

	/// Converts a om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM &operator=(const grade1OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini);

	/// Sets this grade1OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: e1^ni, e2^ni, no^ni.
/// Domain grade 3: .
/// Domain grade 4: .
/// 
/// The range and domain are equal.
/// 
class flatPointOM
{
public:
	/// Matrix for grade 2; the size is 3 x 3
	double m_m2[9];
public:

	/// Floating point type used by flatPointOM 
	typedef double Float;

	/// Constructs a new flatPointOM, set to identity
	inline flatPointOM() { setIdentity(); }

	/// Copy constructor.
	inline flatPointOM(const flatPointOM&M) { set(M); }

	/// Constructor from matrix
	inline flatPointOM(const double *M) { set(M); }

	/// Constructor from matrix
	inline flatPointOM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline flatPointOM(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini)
		{ set(ino, ie1, ie2, ini); }

	/// Converts a om to a flatPointOM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline flatPointOM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline flatPointOM &operator=(const flatPointOM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a flatPointOM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline flatPointOM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this flatPointOM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const flatPointOM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini);

	/// Sets this flatPointOM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of flatPointOM
extern no_t no;
extern e1_t e1;
extern e2_t e2;
extern ni_t ni;
extern noni_t noni;
extern I2_t I2;
extern I4_t I4;
extern I4i_t I4i;
extern vectorE2GA vectorE1;
extern vectorE2GA vectorE2;
/** The point at the origin . . .  */
extern normalizedPoint pointAtOrigin;
/** The point at infinity . . .  */
extern dualCircle pointAtInfinity;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 31);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  no_t
double _double(const no_t &x);
/// Returns scalar part of  no_t
inline double _Float(const no_t &x) {return _double(x); };
/// Returns scalar part of  e1_t
double _double(const e1_t &x);
/// Returns scalar part of  e1_t
inline double _Float(const e1_t &x) {return _double(x); };
/// Returns scalar part of  e2_t
double _double(const e2_t &x);
/// Returns scalar part of  e2_t
inline double _Float(const e2_t &x) {return _double(x); };
/// Returns scalar part of  ni_t
double _double(const ni_t &x);
/// Returns scalar part of  ni_t
inline double _Float(const ni_t &x) {return _double(x); };
/// Returns scalar part of  noni_t
double _double(const noni_t &x);
/// Returns scalar part of  noni_t
inline double _Float(const noni_t &x) {return _double(x); };
/// Returns scalar part of  I2_t
double _double(const I2_t &x);
/// Returns scalar part of  I2_t
inline double _Float(const I2_t &x) {return _double(x); };
/// Returns scalar part of  I4_t
double _double(const I4_t &x);
/// Returns scalar part of  I4_t
inline double _Float(const I4_t &x) {return _double(x); };
/// Returns scalar part of  I4i_t
double _double(const I4i_t &x);
/// Returns scalar part of  I4i_t
inline double _Float(const I4i_t &x) {return _double(x); };
/// Returns scalar part of  vectorE2GA
double _double(const vectorE2GA &x);
/// Returns scalar part of  vectorE2GA
inline double _Float(const vectorE2GA &x) {return _double(x); };
/// Returns scalar part of  bivectorE2GA
double _double(const bivectorE2GA &x);
/// Returns scalar part of  bivectorE2GA
inline double _Float(const bivectorE2GA &x) {return _double(x); };
/// Returns scalar part of  rotorE2GA
double _double(const rotorE2GA &x);
/// Returns scalar part of  rotorE2GA
inline double _Float(const rotorE2GA &x) {return _double(x); };
/// Returns scalar part of  normalizedPoint
double _double(const normalizedPoint &x);
/// Returns scalar part of  normalizedPoint
inline double _Float(const normalizedPoint &x) {return _double(x); };
/// Returns scalar part of  dualCircle
double _double(const dualCircle &x);
/// Returns scalar part of  dualCircle
inline double _Float(const dualCircle &x) {return _double(x); };
/// Returns scalar part of  freeVector
double _double(const freeVector &x);
/// Returns scalar part of  freeVector
inline double _Float(const freeVector &x) {return _double(x); };
/// Returns scalar part of  freeBivector
double _double(const freeBivector &x);
/// Returns scalar part of  freeBivector
inline double _Float(const freeBivector &x) {return _double(x); };
/// Returns scalar part of  circle
double _double(const circle &x);
/// Returns scalar part of  circle
inline double _Float(const circle &x) {return _double(x); };
/// Returns scalar part of  line
double _double(const line &x);
/// Returns scalar part of  line
inline double _Float(const line &x) {return _double(x); };
/// Returns scalar part of  pseudoscalar
double _double(const pseudoscalar &x);
/// Returns scalar part of  pseudoscalar
inline double _Float(const pseudoscalar &x) {return _double(x); };
/// Returns scalar part of  normalizedTranslator
double _double(const normalizedTranslator &x);
/// Returns scalar part of  normalizedTranslator
inline double _Float(const normalizedTranslator &x) {return _double(x); };
/// Returns scalar part of  translator
double _double(const translator &x);
/// Returns scalar part of  translator
inline double _Float(const translator &x) {return _double(x); };
/// Returns scalar part of  evenVersor
double _double(const evenVersor &x);
/// Returns scalar part of  evenVersor
inline double _Float(const evenVersor &x) {return _double(x); };
/// Returns scalar part of  oddVersor
double _double(const oddVersor &x);
/// Returns scalar part of  oddVersor
inline double _Float(const oddVersor &x) {return _double(x); };
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of vectorE2GA and vectorE2GA.
rotorE2GA gp(const vectorE2GA &a, const vectorE2GA &b);
/// Returns geometric product of rotorE2GA and vectorE2GA.
vectorE2GA gp(const rotorE2GA &a, const vectorE2GA &b);
/// Returns geometric product of vectorE2GA and rotorE2GA.
vectorE2GA gp(const vectorE2GA &a, const rotorE2GA &b);
/// Returns geometric product of rotorE2GA and rotorE2GA.
rotorE2GA gp(const rotorE2GA &a, const rotorE2GA &b);
/// Returns geometric product of rotorE2GA and line.
oddVersor gp(const rotorE2GA &a, const line &b);
/// Returns geometric product of circle and line.
evenVersor gp(const circle &a, const line &b);
/// Returns geometric product of bivectorE2GA and bivectorE2GA.
double gp(const bivectorE2GA &a, const bivectorE2GA &b);
/// Returns geometric product of normalizedPoint and normalizedPoint.
evenVersor gp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns geometric product of e1_t and e2_t.
I2_t gp(const e1_t &a, const e2_t &b);
/// Returns geometric product of no_t and ni_t.
evenVersor gp(const no_t &a, const ni_t &b);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vectorE2GA and vectorE2GA.
bivectorE2GA op(const vectorE2GA &a, const vectorE2GA &b);
/// Returns outer product of rotorE2GA and vectorE2GA.
vectorE2GA op(const rotorE2GA &a, const vectorE2GA &b);
/// Returns outer product of vectorE2GA and rotorE2GA.
vectorE2GA op(const vectorE2GA &a, const rotorE2GA &b);
/// Returns outer product of rotorE2GA and rotorE2GA.
rotorE2GA op(const rotorE2GA &a, const rotorE2GA &b);
/// Returns outer product of vectorE2GA and line.
pseudoscalar op(const vectorE2GA &a, const line &b);
/// Returns outer product of rotorE2GA and circle.
circle op(const rotorE2GA &a, const circle &b);
/// Returns outer product of bivectorE2GA and bivectorE2GA.
double op(const bivectorE2GA &a, const bivectorE2GA &b);
/// Returns outer product of pseudoscalar and oddVersor.
double op(const pseudoscalar &a, const oddVersor &b);
/// Returns outer product of no_t and ni_t.
noni_t op(const no_t &a, const ni_t &b);
/// Returns outer product of ni_t and no_t.
evenVersor op(const ni_t &a, const no_t &b);
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotorE2GA operator*(const vectorE2GA &a, const vectorE2GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline vectorE2GA operator*(const rotorE2GA &a, const vectorE2GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline vectorE2GA operator*(const vectorE2GA &a, const rotorE2GA &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline vectorE2GA &operator*=(vectorE2GA &a, const rotorE2GA &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotorE2GA operator*(const rotorE2GA &a, const rotorE2GA &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline rotorE2GA &operator*=(rotorE2GA &a, const rotorE2GA &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline oddVersor operator*(const rotorE2GA &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const circle &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline double operator*(const bivectorE2GA &a, const bivectorE2GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const normalizedPoint &a, const normalizedPoint &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline I2_t operator*(const e1_t &a, const e2_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const no_t &a, const ni_t &b) {
	return gp(a, b);
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline bivectorE2GA operator^(const vectorE2GA &a, const vectorE2GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline vectorE2GA operator^(const rotorE2GA &a, const vectorE2GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline vectorE2GA operator^(const vectorE2GA &a, const rotorE2GA &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline vectorE2GA &operator^=(vectorE2GA &a, const rotorE2GA &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline rotorE2GA operator^(const rotorE2GA &a, const rotorE2GA &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline rotorE2GA &operator^=(rotorE2GA &a, const rotorE2GA &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline pseudoscalar operator^(const vectorE2GA &a, const line &b) {
	return op(a, b);
}
/// returns op(a, b)
inline circle operator^(const rotorE2GA &a, const circle &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivectorE2GA &a, const bivectorE2GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const pseudoscalar &a, const oddVersor &b) {
	return op(a, b);
}
/// returns op(a, b)
inline noni_t operator^(const no_t &a, const ni_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline evenVersor operator^(const ni_t &a, const no_t &b) {
	return op(a, b);
}

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
}
inline void mv::set(double val) {
	setGroupUsage(1);
	m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
	setGroupUsage(gu);
	c2ga::copy_N(m_c, arr, c2ga_mvSize[gu]);

}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const double*srcC = src.getC();
	c2ga::copy_N(m_c, srcC, c2ga_mvSize[src.gu()]);

}
inline void no_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e1_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void ni_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void noni_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
	}
	else {
	}
}
inline void I2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
	}
	else {
	}
}
inline void I4_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
	}
	else {
	}
}
inline void I4i_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
	}
	else {
	}
}
inline void vectorE2GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[1];
		m_e2 = ptr[2];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
	}
}
inline void bivectorE2GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[2];
	}
	else {
		m_e1_e2 = 0.0;
	}
}
inline void rotorE2GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[2];
	}
	else {
		m_e1_e2 = 0.0;
	}
}
inline void normalizedPoint::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_ni = ptr[3];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_ni = 0.0;
	}
}
inline void dualCircle::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_no = ptr[0];
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_ni = ptr[3];
	}
	else {
		m_no = 0.0;
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_ni = 0.0;
	}
}
inline void freeVector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[4];
		m_e2_ni = ptr[5];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
	}
}
inline void freeBivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_e1_e2_ni = ptr[3];
	}
	else {
		m_e1_e2_ni = 0.0;
	}
}
inline void circle::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_no_e1_e2 = ptr[0];
		m_no_e1_ni = ptr[1];
		m_no_e2_ni = ptr[2];
		m_e1_e2_ni = ptr[3];
	}
	else {
		m_no_e1_e2 = 0.0;
		m_no_e1_ni = 0.0;
		m_no_e2_ni = 0.0;
		m_e1_e2_ni = 0.0;
	}
}
inline void line::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_e1_e2_ni = ptr[3];
		m_e1_no_ni = -ptr[1];
		m_e2_no_ni = -ptr[2];
	}
	else {
		m_e1_e2_ni = 0.0;
		m_e1_no_ni = 0.0;
		m_e2_no_ni = 0.0;
	}
}
inline void pseudoscalar::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
		m_no_e1_e2_ni = ptr[0];
	}
	else {
		m_no_e1_e2_ni = 0.0;
	}
}
inline void normalizedTranslator::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	else {
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[4];
		m_e2_ni = ptr[5];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
	}
}
inline void translator::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[4];
		m_e2_ni = ptr[5];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
	}
}
inline void evenVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_no_e1 = ptr[0];
		m_no_e2 = ptr[1];
		m_e1_e2 = ptr[2];
		m_e1_ni = ptr[4];
		m_e2_ni = ptr[5];
		m_no_ni = ptr[3];
		ptr += 6;
	}
	else {
		m_no_e1 = 0.0;
		m_no_e2 = 0.0;
		m_e1_e2 = 0.0;
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_no_ni = 0.0;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
		m_no_e1_e2_ni = ptr[0];
	}
	else {
		m_no_e1_e2_ni = 0.0;
	}
}
inline void oddVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_no = ptr[0];
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_ni = ptr[3];
		ptr += 4;
	}
	else {
		m_no = 0.0;
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_ni = 0.0;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_no_e1_e2 = ptr[0];
		m_no_e1_ni = ptr[1];
		m_no_e2_ni = ptr[2];
		m_e1_e2_ni = ptr[3];
	}
	else {
		m_no_e1_e2 = 0.0;
		m_no_e1_ni = 0.0;
		m_no_e2_ni = 0.0;
		m_e1_e2_ni = 0.0;
	}
}
inline void mv::set(const no_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = ptr[2] = ptr[3] = 0.0;
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = 0.0;
	ptr[1] = 1.0;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const ni_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const noni_t &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[4] = ptr[5] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const I2_t &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = ptr[5] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const I4_t &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const I4i_t &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = -1.0;
}
inline void mv::set(const vectorE2GA &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[3] = 0.0;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
}
inline void mv::set(const bivectorE2GA &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = ptr[5] = 0.0;
	ptr[2] = src.m_e1_e2;
}
inline void mv::set(const rotorE2GA &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = ptr[5] = 0.0;
	ptr[2] = src.m_e1_e2;
}
inline void mv::set(const normalizedPoint &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_ni;
}
inline void mv::set(const dualCircle &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_no;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_ni;
}
inline void mv::set(const freeVector &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = src.m_e1_ni;
	ptr[5] = src.m_e2_ni;
}
inline void mv::set(const freeBivector &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = src.m_e1_e2_ni;
}
inline void mv::set(const circle &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1_e2;
	ptr[1] = src.m_no_e1_ni;
	ptr[2] = src.m_no_e2_ni;
	ptr[3] = src.m_e1_e2_ni;
}
inline void mv::set(const line &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = 0.0;
	ptr[1] = -src.m_e1_no_ni;
	ptr[2] = -src.m_e2_no_ni;
	ptr[3] = src.m_e1_e2_ni;
}
inline void mv::set(const pseudoscalar &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1_e2_ni;
}
inline void mv::set(const normalizedTranslator &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = src.m_e1_ni;
	ptr[5] = src.m_e2_ni;
}
inline void mv::set(const translator &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = src.m_e1_ni;
	ptr[5] = src.m_e2_ni;
}
inline void mv::set(const evenVersor &src) {
	setGroupUsage(21);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = src.m_no_e1;
	ptr[1] = src.m_no_e2;
	ptr[2] = src.m_e1_e2;
	ptr[3] = src.m_no_ni;
	ptr[4] = src.m_e1_ni;
	ptr[5] = src.m_e2_ni;
	ptr += 6;
	ptr[0] = src.m_no_e1_e2_ni;
}
inline void mv::set(const oddVersor &src) {
	setGroupUsage(10);
	double *ptr = m_c;
	ptr[0] = src.m_no;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_ni;
	ptr += 4;
	ptr[0] = src.m_no_e1_e2;
	ptr[1] = src.m_no_e1_ni;
	ptr[2] = src.m_no_e2_ni;
	ptr[3] = src.m_e1_e2_ni;
}

inline double _double(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void vectorE2GA::set()
{
	m_e1 = m_e2 = 0.0;

}
inline void bivectorE2GA::set()
{
	m_e1_e2 = 0.0;

}
inline void rotorE2GA::set()
{
	m_scalar = m_e1_e2 = 0.0;

}
inline void normalizedPoint::set()
{
	m_e1 = m_e2 = m_ni = 0.0;

}
inline void dualCircle::set()
{
	m_no = m_e1 = m_e2 = m_ni = 0.0;

}
inline void freeVector::set()
{
	m_e1_ni = m_e2_ni = 0.0;

}
inline void freeBivector::set()
{
	m_e1_e2_ni = 0.0;

}
inline void circle::set()
{
	m_no_e1_e2 = m_no_e1_ni = m_no_e2_ni = m_e1_e2_ni = 0.0;

}
inline void line::set()
{
	m_e1_e2_ni = m_e1_no_ni = m_e2_no_ni = 0.0;

}
inline void pseudoscalar::set()
{
	m_no_e1_e2_ni = 0.0;

}
inline void normalizedTranslator::set()
{
	m_e1_ni = m_e2_ni = 0.0;

}
inline void translator::set()
{
	m_scalar = m_e1_ni = m_e2_ni = 0.0;

}
inline void evenVersor::set()
{
	m_scalar = m_no_e1 = m_no_e2 = m_e1_e2 = m_e1_ni = m_e2_ni = m_no_ni = m_no_e1_e2_ni = 0.0;

}
inline void oddVersor::set()
{
	m_no = m_e1 = m_e2 = m_ni = m_no_e1_e2 = m_no_e1_ni = m_no_e2_ni = m_e1_e2_ni = 0.0;

}

inline void rotorE2GA::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_e2 = 0.0;

}
inline void normalizedTranslator::set(const double scalarVal)
{
	m_e1_ni = m_e2_ni = 0.0;

}
inline void translator::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_ni = m_e2_ni = 0.0;

}
inline void evenVersor::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_no_e1 = m_no_e2 = m_e1_e2 = m_e1_ni = m_e2_ni = m_no_ni = m_no_e1_e2_ni = 0.0;

}

inline void vectorE2GA::set(const CoordinateOrder co, const double _e1, const double _e2)
{
	m_e1 = _e1;
	m_e2 = _e2;

}
inline void bivectorE2GA::set(const CoordinateOrder co, const double _e1_e2)
{
	m_e1_e2 = _e1_e2;

}
inline void rotorE2GA::set(const CoordinateOrder co, const double _scalar, const double _e1_e2)
{
	m_scalar = _scalar;
	m_e1_e2 = _e1_e2;

}
inline void normalizedPoint::set(const CoordinateOrder co, const double _e1, const double _e2, const double _ni)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_ni = _ni;

}
inline void dualCircle::set(const CoordinateOrder co, const double _no, const double _e1, const double _e2, const double _ni)
{
	m_no = _no;
	m_e1 = _e1;
	m_e2 = _e2;
	m_ni = _ni;

}
inline void freeVector::set(const CoordinateOrder co, const double _e1_ni, const double _e2_ni)
{
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;

}
inline void freeBivector::set(const CoordinateOrder co, const double _e1_e2_ni)
{
	m_e1_e2_ni = _e1_e2_ni;

}
inline void circle::set(const CoordinateOrder co, const double _no_e1_e2, const double _no_e1_ni, const double _no_e2_ni, const double _e1_e2_ni)
{
	m_no_e1_e2 = _no_e1_e2;
	m_no_e1_ni = _no_e1_ni;
	m_no_e2_ni = _no_e2_ni;
	m_e1_e2_ni = _e1_e2_ni;

}
inline void line::set(const CoordinateOrder co, const double _e1_e2_ni, const double _e1_no_ni, const double _e2_no_ni)
{
	m_e1_e2_ni = _e1_e2_ni;
	m_e1_no_ni = _e1_no_ni;
	m_e2_no_ni = _e2_no_ni;

}
inline void pseudoscalar::set(const CoordinateOrder co, const double _no_e1_e2_ni)
{
	m_no_e1_e2_ni = _no_e1_e2_ni;

}
inline void normalizedTranslator::set(const CoordinateOrder co, const double _e1_ni, const double _e2_ni)
{
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;

}
inline void translator::set(const CoordinateOrder co, const double _scalar, const double _e1_ni, const double _e2_ni)
{
	m_scalar = _scalar;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;

}
inline void evenVersor::set(const CoordinateOrder co, const double _scalar, const double _no_e1, const double _no_e2, const double _e1_e2, const double _e1_ni, const double _e2_ni, const double _no_ni, const double _no_e1_e2_ni)
{
	m_scalar = _scalar;
	m_no_e1 = _no_e1;
	m_no_e2 = _no_e2;
	m_e1_e2 = _e1_e2;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_no_ni = _no_ni;
	m_no_e1_e2_ni = _no_e1_e2_ni;

}
inline void oddVersor::set(const CoordinateOrder co, const double _no, const double _e1, const double _e2, const double _ni, const double _no_e1_e2, const double _no_e1_ni, const double _no_e2_ni, const double _e1_e2_ni)
{
	m_no = _no;
	m_e1 = _e1;
	m_e2 = _e2;
	m_ni = _ni;
	m_no_e1_e2 = _no_e1_e2;
	m_no_e1_ni = _no_e1_ni;
	m_no_e2_ni = _no_e2_ni;
	m_e1_e2_ni = _e1_e2_ni;

}

inline void vectorE2GA::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];

}
inline void bivectorE2GA::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2 = A[0];

}
inline void rotorE2GA::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_e2 = A[1];

}
inline void normalizedPoint::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_ni = A[2];

}
inline void dualCircle::set(const CoordinateOrder co, const double *A)
{
	m_no = A[0];
	m_e1 = A[1];
	m_e2 = A[2];
	m_ni = A[3];

}
inline void freeVector::set(const CoordinateOrder co, const double *A)
{
	m_e1_ni = A[0];
	m_e2_ni = A[1];

}
inline void freeBivector::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_ni = A[0];

}
inline void circle::set(const CoordinateOrder co, const double *A)
{
	m_no_e1_e2 = A[0];
	m_no_e1_ni = A[1];
	m_no_e2_ni = A[2];
	m_e1_e2_ni = A[3];

}
inline void line::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_ni = A[0];
	m_e1_no_ni = A[1];
	m_e2_no_ni = A[2];

}
inline void pseudoscalar::set(const CoordinateOrder co, const double *A)
{
	m_no_e1_e2_ni = A[0];

}
inline void normalizedTranslator::set(const CoordinateOrder co, const double *A)
{
	m_e1_ni = A[0];
	m_e2_ni = A[1];

}
inline void translator::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_ni = A[1];
	m_e2_ni = A[2];

}
inline void evenVersor::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_no_e1 = A[1];
	m_no_e2 = A[2];
	m_e1_e2 = A[3];
	m_e1_ni = A[4];
	m_e2_ni = A[5];
	m_no_ni = A[6];
	m_no_e1_e2_ni = A[7];

}
inline void oddVersor::set(const CoordinateOrder co, const double *A)
{
	m_no = A[0];
	m_e1 = A[1];
	m_e2 = A[2];
	m_ni = A[3];
	m_no_e1_e2 = A[4];
	m_no_e1_ni = A[5];
	m_no_e2_ni = A[6];
	m_e1_e2_ni = A[7];

}

inline void no_t::set(const no_t &a)
{

}
inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void ni_t::set(const ni_t &a)
{

}
inline void noni_t::set(const noni_t &a)
{

}
inline void I2_t::set(const I2_t &a)
{

}
inline void I4_t::set(const I4_t &a)
{

}
inline void I4i_t::set(const I4i_t &a)
{

}
inline void vectorE2GA::set(const vectorE2GA &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;

}
inline void bivectorE2GA::set(const bivectorE2GA &a)
{
	m_e1_e2 = a.m_e1_e2;

}
inline void rotorE2GA::set(const rotorE2GA &a)
{
	m_scalar = a.m_scalar;
	m_e1_e2 = a.m_e1_e2;

}
inline void normalizedPoint::set(const normalizedPoint &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_ni = a.m_ni;

}
inline void dualCircle::set(const dualCircle &a)
{
	m_no = a.m_no;
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_ni = a.m_ni;

}
inline void freeVector::set(const freeVector &a)
{
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;

}
inline void freeBivector::set(const freeBivector &a)
{
	m_e1_e2_ni = a.m_e1_e2_ni;

}
inline void circle::set(const circle &a)
{
	m_no_e1_e2 = a.m_no_e1_e2;
	m_no_e1_ni = a.m_no_e1_ni;
	m_no_e2_ni = a.m_no_e2_ni;
	m_e1_e2_ni = a.m_e1_e2_ni;

}
inline void line::set(const line &a)
{
	m_e1_e2_ni = a.m_e1_e2_ni;
	m_e1_no_ni = a.m_e1_no_ni;
	m_e2_no_ni = a.m_e2_no_ni;

}
inline void pseudoscalar::set(const pseudoscalar &a)
{
	m_no_e1_e2_ni = a.m_no_e1_e2_ni;

}
inline void normalizedTranslator::set(const normalizedTranslator &a)
{
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;

}
inline void translator::set(const translator &a)
{
	m_scalar = a.m_scalar;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;

}
inline void evenVersor::set(const evenVersor &a)
{
	m_scalar = a.m_scalar;
	m_no_e1 = a.m_no_e1;
	m_no_e2 = a.m_no_e2;
	m_e1_e2 = a.m_e1_e2;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_no_ni = a.m_no_ni;
	m_no_e1_e2_ni = a.m_no_e1_e2_ni;

}
inline void oddVersor::set(const oddVersor &a)
{
	m_no = a.m_no;
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_ni = a.m_ni;
	m_no_e1_e2 = a.m_no_e1_e2;
	m_no_e1_ni = a.m_no_e1_ni;
	m_no_e2_ni = a.m_no_e2_ni;
	m_e1_e2_ni = a.m_e1_e2_ni;

}


inline double no_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double no_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	return maxValue;
}
inline double e1_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e1_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 2;
	return maxValue;
}
inline double e2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 4;
	return maxValue;
}
inline double ni_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double ni_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 8;
	return maxValue;
}
inline double noni_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double noni_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 9;
	return maxValue;
}
inline double I2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 6;
	return maxValue;
}
inline double I4_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I4_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 15;
	return maxValue;
}
inline double I4i_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I4i_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 15;
	return maxValue;
}
inline double vectorE2GA::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	return maxValue;
}
inline double vectorE2GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	return maxValue;
}
inline double bivectorE2GA::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2);
	return maxValue;
}
inline double bivectorE2GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2);
	bm = 0;
	return maxValue;
}
inline double rotorE2GA::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	return maxValue;
}
inline double rotorE2GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	return maxValue;
}
inline double normalizedPoint::largestCoordinate() const {
	double maxValue = 1.0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	return maxValue;
}
inline double normalizedPoint::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 8; }
	return maxValue;
}
inline double dualCircle::largestCoordinate() const {
	double maxValue = ::fabs(m_no);
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	return maxValue;
}
inline double dualCircle::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no);
	bm = 0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 8; }
	return maxValue;
}
inline double freeVector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_ni);
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	return maxValue;
}
inline double freeVector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_ni);
	bm = 0;
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 12; }
	return maxValue;
}
inline double freeBivector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_ni);
	return maxValue;
}
inline double freeBivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_ni);
	bm = 0;
	return maxValue;
}
inline double circle::largestCoordinate() const {
	double maxValue = ::fabs(m_no_e1_e2);
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); }
	return maxValue;
}
inline double circle::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no_e1_e2);
	bm = 0;
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); bm = 11; }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); bm = 13; }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); bm = 14; }
	return maxValue;
}
inline double line::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_ni);
	if (::fabs(m_e1_no_ni) > maxValue) { maxValue = ::fabs(m_e1_no_ni); }
	if (::fabs(m_e2_no_ni) > maxValue) { maxValue = ::fabs(m_e2_no_ni); }
	return maxValue;
}
inline double line::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_ni);
	bm = 0;
	if (::fabs(m_e1_no_ni) > maxValue) { maxValue = ::fabs(m_e1_no_ni); bm = 11; }
	if (::fabs(m_e2_no_ni) > maxValue) { maxValue = ::fabs(m_e2_no_ni); bm = 13; }
	return maxValue;
}
inline double pseudoscalar::largestCoordinate() const {
	double maxValue = ::fabs(m_no_e1_e2_ni);
	return maxValue;
}
inline double pseudoscalar::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no_e1_e2_ni);
	bm = 0;
	return maxValue;
}
inline double normalizedTranslator::largestCoordinate() const {
	double maxValue = 1.0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	return maxValue;
}
inline double normalizedTranslator::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 10; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 12; }
	return maxValue;
}
inline double translator::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	return maxValue;
}
inline double translator::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 10; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 12; }
	return maxValue;
}
inline double evenVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_no_e1) > maxValue) { maxValue = ::fabs(m_no_e1); }
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); }
	return maxValue;
}
inline double evenVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_no_e1) > maxValue) { maxValue = ::fabs(m_no_e1); bm = 3; }
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); bm = 5; }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 10; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 12; }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); bm = 9; }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); bm = 15; }
	return maxValue;
}
inline double oddVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_no);
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	if (::fabs(m_no_e1_e2) > maxValue) { maxValue = ::fabs(m_no_e1_e2); }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); }
	return maxValue;
}
inline double oddVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no);
	bm = 0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 8; }
	if (::fabs(m_no_e1_e2) > maxValue) { maxValue = ::fabs(m_no_e1_e2); bm = 7; }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); bm = 11; }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); bm = 13; }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); bm = 14; }
	return maxValue;
}

inline double _double(const no_t &x) {
	return 0.0;
}
inline double _double(const e1_t &x) {
	return 0.0;
}
inline double _double(const e2_t &x) {
	return 0.0;
}
inline double _double(const ni_t &x) {
	return 0.0;
}
inline double _double(const noni_t &x) {
	return 0.0;
}
inline double _double(const I2_t &x) {
	return 0.0;
}
inline double _double(const I4_t &x) {
	return 0.0;
}
inline double _double(const I4i_t &x) {
	return 0.0;
}
inline double _double(const vectorE2GA &x) {
	return 0.0;
}
inline double _double(const bivectorE2GA &x) {
	return 0.0;
}
inline double _double(const rotorE2GA &x) {
	return x.m_scalar;
}
inline double _double(const normalizedPoint &x) {
	return 0.0;
}
inline double _double(const dualCircle &x) {
	return 0.0;
}
inline double _double(const freeVector &x) {
	return 0.0;
}
inline double _double(const freeBivector &x) {
	return 0.0;
}
inline double _double(const circle &x) {
	return 0.0;
}
inline double _double(const line &x) {
	return 0.0;
}
inline double _double(const pseudoscalar &x) {
	return 0.0;
}
inline double _double(const normalizedTranslator &x) {
	return 1.0;
}
inline double _double(const translator &x) {
	return x.m_scalar;
}
inline double _double(const evenVersor &x) {
	return x.m_scalar;
}
inline double _double(const oddVersor &x) {
	return 0.0;
}

inline void om::setIdentity() {
	c2ga::zero_16(m_m1);

	c2ga::zero_N(m_m2, 36);

	c2ga::zero_16(m_m3);

	c2ga::zero_1(m_m4);

	m_m1[0] = m_m1[5] = m_m1[10] = m_m1[15] = m_m2[0] = m_m2[7] = m_m2[14] = m_m2[21] = 
		m_m2[28] = m_m2[35] = m_m3[0] = m_m3[5] = m_m3[10] = m_m3[15] = m_m4[0] = 1.0;
}

inline void om::set(const om &src) {
	c2ga::copy_16(m_m1, src.m_m1);

	c2ga::copy_N(m_m2, src.m_m2, 36);

	c2ga::copy_16(m_m3, src.m_m3);

	c2ga::copy_1(m_m4, src.m_m4);

}
inline void grade1OM_E2GA::set(const om &src) {
	m_m1[0] =  src.m_m1[5];
	m_m1[1] =  src.m_m1[6];
	m_m1[2] =  src.m_m1[9];
	m_m1[3] =  src.m_m1[10];
}
inline void grade1OM::set(const om &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
}
inline void flatPointOM::set(const om &src) {
	m_m2[0] =  src.m_m2[28];
	m_m2[1] =  src.m_m2[29];
	m_m2[2] =  src.m_m2[27];
	m_m2[3] =  src.m_m2[34];
	m_m2[4] =  src.m_m2[35];
	m_m2[5] =  src.m_m2[33];
	m_m2[6] =  src.m_m2[22];
	m_m2[7] =  src.m_m2[23];
	m_m2[8] =  src.m_m2[21];
}
inline void om::set(const grade1OM_E2GA &src) {
	m_m1[5] =  src.m_m1[0];
	m_m1[6] =  src.m_m1[1];
	m_m1[9] =  src.m_m1[2];
	m_m1[10] =  src.m_m1[3];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[7] = m_m1[8] = m_m1[11] = m_m1[12] = 
		m_m1[13] = m_m1[14] = m_m1[15] = m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = 
		m_m2[6] = m_m2[7] = m_m2[8] = m_m2[9] = m_m2[10] = m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = 
		m_m2[15] = m_m2[16] = m_m2[17] = m_m2[18] = m_m2[19] = m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = 
		m_m2[24] = m_m2[25] = m_m2[26] = m_m2[27] = m_m2[28] = m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = 
		m_m2[33] = m_m2[34] = m_m2[35] = m_m3[0] = m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = 
		m_m3[6] = m_m3[7] = m_m3[8] = m_m3[9] = m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = 
		m_m3[15] = m_m4[0] = 0.0;
}
inline void om::set(const grade1OM &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
	m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = 
		m_m2[9] = m_m2[10] = m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = 
		m_m2[18] = m_m2[19] = m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = 
		m_m2[27] = m_m2[28] = m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = 
		m_m3[0] = m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = m_m3[8] = 
		m_m3[9] = m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m4[0] = 0.0;
}
inline void om::set(const flatPointOM &src) {
	m_m2[21] =  src.m_m2[8];
	m_m2[22] =  src.m_m2[6];
	m_m2[23] =  src.m_m2[7];
	m_m2[27] =  src.m_m2[2];
	m_m2[28] =  src.m_m2[0];
	m_m2[29] =  src.m_m2[1];
	m_m2[33] =  src.m_m2[5];
	m_m2[34] =  src.m_m2[3];
	m_m2[35] =  src.m_m2[4];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m1[9] = m_m1[10] = m_m1[11] = m_m1[12] = m_m1[13] = m_m1[14] = m_m1[15] = m_m2[0] = m_m2[1] = 
		m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = m_m2[9] = m_m2[10] = 
		m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = m_m2[18] = m_m2[19] = 
		m_m2[20] = m_m2[24] = m_m2[25] = m_m2[26] = m_m2[30] = m_m2[31] = m_m2[32] = m_m3[0] = m_m3[1] = 
		m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = m_m3[8] = m_m3[9] = m_m3[10] = 
		m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m4[0] = 0.0;
}

inline void grade1OM_E2GA::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[2] = 0.0;

	m_m1[1] = 0.0;
	m_m1[3] = 1.0;

}

inline void grade1OM::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[4] = m_m1[8] = m_m1[12] = 0.0;

	m_m1[1] = m_m1[9] = m_m1[13] = 0.0;
	m_m1[5] = 1.0;

	m_m1[2] = m_m1[6] = m_m1[14] = 0.0;
	m_m1[10] = 1.0;

	m_m1[3] = m_m1[7] = m_m1[11] = 0.0;
	m_m1[15] = 1.0;

}

inline void flatPointOM::setIdentity()
{
	m_m2[0] = 1.0;
	m_m2[3] = m_m2[6] = 0.0;

	m_m2[1] = m_m2[7] = 0.0;
	m_m2[4] = 1.0;

	m_m2[2] = m_m2[5] = 0.0;
	m_m2[8] = 1.0;

}

inline void grade1OM_E2GA::set(const grade1OM_E2GA &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[2] = src.m_m1[2];

	m_m1[1] = src.m_m1[1];
	m_m1[3] = src.m_m1[3];

}

inline void grade1OM::set(const grade1OM &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[4] = src.m_m1[4];
	m_m1[8] = src.m_m1[8];
	m_m1[12] = src.m_m1[12];

	m_m1[1] = src.m_m1[1];
	m_m1[5] = src.m_m1[5];
	m_m1[9] = src.m_m1[9];
	m_m1[13] = src.m_m1[13];

	m_m1[2] = src.m_m1[2];
	m_m1[6] = src.m_m1[6];
	m_m1[10] = src.m_m1[10];
	m_m1[14] = src.m_m1[14];

	m_m1[3] = src.m_m1[3];
	m_m1[7] = src.m_m1[7];
	m_m1[11] = src.m_m1[11];
	m_m1[15] = src.m_m1[15];

}

inline void flatPointOM::set(const flatPointOM &src)
{
	m_m2[0] = src.m_m2[0];
	m_m2[3] = src.m_m2[3];
	m_m2[6] = src.m_m2[6];

	m_m2[1] = src.m_m2[1];
	m_m2[4] = src.m_m2[4];
	m_m2[7] = src.m_m2[7];

	m_m2[2] = src.m_m2[2];
	m_m2[5] = src.m_m2[5];
	m_m2[8] = src.m_m2[8];

}
inline void grade1OM_E2GA::set(const vectorE2GA &ie1, const vectorE2GA &ie2)
{
	// Set image of e1
	m_m1[0] = ie1.m_e1;
	m_m1[2] = ie1.m_e2;

	// Set image of e2
	m_m1[1] = ie2.m_e1;
	m_m1[3] = ie2.m_e2;

}
inline void grade1OM::set(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini)
{
	// Set image of no
	m_m1[0] = ino.m_no;
	m_m1[4] = ino.m_e1;
	m_m1[8] = ino.m_e2;
	m_m1[12] = ino.m_ni;

	// Set image of e1
	m_m1[1] = ie1.m_no;
	m_m1[5] = ie1.m_e1;
	m_m1[9] = ie1.m_e2;
	m_m1[13] = ie1.m_ni;

	// Set image of e2
	m_m1[2] = ie2.m_no;
	m_m1[6] = ie2.m_e1;
	m_m1[10] = ie2.m_e2;
	m_m1[14] = ie2.m_ni;

	// Set image of ni
	m_m1[3] = ini.m_no;
	m_m1[7] = ini.m_e1;
	m_m1[11] = ini.m_e2;
	m_m1[15] = ini.m_ni;

}
inline void flatPointOM::set(const dualCircle &ino, const dualCircle &ie1, const dualCircle &ie2, const dualCircle &ini)
{
	// Set image of e1^ni
	m_m2[0] = (ie1.m_e1*ini.m_ni-ie1.m_ni*ini.m_e1);
	m_m2[3] = (ie1.m_e2*ini.m_ni-ie1.m_ni*ini.m_e2);
	m_m2[6] = (-ie1.m_ni*ini.m_no+ie1.m_no*ini.m_ni);

	// Set image of e2^ni
	m_m2[1] = (ie2.m_e1*ini.m_ni-ie2.m_ni*ini.m_e1);
	m_m2[4] = (ie2.m_e2*ini.m_ni-ie2.m_ni*ini.m_e2);
	m_m2[7] = (-ie2.m_ni*ini.m_no+ie2.m_no*ini.m_ni);

	// Set image of no^ni
	m_m2[2] = (-ini.m_e1*ino.m_ni+ini.m_ni*ino.m_e1);
	m_m2[5] = (-ini.m_e2*ino.m_ni+ini.m_ni*ino.m_e2);
	m_m2[8] = (ini.m_ni*ino.m_no-ini.m_no*ino.m_ni);

}
inline void grade1OM_E2GA::set(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[2] = M[2];

	// Set image of e2
	m_m1[1] = M[1];
	m_m1[3] = M[3];

}
inline void grade1OM::set(const double *M)
{
	// Set image of no
	m_m1[0] = M[0];
	m_m1[4] = M[4];
	m_m1[8] = M[8];
	m_m1[12] = M[12];

	// Set image of e1
	m_m1[1] = M[1];
	m_m1[5] = M[5];
	m_m1[9] = M[9];
	m_m1[13] = M[13];

	// Set image of e2
	m_m1[2] = M[2];
	m_m1[6] = M[6];
	m_m1[10] = M[10];
	m_m1[14] = M[14];

	// Set image of ni
	m_m1[3] = M[3];
	m_m1[7] = M[7];
	m_m1[11] = M[11];
	m_m1[15] = M[15];

}
inline void flatPointOM::set(const double *M)
{
	// Set image of e1^ni
	m_m2[0] = (-M[13]*M[7]+M[15]*M[5]);
	m_m2[3] = (-M[11]*M[13]+M[15]*M[9]);
	m_m2[6] = (M[1]*M[15]-M[13]*M[3]);

	// Set image of e2^ni
	m_m2[1] = (-M[14]*M[7]+M[15]*M[6]);
	m_m2[4] = (M[10]*M[15]-M[11]*M[14]);
	m_m2[7] = (-M[14]*M[3]+M[15]*M[2]);

	// Set image of no^ni
	m_m2[2] = (-M[12]*M[7]+M[15]*M[4]);
	m_m2[5] = (-M[11]*M[12]+M[15]*M[8]);
	m_m2[8] = (M[0]*M[15]-M[12]*M[3]);

}
inline void grade1OM_E2GA::setTranspose(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[2] = M[1];

	// Set image of e2
	m_m1[1] = M[2];
	m_m1[3] = M[3];

}
inline void grade1OM::setTranspose(const double *M)
{
	// Set image of no
	m_m1[0] = M[0];
	m_m1[4] = M[1];
	m_m1[8] = M[2];
	m_m1[12] = M[3];

	// Set image of e1
	m_m1[1] = M[4];
	m_m1[5] = M[5];
	m_m1[9] = M[6];
	m_m1[13] = M[7];

	// Set image of e2
	m_m1[2] = M[8];
	m_m1[6] = M[9];
	m_m1[10] = M[10];
	m_m1[14] = M[11];

	// Set image of ni
	m_m1[3] = M[12];
	m_m1[7] = M[13];
	m_m1[11] = M[14];
	m_m1[15] = M[15];

}
inline void flatPointOM::setTranspose(const double *M)
{
	// Set image of e1^ni
	m_m2[0] = (-M[13]*M[7]+M[15]*M[5]);
	m_m2[3] = (-M[14]*M[7]+M[15]*M[6]);
	m_m2[6] = (-M[12]*M[7]+M[15]*M[4]);

	// Set image of e2^ni
	m_m2[1] = (-M[11]*M[13]+M[15]*M[9]);
	m_m2[4] = (M[10]*M[15]-M[11]*M[14]);
	m_m2[7] = (-M[11]*M[12]+M[15]*M[8]);

	// Set image of no^ni
	m_m2[2] = (M[1]*M[15]-M[13]*M[3]);
	m_m2[5] = (-M[14]*M[3]+M[15]*M[2]);
	m_m2[8] = (M[0]*M[15]-M[12]*M[3]);

}
inline rotorE2GA gp(const vectorE2GA &a, const vectorE2GA &b)
{
	return rotorE2GA(rotorE2GA::coord_scalar_e1e2,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1) // e1_e2
		);

}
inline vectorE2GA gp(const rotorE2GA &a, const vectorE2GA &b)
{
	return vectorE2GA(vectorE2GA::coord_e1_e2,
			(a.m_e1_e2*b.m_e2+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_scalar*b.m_e2) // e2
		);

}
inline vectorE2GA gp(const vectorE2GA &a, const rotorE2GA &b)
{
	return vectorE2GA(vectorE2GA::coord_e1_e2,
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar) // e2
		);

}
inline rotorE2GA gp(const rotorE2GA &a, const rotorE2GA &b)
{
	return rotorE2GA(rotorE2GA::coord_scalar_e1e2,
			(-a.m_e1_e2*b.m_e1_e2+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar+a.m_scalar*b.m_e1_e2) // e1_e2
		);

}
inline oddVersor gp(const rotorE2GA &a, const line &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_ni_noe1e2_noe1ni_noe2ni_e1e2ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			-a.m_e1_e2*b.m_e1_e2_ni, // ni
			0.0, // no_e1_e2
			(-a.m_e1_e2*b.m_e2_no_ni-a.m_scalar*b.m_e1_no_ni), // no_e1_ni
			(a.m_e1_e2*b.m_e1_no_ni-a.m_scalar*b.m_e2_no_ni), // no_e2_ni
			a.m_scalar*b.m_e1_e2_ni // e1_e2_ni
		);

}
inline evenVersor gp(const circle &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_e1e2_e1ni_e2ni_noni_noe1e2ni,
			(a.m_no_e1_e2*b.m_e1_e2_ni-a.m_no_e1_ni*b.m_e1_no_ni-a.m_no_e2_ni*b.m_e2_no_ni), // scalar
			a.m_no_e1_e2*b.m_e2_no_ni, // no_e1
			-a.m_no_e1_e2*b.m_e1_no_ni, // no_e2
			(-a.m_no_e1_ni*b.m_e2_no_ni+a.m_no_e2_ni*b.m_e1_no_ni), // e1_e2
			(a.m_e1_e2_ni*b.m_e2_no_ni+a.m_no_e2_ni*b.m_e1_e2_ni), // e1_ni
			(-a.m_e1_e2_ni*b.m_e1_no_ni-a.m_no_e1_ni*b.m_e1_e2_ni), // e2_ni
			-a.m_no_e1_e2*b.m_e1_e2_ni, // no_ni
			0.0 // no_e1_e2_ni
		);

}
inline double gp(const bivectorE2GA &a, const bivectorE2GA &b)
{
	return -a.m_e1_e2*b.m_e1_e2;

}
inline evenVersor gp(const normalizedPoint &a, const normalizedPoint &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_e1e2_e1ni_e2ni_noni_noe1e2ni,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2-a.m_ni-b.m_ni), // scalar
			(-a.m_e1+b.m_e1), // no_e1
			(-a.m_e2+b.m_e2), // no_e2
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e1*b.m_ni-a.m_ni*b.m_e1), // e1_ni
			(a.m_e2*b.m_ni-a.m_ni*b.m_e2), // e2_ni
			(-a.m_ni+b.m_ni), // no_ni
			0.0 // no_e1_e2_ni
		);

}
inline I2_t gp(const e1_t &a, const e2_t &b)
{
	return I2_t(		);

}
inline evenVersor gp(const no_t &a, const ni_t &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_e1e2_e1ni_e2ni_noni_noe1e2ni,
			-1.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // e1_e2
			0.0, // e1_ni
			0.0, // e2_ni
			1.0, // no_ni
			0.0 // no_e1_e2_ni
		);

}
inline bivectorE2GA op(const vectorE2GA &a, const vectorE2GA &b)
{
	return bivectorE2GA(bivectorE2GA::coord_e1e2,
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1) // e1_e2
		);

}
inline vectorE2GA op(const rotorE2GA &a, const vectorE2GA &b)
{
	return vectorE2GA(vectorE2GA::coord_e1_e2,
			a.m_scalar*b.m_e1, // e1
			a.m_scalar*b.m_e2 // e2
		);

}
inline vectorE2GA op(const vectorE2GA &a, const rotorE2GA &b)
{
	return vectorE2GA(vectorE2GA::coord_e1_e2,
			a.m_e1*b.m_scalar, // e1
			a.m_e2*b.m_scalar // e2
		);

}
inline rotorE2GA op(const rotorE2GA &a, const rotorE2GA &b)
{
	return rotorE2GA(rotorE2GA::coord_scalar_e1e2,
			a.m_scalar*b.m_scalar, // scalar
			(a.m_e1_e2*b.m_scalar+a.m_scalar*b.m_e1_e2) // e1_e2
		);

}
inline pseudoscalar op(const vectorE2GA &a, const line &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2ni,
			(a.m_e1*b.m_e2_no_ni-a.m_e2*b.m_e1_no_ni) // no_e1_e2_ni
		);

}
inline circle op(const rotorE2GA &a, const circle &b)
{
	return circle(circle::coord_noe1e2_noe1ni_noe2ni_e1e2ni,
			a.m_scalar*b.m_no_e1_e2, // no_e1_e2
			a.m_scalar*b.m_no_e1_ni, // no_e1_ni
			a.m_scalar*b.m_no_e2_ni, // no_e2_ni
			a.m_scalar*b.m_e1_e2_ni // e1_e2_ni
		);

}
inline double op(const bivectorE2GA &a, const bivectorE2GA &b)
{
	return 0.0;

}
inline double op(const pseudoscalar &a, const oddVersor &b)
{
	return 0.0;

}
inline noni_t op(const no_t &a, const ni_t &b)
{
	return noni_t(		);

}
inline evenVersor op(const ni_t &a, const no_t &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_e1e2_e1ni_e2ni_noni_noe1e2ni,
			0.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // e1_e2
			0.0, // e1_ni
			0.0, // e2_ni
			-1.0, // no_ni
			0.0 // no_e1_e2_ni
		);

}


/** structure used by custom parser */
struct c2gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct c2gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace c2ga
#endif /* _C2GA_H_ */
