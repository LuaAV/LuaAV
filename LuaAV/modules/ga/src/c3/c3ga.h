/*
Gaigen 2.5 Test Suite
*/
/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage c3ga documentation
 *
 * c3ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _C3GA_H_
#define _C3GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <time.h> /* used to seed random generator */
namespace c3ga {

// group: 1
#define GROUP_0 1
// group: no, e1, e2, e3, ni
#define GROUP_1 2
// group: no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni
#define GROUP_2 4
// group: no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni
#define GROUP_3 8
// group: no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni
#define GROUP_4 16
// group: no^e1^e2^e3^ni
#define GROUP_5 32
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16
#define GRADE_5 32


/// The dimension of the space:
extern const int c3ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int c3ga_nbGroups;

/// The constants for the groups in an array:
extern const int c3ga_groups[];

/// The constants for the grades in an array:
extern const int c3ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool c3ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int c3ga_groupSize[6];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int c3ga_mvSize[64];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *c3ga_basisVectorNames[5];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int c3ga_basisElements[32][6];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double c3ga_basisElementSignByIndex[32];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double c3ga_basisElementSignByBitmap[32];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int c3ga_basisElementIndexByBitmap[32];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int c3ga_basisElementBitmapByIndex[32];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int c3ga_basisElementGradeByBitmap[32];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int c3ga_basisElementGroupByBitmap[32];
class mv;
class no_t;
class e1_t;
class e2_t;
class e3_t;
class ni_t;
class noni_t;
class I3_t;
class I5_t;
class I5i_t;
class vectorE3GA;
class bivectorE3GA;
class rotorE3GA;
class normalizedPoint;
class dualSphere;
class dualPlane;
class freeVector;
class freeBivector;
class flatPoint;
class pointPair;
class line;
class circle;
class sphere;
class plane;
class pseudoscalar;
class normalizedTranslator;
class translator;
class RBM;
class evenVersor;
class oddVersor;
class om;
class grade1OM_E3GA;
class grade1OM;
class flatPointOM;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 6 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:no, e1, e2, e3, ni  (grade 1).
/// group 2:no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni  (grade 2).
/// group 3:no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni  (grade 3).
/// group 4:no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni  (grade 4).
/// group 5:no^e1^e2^e3^ni  (grade 5).
/// 
/// 32 doubles are allocated inside the struct.
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates
	double m_c[32]; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  {set();}

	/// Copy constructor.
	inline mv(const mv&A)  {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

	/// Converts a no_t to a mv.
	inline mv(const no_t&A)  {set(A);}
	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  {set(A);}
	/// Converts a e3_t to a mv.
	inline mv(const e3_t&A)  {set(A);}
	/// Converts a ni_t to a mv.
	inline mv(const ni_t&A)  {set(A);}
	/// Converts a noni_t to a mv.
	inline mv(const noni_t&A)  {set(A);}
	/// Converts a I3_t to a mv.
	inline mv(const I3_t&A)  {set(A);}
	/// Converts a I5_t to a mv.
	inline mv(const I5_t&A)  {set(A);}
	/// Converts a I5i_t to a mv.
	inline mv(const I5i_t&A)  {set(A);}
	/// Converts a vectorE3GA to a mv.
	inline mv(const vectorE3GA&A)  {set(A);}
	/// Converts a bivectorE3GA to a mv.
	inline mv(const bivectorE3GA&A)  {set(A);}
	/// Converts a rotorE3GA to a mv.
	inline mv(const rotorE3GA&A)  {set(A);}
	/// Converts a normalizedPoint to a mv.
	inline mv(const normalizedPoint&A)  {set(A);}
	/// Converts a dualSphere to a mv.
	inline mv(const dualSphere&A)  {set(A);}
	/// Converts a dualPlane to a mv.
	inline mv(const dualPlane&A)  {set(A);}
	/// Converts a freeVector to a mv.
	inline mv(const freeVector&A)  {set(A);}
	/// Converts a freeBivector to a mv.
	inline mv(const freeBivector&A)  {set(A);}
	/// Converts a flatPoint to a mv.
	inline mv(const flatPoint&A)  {set(A);}
	/// Converts a pointPair to a mv.
	inline mv(const pointPair&A)  {set(A);}
	/// Converts a line to a mv.
	inline mv(const line&A)  {set(A);}
	/// Converts a circle to a mv.
	inline mv(const circle&A)  {set(A);}
	/// Converts a sphere to a mv.
	inline mv(const sphere&A)  {set(A);}
	/// Converts a plane to a mv.
	inline mv(const plane&A)  {set(A);}
	/// Converts a pseudoscalar to a mv.
	inline mv(const pseudoscalar&A)  {set(A);}
	/// Converts a normalizedTranslator to a mv.
	inline mv(const normalizedTranslator&A)  {set(A);}
	/// Converts a translator to a mv.
	inline mv(const translator&A)  {set(A);}
	/// Converts a RBM to a mv.
	inline mv(const RBM&A)  {set(A);}
	/// Converts a evenVersor to a mv.
	inline mv(const evenVersor&A)  {set(A);}
	/// Converts a oddVersor to a mv.
	inline mv(const oddVersor&A)  {set(A);}


	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const no_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const ni_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const noni_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I5_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I5i_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vectorE3GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivectorE3GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const rotorE3GA &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const dualSphere &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const dualPlane &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const freeVector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const freeBivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const flatPoint &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pointPair &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const line &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const circle &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const sphere &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const plane &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pseudoscalar &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const normalizedTranslator &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const translator &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const RBM &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const evenVersor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const oddVersor &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of no_t A
	void set(const no_t &A);
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of e3_t A
	void set(const e3_t &A);
	/// Sets this mv to the value of ni_t A
	void set(const ni_t &A);
	/// Sets this mv to the value of noni_t A
	void set(const noni_t &A);
	/// Sets this mv to the value of I3_t A
	void set(const I3_t &A);
	/// Sets this mv to the value of I5_t A
	void set(const I5_t &A);
	/// Sets this mv to the value of I5i_t A
	void set(const I5i_t &A);
	/// Sets this mv to the value of vectorE3GA A
	void set(const vectorE3GA &A);
	/// Sets this mv to the value of bivectorE3GA A
	void set(const bivectorE3GA &A);
	/// Sets this mv to the value of rotorE3GA A
	void set(const rotorE3GA &A);
	/// Sets this mv to the value of normalizedPoint A
	void set(const normalizedPoint &A);
	/// Sets this mv to the value of dualSphere A
	void set(const dualSphere &A);
	/// Sets this mv to the value of dualPlane A
	void set(const dualPlane &A);
	/// Sets this mv to the value of freeVector A
	void set(const freeVector &A);
	/// Sets this mv to the value of freeBivector A
	void set(const freeBivector &A);
	/// Sets this mv to the value of flatPoint A
	void set(const flatPoint &A);
	/// Sets this mv to the value of pointPair A
	void set(const pointPair &A);
	/// Sets this mv to the value of line A
	void set(const line &A);
	/// Sets this mv to the value of circle A
	void set(const circle &A);
	/// Sets this mv to the value of sphere A
	void set(const sphere &A);
	/// Sets this mv to the value of plane A
	void set(const plane &A);
	/// Sets this mv to the value of pseudoscalar A
	void set(const pseudoscalar &A);
	/// Sets this mv to the value of normalizedTranslator A
	void set(const normalizedTranslator &A);
	/// Sets this mv to the value of translator A
	void set(const translator &A);
	/// Sets this mv to the value of RBM A
	void set(const RBM &A);
	/// Sets this mv to the value of evenVersor A
	void set(const evenVersor &A);
	/// Sets this mv to the value of oddVersor A
	void set(const oddVersor &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[c3ga_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the no coordinate of this mv.
	inline double get_no() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the e1 coordinate of this mv.
	inline double get_e1() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the e2 coordinate of this mv.
	inline double get_e2() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the e3 coordinate of this mv.
	inline double get_e3() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 3] : 0.0;
	}
	/// Returns the ni coordinate of this mv.
	inline double get_ni() const {
		return (m_gu & 2) ? m_c[c3ga_mvSize[m_gu & 1] + 4] : 0.0;
	}
	/// Returns the no_e1 coordinate of this mv.
	inline double get_no_e1() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the no_e2 coordinate of this mv.
	inline double get_no_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline double get_e1_e2() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the no_e3 coordinate of this mv.
	inline double get_no_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 3] : 0.0;
	}
	/// Returns the e1_e3 coordinate of this mv.
	inline double get_e1_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 4] : 0.0;
	}
	/// Returns the e2_e3 coordinate of this mv.
	inline double get_e2_e3() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 5] : 0.0;
	}
	/// Returns the no_ni coordinate of this mv.
	inline double get_no_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 6] : 0.0;
	}
	/// Returns the e1_ni coordinate of this mv.
	inline double get_e1_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 7] : 0.0;
	}
	/// Returns the e2_ni coordinate of this mv.
	inline double get_e2_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 8] : 0.0;
	}
	/// Returns the e3_ni coordinate of this mv.
	inline double get_e3_ni() const {
		return (m_gu & 4) ? m_c[c3ga_mvSize[m_gu & 3] + 9] : 0.0;
	}
	/// Returns the no_e1_e2 coordinate of this mv.
	inline double get_no_e1_e2() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns the no_e1_e3 coordinate of this mv.
	inline double get_no_e1_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 1] : 0.0;
	}
	/// Returns the no_e2_e3 coordinate of this mv.
	inline double get_no_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 2] : 0.0;
	}
	/// Returns the e1_e2_e3 coordinate of this mv.
	inline double get_e1_e2_e3() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 3] : 0.0;
	}
	/// Returns the no_e1_ni coordinate of this mv.
	inline double get_no_e1_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 4] : 0.0;
	}
	/// Returns the no_e2_ni coordinate of this mv.
	inline double get_no_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 5] : 0.0;
	}
	/// Returns the e1_e2_ni coordinate of this mv.
	inline double get_e1_e2_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 6] : 0.0;
	}
	/// Returns the no_e3_ni coordinate of this mv.
	inline double get_no_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 7] : 0.0;
	}
	/// Returns the e1_e3_ni coordinate of this mv.
	inline double get_e1_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 8] : 0.0;
	}
	/// Returns the e2_e3_ni coordinate of this mv.
	inline double get_e2_e3_ni() const {
		return (m_gu & 8) ? m_c[c3ga_mvSize[m_gu & 7] + 9] : 0.0;
	}
	/// Returns the no_e1_e2_e3 coordinate of this mv.
	inline double get_no_e1_e2_e3() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 0] : 0.0;
	}
	/// Returns the no_e1_e2_ni coordinate of this mv.
	inline double get_no_e1_e2_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 1] : 0.0;
	}
	/// Returns the no_e1_e3_ni coordinate of this mv.
	inline double get_no_e1_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 2] : 0.0;
	}
	/// Returns the no_e2_e3_ni coordinate of this mv.
	inline double get_no_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 3] : 0.0;
	}
	/// Returns the e1_e2_e3_ni coordinate of this mv.
	inline double get_e1_e2_e3_ni() const {
		return (m_gu & 16) ? m_c[c3ga_mvSize[m_gu & 15] + 4] : 0.0;
	}
	/// Returns the no_e1_e2_e3_ni coordinate of this mv.
	inline double get_no_e1_e2_e3_ni() const {
		return (m_gu & 32) ? m_c[c3ga_mvSize[m_gu & 31] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[c3ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the no coordinate of this mv.
	inline void set_no(double val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(double val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(double val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the e3 coordinate of this mv.
	inline void set_e3(double val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the ni coordinate of this mv.
	inline void set_ni(double val)  {
		reserveGroup_1();
		m_c[c3ga_mvSize[m_gu & 1] + 4] = val;
	}
	/// Sets the no_e1 coordinate of this mv.
	inline void set_no_e1(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the no_e2 coordinate of this mv.
	inline void set_no_e2(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the no_e3 coordinate of this mv.
	inline void set_no_e3(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the e1_e3 coordinate of this mv.
	inline void set_e1_e3(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the e2_e3 coordinate of this mv.
	inline void set_e2_e3(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the no_ni coordinate of this mv.
	inline void set_no_ni(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 6] = val;
	}
	/// Sets the e1_ni coordinate of this mv.
	inline void set_e1_ni(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 7] = val;
	}
	/// Sets the e2_ni coordinate of this mv.
	inline void set_e2_ni(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 8] = val;
	}
	/// Sets the e3_ni coordinate of this mv.
	inline void set_e3_ni(double val)  {
		reserveGroup_2();
		m_c[c3ga_mvSize[m_gu & 3] + 9] = val;
	}
	/// Sets the no_e1_e2 coordinate of this mv.
	inline void set_no_e1_e2(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the no_e1_e3 coordinate of this mv.
	inline void set_no_e1_e3(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the no_e2_e3 coordinate of this mv.
	inline void set_no_e2_e3(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the e1_e2_e3 coordinate of this mv.
	inline void set_e1_e2_e3(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the no_e1_ni coordinate of this mv.
	inline void set_no_e1_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 4] = val;
	}
	/// Sets the no_e2_ni coordinate of this mv.
	inline void set_no_e2_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 5] = val;
	}
	/// Sets the e1_e2_ni coordinate of this mv.
	inline void set_e1_e2_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 6] = val;
	}
	/// Sets the no_e3_ni coordinate of this mv.
	inline void set_no_e3_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 7] = val;
	}
	/// Sets the e1_e3_ni coordinate of this mv.
	inline void set_e1_e3_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 8] = val;
	}
	/// Sets the e2_e3_ni coordinate of this mv.
	inline void set_e2_e3_ni(double val)  {
		reserveGroup_3();
		m_c[c3ga_mvSize[m_gu & 7] + 9] = val;
	}
	/// Sets the no_e1_e2_e3 coordinate of this mv.
	inline void set_no_e1_e2_e3(double val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 0] = val;
	}
	/// Sets the no_e1_e2_ni coordinate of this mv.
	inline void set_no_e1_e2_ni(double val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 1] = val;
	}
	/// Sets the no_e1_e3_ni coordinate of this mv.
	inline void set_no_e1_e3_ni(double val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 2] = val;
	}
	/// Sets the no_e2_e3_ni coordinate of this mv.
	inline void set_no_e2_e3_ni(double val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 3] = val;
	}
	/// Sets the e1_e2_e3_ni coordinate of this mv.
	inline void set_e1_e2_e3_ni(double val)  {
		reserveGroup_4();
		m_c[c3ga_mvSize[m_gu & 15] + 4] = val;
	}
	/// Sets the no_e1_e2_e3_ni coordinate of this mv.
	inline void set_no_e1_e2_e3_ni(double val)  {
		reserveGroup_5();
		m_c[c3ga_mvSize[m_gu & 31] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[6], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[32]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + c3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + c3ga_mvSize[groupUsageBelow];
			for (int i = c3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_5.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_5() {
		if ((m_gu & 32) == 0) {
			const int groupUsageBelow = m_gu & 31;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 32;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 63;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + c3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type no_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class no_t
{
public:
public:

	/// Floating point type used by no_t 
	typedef double Float;
	/// Array indices of no_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new no_t with variable coordinates set to 0.
	inline no_t() {set();}

	/// Copy constructor.
	inline no_t(const no_t &A) {set(A);}



	/// Constructs a new no_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline no_t(mv &A, int filler) {set(A);}


	/// Assignment operator (no_t).
	inline no_t &operator=(const no_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline no_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const no_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class no_t

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef double Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef double Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline double get_e2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type e3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e3 = 1
/// 
/// 
class e3_t
{
public:
public:

	/// Floating point type used by e3_t 
	typedef double Float;
	/// Array indices of e3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e3_t with variable coordinates set to 0.
	inline e3_t() {set();}

	/// Copy constructor.
	inline e3_t(const e3_t &A) {set(A);}



	/// Constructs a new e3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e3_t).
	inline e3_t &operator=(const e3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e3 coordinate.
	inline double get_e3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e3_t

/// This class can hold a specialized multivector of type ni_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - ni = 1
/// 
/// 
class ni_t
{
public:
public:

	/// Floating point type used by ni_t 
	typedef double Float;
	/// Array indices of ni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new ni_t with variable coordinates set to 0.
	inline ni_t() {set();}

	/// Copy constructor.
	inline ni_t(const ni_t &A) {set(A);}



	/// Constructs a new ni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline ni_t(mv &A, int filler) {set(A);}


	/// Assignment operator (ni_t).
	inline ni_t &operator=(const ni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline ni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const ni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the ni coordinate.
	inline double get_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class ni_t

/// This class can hold a specialized multivector of type noni_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^ni = 1
/// 
/// 
class noni_t
{
public:
public:

	/// Floating point type used by noni_t 
	typedef double Float;
	/// Array indices of noni_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new noni_t with variable coordinates set to 0.
	inline noni_t() {set();}

	/// Copy constructor.
	inline noni_t(const noni_t &A) {set(A);}



	/// Constructs a new noni_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline noni_t(mv &A, int filler) {set(A);}


	/// Assignment operator (noni_t).
	inline noni_t &operator=(const noni_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline noni_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const noni_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class noni_t

/// This class can hold a specialized multivector of type I3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1^e2^e3 = 1
/// 
/// 
class I3_t
{
public:
public:

	/// Floating point type used by I3_t 
	typedef double Float;
	/// Array indices of I3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I3_t with variable coordinates set to 0.
	inline I3_t() {set();}

	/// Copy constructor.
	inline I3_t(const I3_t &A) {set(A);}



	/// Constructs a new I3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I3_t).
	inline I3_t &operator=(const I3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I3_t

/// This class can hold a specialized multivector of type I5_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^e1^e2^e3^ni = 1
/// 
/// 
class I5_t
{
public:
public:

	/// Floating point type used by I5_t 
	typedef double Float;
	/// Array indices of I5_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I5_t with variable coordinates set to 0.
	inline I5_t() {set();}

	/// Copy constructor.
	inline I5_t(const I5_t &A) {set(A);}



	/// Constructs a new I5_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I5_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I5_t).
	inline I5_t &operator=(const I5_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I5_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I5_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^e3^ni coordinate.
	inline double get_no_e1_e2_e3_ni() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I5_t

/// This class can hold a specialized multivector of type I5i_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - no^e1^e2^e3^ni = -1
/// 
/// 
class I5i_t
{
public:
public:

	/// Floating point type used by I5i_t 
	typedef double Float;
	/// Array indices of I5i_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I5i_t with variable coordinates set to 0.
	inline I5i_t() {set();}

	/// Copy constructor.
	inline I5i_t(const I5i_t &A) {set(A);}



	/// Constructs a new I5i_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I5i_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I5i_t).
	inline I5i_t &operator=(const I5i_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I5i_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I5i_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^e3^ni coordinate.
	inline double get_no_e1_e2_e3_ni() const { return -1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I5i_t

/// This class can hold a specialized multivector of type vectorE3GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vectorE3GA
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
public:

	/// Floating point type used by vectorE3GA 
	typedef double Float;
	/// Array indices of vectorE3GA coordinates.
	typedef enum {
		/// index of coordinate for e1 in vectorE3GA
		E1 = 0, 
		/// index of coordinate for e2 in vectorE3GA
		E2 = 1, 
		/// index of coordinate for e3 in vectorE3GA
		E3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3
	} CoordinateOrder;

	/// Constructs a new vectorE3GA with variable coordinates set to 0.
	inline vectorE3GA() {set();}

	/// Copy constructor.
	inline vectorE3GA(const vectorE3GA &A) {set(A);}



	/// Constructs a new vectorE3GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vectorE3GA(mv &A, int filler) {set(A);}

	/// Constructs a new vectorE3GA. Coordinate values come from 'A'.
	inline vectorE3GA(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new vectorE3GA with each coordinate specified.
	inline vectorE3GA(const CoordinateOrder co,  double e1, double e2, double e3) {
		set(co, e1, e2, e3);
	}

	/// Assignment operator (vectorE3GA).
	inline vectorE3GA &operator=(const vectorE3GA &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vectorE3GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vectorE3GA &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class vectorE3GA

/// This class can hold a specialized multivector of type bivectorE3GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2  (array index: E1_E2 = 0)
///   - coordinate e2^e3  (array index: E2_E3 = 1)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivectorE3GA
{
public:
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by bivectorE3GA 
	typedef double Float;
	/// Array indices of bivectorE3GA coordinates.
	typedef enum {
		/// index of coordinate for e1^e2 in bivectorE3GA
		E1_E2 = 0, 
		/// index of coordinate for e2^e3 in bivectorE3GA
		E2_E3 = 1, 
		/// index of coordinate for -1*e1^e3 in bivectorE3GA
		E3_E1 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new bivectorE3GA with variable coordinates set to 0.
	inline bivectorE3GA() {set();}

	/// Copy constructor.
	inline bivectorE3GA(const bivectorE3GA &A) {set(A);}



	/// Constructs a new bivectorE3GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivectorE3GA(mv &A, int filler) {set(A);}

	/// Constructs a new bivectorE3GA. Coordinate values come from 'A'.
	inline bivectorE3GA(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new bivectorE3GA with each coordinate specified.
	inline bivectorE3GA(const CoordinateOrder co,  double e1_e2, double e2_e3, double e3_e1) {
		set(co, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (bivectorE3GA).
	inline bivectorE3GA &operator=(const bivectorE3GA &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivectorE3GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivectorE3GA &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class bivectorE3GA

/// This class can hold a specialized multivector of type rotorE3GA.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^e2  (array index: E1_E2 = 1)
///   - coordinate e2^e3  (array index: E2_E3 = 2)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class rotorE3GA
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by rotorE3GA 
	typedef double Float;
	/// Array indices of rotorE3GA coordinates.
	typedef enum {
		/// index of coordinate for 1 in rotorE3GA
		SCALAR = 0, 
		/// index of coordinate for e1^e2 in rotorE3GA
		E1_E2 = 1, 
		/// index of coordinate for e2^e3 in rotorE3GA
		E2_E3 = 2, 
		/// index of coordinate for -1*e1^e3 in rotorE3GA
		E3_E1 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new rotorE3GA with variable coordinates set to 0.
	inline rotorE3GA() {set();}

	/// Copy constructor.
	inline rotorE3GA(const rotorE3GA &A) {set(A);}


	/// Constructs a new rotorE3GA with scalar value 'scalar'.
	inline rotorE3GA(double scalar) {set(scalar);}

	/// Constructs a new rotorE3GA from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline rotorE3GA(mv &A, int filler) {set(A);}

	/// Constructs a new rotorE3GA. Coordinate values come from 'A'.
	inline rotorE3GA(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new rotorE3GA with each coordinate specified.
	inline rotorE3GA(const CoordinateOrder co,  double scalar, double e1_e2, double e2_e3, double e3_e1) {
		set(co, scalar, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (rotorE3GA).
	inline rotorE3GA &operator=(const rotorE3GA &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline rotorE3GA &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline rotorE3GA &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const rotorE3GA &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
}; // end of class rotorE3GA

/// This class can hold a specialized multivector of type normalizedPoint.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate ni  (array index: NI = 3)
/// 
/// The constant non-zero coordinates are:
///   - no = 1
/// 
/// 
class normalizedPoint
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The ni coordinate.
	double m_ni;
public:

	/// Floating point type used by normalizedPoint 
	typedef double Float;
	/// Array indices of normalizedPoint coordinates.
	typedef enum {
		/// index of coordinate for e1 in normalizedPoint
		E1 = 0, 
		/// index of coordinate for e2 in normalizedPoint
		E2 = 1, 
		/// index of coordinate for e3 in normalizedPoint
		E3 = 2, 
		/// index of coordinate for ni in normalizedPoint
		NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_ni
	} CoordinateOrder;

	/// Constructs a new normalizedPoint with variable coordinates set to 0.
	inline normalizedPoint() {set();}

	/// Copy constructor.
	inline normalizedPoint(const normalizedPoint &A) {set(A);}



	/// Constructs a new normalizedPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedPoint(mv &A, int filler) {set(A);}

	/// Constructs a new normalizedPoint. Coordinate values come from 'A'.
	inline normalizedPoint(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new normalizedPoint with each coordinate specified.
	inline normalizedPoint(const CoordinateOrder co,  double e1, double e2, double e3, double ni) {
		set(co, e1, e2, e3, ni);
	}

	/// Assignment operator (normalizedPoint).
	inline normalizedPoint &operator=(const normalizedPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline normalizedPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3, double ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the no coordinate.
	inline double get_no() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class normalizedPoint

/// This class can hold a specialized multivector of type dualSphere.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no  (array index: NO = 0)
///   - coordinate e1  (array index: E1 = 1)
///   - coordinate e2  (array index: E2 = 2)
///   - coordinate e3  (array index: E3 = 3)
///   - coordinate ni  (array index: NI = 4)
/// 
/// The type has no constant coordinates.
/// 
/// 
class dualSphere
{
public:
	/// The no coordinate.
	double m_no;
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The ni coordinate.
	double m_ni;
public:

	/// Floating point type used by dualSphere 
	typedef double Float;
	/// Array indices of dualSphere coordinates.
	typedef enum {
		/// index of coordinate for no in dualSphere
		NO = 0, 
		/// index of coordinate for e1 in dualSphere
		E1 = 1, 
		/// index of coordinate for e2 in dualSphere
		E2 = 2, 
		/// index of coordinate for e3 in dualSphere
		E3 = 3, 
		/// index of coordinate for ni in dualSphere
		NI = 4, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_no_e1_e2_e3_ni
	} CoordinateOrder;

	/// Constructs a new dualSphere with variable coordinates set to 0.
	inline dualSphere() {set();}

	/// Copy constructor.
	inline dualSphere(const dualSphere &A) {set(A);}



	/// Constructs a new dualSphere from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline dualSphere(mv &A, int filler) {set(A);}

	/// Constructs a new dualSphere. Coordinate values come from 'A'.
	inline dualSphere(const CoordinateOrder co, const double A[5]) {set(co, A);}
	
	/// Constructs a new dualSphere with each coordinate specified.
	inline dualSphere(const CoordinateOrder co,  double no, double e1, double e2, double e3, double ni) {
		set(co, no, e1, e2, e3, ni);
	}

	/// Assignment operator (dualSphere).
	inline dualSphere &operator=(const dualSphere &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline dualSphere &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const dualSphere &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[5]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no, double e1, double e2, double e3, double ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return m_no;}
	/// Sets the no coordinate.
	inline void set_no(double no) { m_no = no;}
	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class dualSphere

/// This class can hold a specialized multivector of type dualPlane.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate ni  (array index: NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class dualPlane
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The ni coordinate.
	double m_ni;
public:

	/// Floating point type used by dualPlane 
	typedef double Float;
	/// Array indices of dualPlane coordinates.
	typedef enum {
		/// index of coordinate for e1 in dualPlane
		E1 = 0, 
		/// index of coordinate for e2 in dualPlane
		E2 = 1, 
		/// index of coordinate for e3 in dualPlane
		E3 = 2, 
		/// index of coordinate for ni in dualPlane
		NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_ni
	} CoordinateOrder;

	/// Constructs a new dualPlane with variable coordinates set to 0.
	inline dualPlane() {set();}

	/// Copy constructor.
	inline dualPlane(const dualPlane &A) {set(A);}



	/// Constructs a new dualPlane from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline dualPlane(mv &A, int filler) {set(A);}

	/// Constructs a new dualPlane. Coordinate values come from 'A'.
	inline dualPlane(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new dualPlane with each coordinate specified.
	inline dualPlane(const CoordinateOrder co,  double e1, double e2, double e3, double ni) {
		set(co, e1, e2, e3, ni);
	}

	/// Assignment operator (dualPlane).
	inline dualPlane &operator=(const dualPlane &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline dualPlane &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const dualPlane &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3, double ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class dualPlane

/// This class can hold a specialized multivector of type freeVector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
///   - coordinate e3^ni  (array index: E3_NI = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class freeVector
{
public:
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
public:

	/// Floating point type used by freeVector 
	typedef double Float;
	/// Array indices of freeVector coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in freeVector
		E1_NI = 0, 
		/// index of coordinate for e2^ni in freeVector
		E2_NI = 1, 
		/// index of coordinate for e3^ni in freeVector
		E3_NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni_e3ni
	} CoordinateOrder;

	/// Constructs a new freeVector with variable coordinates set to 0.
	inline freeVector() {set();}

	/// Copy constructor.
	inline freeVector(const freeVector &A) {set(A);}



	/// Constructs a new freeVector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline freeVector(mv &A, int filler) {set(A);}

	/// Constructs a new freeVector. Coordinate values come from 'A'.
	inline freeVector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new freeVector with each coordinate specified.
	inline freeVector(const CoordinateOrder co,  double e1_ni, double e2_ni, double e3_ni) {
		set(co, e1_ni, e2_ni, e3_ni);
	}

	/// Assignment operator (freeVector).
	inline freeVector &operator=(const freeVector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline freeVector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const freeVector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_ni, double e2_ni, double e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class freeVector

/// This class can hold a specialized multivector of type freeBivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 0)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 1)
///   - coordinate -1*e1^e3^ni  (array index: E3_E1_NI = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class freeBivector
{
public:
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
	/// The e2^e3^ni coordinate.
	double m_e2_e3_ni;
	/// The -1*e1^e3^ni coordinate.
	double m_e3_e1_ni;
public:

	/// Floating point type used by freeBivector 
	typedef double Float;
	/// Array indices of freeBivector coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^ni in freeBivector
		E1_E2_NI = 0, 
		/// index of coordinate for e2^e3^ni in freeBivector
		E2_E3_NI = 1, 
		/// index of coordinate for -1*e1^e3^ni in freeBivector
		E3_E1_NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2ni_e2e3ni_e3e1ni
	} CoordinateOrder;

	/// Constructs a new freeBivector with variable coordinates set to 0.
	inline freeBivector() {set();}

	/// Copy constructor.
	inline freeBivector(const freeBivector &A) {set(A);}



	/// Constructs a new freeBivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline freeBivector(mv &A, int filler) {set(A);}

	/// Constructs a new freeBivector. Coordinate values come from 'A'.
	inline freeBivector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new freeBivector with each coordinate specified.
	inline freeBivector(const CoordinateOrder co,  double e1_e2_ni, double e2_e3_ni, double e3_e1_ni) {
		set(co, e1_e2_ni, e2_e3_ni, e3_e1_ni);
	}

	/// Assignment operator (freeBivector).
	inline freeBivector &operator=(const freeBivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline freeBivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const freeBivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_ni, double e2_e3_ni, double e3_e1_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline double get_e2_e3_ni() const { return m_e2_e3_ni;}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(double e2_e3_ni) { m_e2_e3_ni = e2_e3_ni;}
	/// Returns the -1*e1^e3^ni coordinate.
	inline double get_e3_e1_ni() const { return m_e3_e1_ni;}
	/// Sets the -1*e1^e3^ni coordinate.
	inline void set_e3_e1_ni(double e3_e1_ni) { m_e3_e1_ni = e3_e1_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class freeBivector

/// This class can hold a specialized multivector of type flatPoint.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
///   - coordinate e3^ni  (array index: E3_NI = 2)
///   - coordinate no^ni  (array index: NO_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class flatPoint
{
public:
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
	/// The no^ni coordinate.
	double m_no_ni;
public:

	/// Floating point type used by flatPoint 
	typedef double Float;
	/// Array indices of flatPoint coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in flatPoint
		E1_NI = 0, 
		/// index of coordinate for e2^ni in flatPoint
		E2_NI = 1, 
		/// index of coordinate for e3^ni in flatPoint
		E3_NI = 2, 
		/// index of coordinate for no^ni in flatPoint
		NO_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni_e3ni_noni
	} CoordinateOrder;

	/// Constructs a new flatPoint with variable coordinates set to 0.
	inline flatPoint() {set();}

	/// Copy constructor.
	inline flatPoint(const flatPoint &A) {set(A);}



	/// Constructs a new flatPoint from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline flatPoint(mv &A, int filler) {set(A);}

	/// Constructs a new flatPoint. Coordinate values come from 'A'.
	inline flatPoint(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new flatPoint with each coordinate specified.
	inline flatPoint(const CoordinateOrder co,  double e1_ni, double e2_ni, double e3_ni, double no_ni) {
		set(co, e1_ni, e2_ni, e3_ni, no_ni);
	}

	/// Assignment operator (flatPoint).
	inline flatPoint &operator=(const flatPoint &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline flatPoint &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const flatPoint &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_ni, double e2_ni, double e3_ni, double no_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return m_no_ni;}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(double no_ni) { m_no_ni = no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class flatPoint

/// This class can hold a specialized multivector of type pointPair.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1  (array index: NO_E1 = 0)
///   - coordinate no^e2  (array index: NO_E2 = 1)
///   - coordinate no^e3  (array index: NO_E3 = 2)
///   - coordinate e1^e2  (array index: E1_E2 = 3)
///   - coordinate e2^e3  (array index: E2_E3 = 4)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 5)
///   - coordinate e1^ni  (array index: E1_NI = 6)
///   - coordinate e2^ni  (array index: E2_NI = 7)
///   - coordinate e3^ni  (array index: E3_NI = 8)
///   - coordinate no^ni  (array index: NO_NI = 9)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pointPair
{
public:
	/// The no^e1 coordinate.
	double m_no_e1;
	/// The no^e2 coordinate.
	double m_no_e2;
	/// The no^e3 coordinate.
	double m_no_e3;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
	/// The no^ni coordinate.
	double m_no_ni;
public:

	/// Floating point type used by pointPair 
	typedef double Float;
	/// Array indices of pointPair coordinates.
	typedef enum {
		/// index of coordinate for no^e1 in pointPair
		NO_E1 = 0, 
		/// index of coordinate for no^e2 in pointPair
		NO_E2 = 1, 
		/// index of coordinate for no^e3 in pointPair
		NO_E3 = 2, 
		/// index of coordinate for e1^e2 in pointPair
		E1_E2 = 3, 
		/// index of coordinate for e2^e3 in pointPair
		E2_E3 = 4, 
		/// index of coordinate for -1*e1^e3 in pointPair
		E3_E1 = 5, 
		/// index of coordinate for e1^ni in pointPair
		E1_NI = 6, 
		/// index of coordinate for e2^ni in pointPair
		E2_NI = 7, 
		/// index of coordinate for e3^ni in pointPair
		E3_NI = 8, 
		/// index of coordinate for no^ni in pointPair
		NO_NI = 9, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni
	} CoordinateOrder;

	/// Constructs a new pointPair with variable coordinates set to 0.
	inline pointPair() {set();}

	/// Copy constructor.
	inline pointPair(const pointPair &A) {set(A);}



	/// Constructs a new pointPair from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pointPair(mv &A, int filler) {set(A);}

	/// Constructs a new pointPair. Coordinate values come from 'A'.
	inline pointPair(const CoordinateOrder co, const double A[10]) {set(co, A);}
	
	/// Constructs a new pointPair with each coordinate specified.
	inline pointPair(const CoordinateOrder co,  double no_e1, double no_e2, double no_e3, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double no_ni) {
		set(co, no_e1, no_e2, no_e3, e1_e2, e2_e3, e3_e1, e1_ni, e2_ni, e3_ni, no_ni);
	}

	/// Assignment operator (pointPair).
	inline pointPair &operator=(const pointPair &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pointPair &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pointPair &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[10]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no_e1, double no_e2, double no_e3, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double no_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1 coordinate.
	inline double get_no_e1() const { return m_no_e1;}
	/// Sets the no^e1 coordinate.
	inline void set_no_e1(double no_e1) { m_no_e1 = no_e1;}
	/// Returns the no^e2 coordinate.
	inline double get_no_e2() const { return m_no_e2;}
	/// Sets the no^e2 coordinate.
	inline void set_no_e2(double no_e2) { m_no_e2 = no_e2;}
	/// Returns the no^e3 coordinate.
	inline double get_no_e3() const { return m_no_e3;}
	/// Sets the no^e3 coordinate.
	inline void set_no_e3(double no_e3) { m_no_e3 = no_e3;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return m_no_ni;}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(double no_ni) { m_no_ni = no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class pointPair

/// This class can hold a specialized multivector of type line.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 0)
///   - coordinate e1^e3^ni  (array index: E1_E3_NI = 1)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 2)
///   - coordinate -1*no^e1^ni  (array index: E1_NO_NI = 3)
///   - coordinate -1*no^e2^ni  (array index: E2_NO_NI = 4)
///   - coordinate -1*no^e3^ni  (array index: E3_NO_NI = 5)
/// 
/// The type has no constant coordinates.
/// 
/// 
class line
{
public:
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
	/// The e1^e3^ni coordinate.
	double m_e1_e3_ni;
	/// The e2^e3^ni coordinate.
	double m_e2_e3_ni;
	/// The -1*no^e1^ni coordinate.
	double m_e1_no_ni;
	/// The -1*no^e2^ni coordinate.
	double m_e2_no_ni;
	/// The -1*no^e3^ni coordinate.
	double m_e3_no_ni;
public:

	/// Floating point type used by line 
	typedef double Float;
	/// Array indices of line coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^ni in line
		E1_E2_NI = 0, 
		/// index of coordinate for e1^e3^ni in line
		E1_E3_NI = 1, 
		/// index of coordinate for e2^e3^ni in line
		E2_E3_NI = 2, 
		/// index of coordinate for -1*no^e1^ni in line
		E1_NO_NI = 3, 
		/// index of coordinate for -1*no^e2^ni in line
		E2_NO_NI = 4, 
		/// index of coordinate for -1*no^e3^ni in line
		E3_NO_NI = 5, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni
	} CoordinateOrder;

	/// Constructs a new line with variable coordinates set to 0.
	inline line() {set();}

	/// Copy constructor.
	inline line(const line &A) {set(A);}



	/// Constructs a new line from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline line(mv &A, int filler) {set(A);}

	/// Constructs a new line. Coordinate values come from 'A'.
	inline line(const CoordinateOrder co, const double A[6]) {set(co, A);}
	
	/// Constructs a new line with each coordinate specified.
	inline line(const CoordinateOrder co,  double e1_e2_ni, double e1_e3_ni, double e2_e3_ni, double e1_no_ni, double e2_no_ni, double e3_no_ni) {
		set(co, e1_e2_ni, e1_e3_ni, e2_e3_ni, e1_no_ni, e2_no_ni, e3_no_ni);
	}

	/// Assignment operator (line).
	inline line &operator=(const line &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline line &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const line &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[6]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_ni, double e1_e3_ni, double e2_e3_ni, double e1_no_ni, double e2_no_ni, double e3_no_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the e1^e3^ni coordinate.
	inline double get_e1_e3_ni() const { return m_e1_e3_ni;}
	/// Sets the e1^e3^ni coordinate.
	inline void set_e1_e3_ni(double e1_e3_ni) { m_e1_e3_ni = e1_e3_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline double get_e2_e3_ni() const { return m_e2_e3_ni;}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(double e2_e3_ni) { m_e2_e3_ni = e2_e3_ni;}
	/// Returns the -1*no^e1^ni coordinate.
	inline double get_e1_no_ni() const { return m_e1_no_ni;}
	/// Sets the -1*no^e1^ni coordinate.
	inline void set_e1_no_ni(double e1_no_ni) { m_e1_no_ni = e1_no_ni;}
	/// Returns the -1*no^e2^ni coordinate.
	inline double get_e2_no_ni() const { return m_e2_no_ni;}
	/// Sets the -1*no^e2^ni coordinate.
	inline void set_e2_no_ni(double e2_no_ni) { m_e2_no_ni = e2_no_ni;}
	/// Returns the -1*no^e3^ni coordinate.
	inline double get_e3_no_ni() const { return m_e3_no_ni;}
	/// Sets the -1*no^e3^ni coordinate.
	inline void set_e3_no_ni(double e3_no_ni) { m_e3_no_ni = e3_no_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class line

/// This class can hold a specialized multivector of type circle.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1^e2  (array index: NO_E1_E2 = 0)
///   - coordinate no^e1^e3  (array index: NO_E1_E3 = 1)
///   - coordinate no^e2^e3  (array index: NO_E2_E3 = 2)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 3)
///   - coordinate no^e1^ni  (array index: NO_E1_NI = 4)
///   - coordinate no^e2^ni  (array index: NO_E2_NI = 5)
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 6)
///   - coordinate no^e3^ni  (array index: NO_E3_NI = 7)
///   - coordinate e1^e3^ni  (array index: E1_E3_NI = 8)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 9)
/// 
/// The type has no constant coordinates.
/// 
/// 
class circle
{
public:
	/// The no^e1^e2 coordinate.
	double m_no_e1_e2;
	/// The no^e1^e3 coordinate.
	double m_no_e1_e3;
	/// The no^e2^e3 coordinate.
	double m_no_e2_e3;
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
	/// The no^e1^ni coordinate.
	double m_no_e1_ni;
	/// The no^e2^ni coordinate.
	double m_no_e2_ni;
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
	/// The no^e3^ni coordinate.
	double m_no_e3_ni;
	/// The e1^e3^ni coordinate.
	double m_e1_e3_ni;
	/// The e2^e3^ni coordinate.
	double m_e2_e3_ni;
public:

	/// Floating point type used by circle 
	typedef double Float;
	/// Array indices of circle coordinates.
	typedef enum {
		/// index of coordinate for no^e1^e2 in circle
		NO_E1_E2 = 0, 
		/// index of coordinate for no^e1^e3 in circle
		NO_E1_E3 = 1, 
		/// index of coordinate for no^e2^e3 in circle
		NO_E2_E3 = 2, 
		/// index of coordinate for e1^e2^e3 in circle
		E1_E2_E3 = 3, 
		/// index of coordinate for no^e1^ni in circle
		NO_E1_NI = 4, 
		/// index of coordinate for no^e2^ni in circle
		NO_E2_NI = 5, 
		/// index of coordinate for e1^e2^ni in circle
		E1_E2_NI = 6, 
		/// index of coordinate for no^e3^ni in circle
		NO_E3_NI = 7, 
		/// index of coordinate for e1^e3^ni in circle
		E1_E3_NI = 8, 
		/// index of coordinate for e2^e3^ni in circle
		E2_E3_NI = 9, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni
	} CoordinateOrder;

	/// Constructs a new circle with variable coordinates set to 0.
	inline circle() {set();}

	/// Copy constructor.
	inline circle(const circle &A) {set(A);}



	/// Constructs a new circle from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline circle(mv &A, int filler) {set(A);}

	/// Constructs a new circle. Coordinate values come from 'A'.
	inline circle(const CoordinateOrder co, const double A[10]) {set(co, A);}
	
	/// Constructs a new circle with each coordinate specified.
	inline circle(const CoordinateOrder co,  double no_e1_e2, double no_e1_e3, double no_e2_e3, double e1_e2_e3, double no_e1_ni, double no_e2_ni, double e1_e2_ni, double no_e3_ni, double e1_e3_ni, double e2_e3_ni) {
		set(co, no_e1_e2, no_e1_e3, no_e2_e3, e1_e2_e3, no_e1_ni, no_e2_ni, e1_e2_ni, no_e3_ni, e1_e3_ni, e2_e3_ni);
	}

	/// Assignment operator (circle).
	inline circle &operator=(const circle &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline circle &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const circle &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[10]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no_e1_e2, double no_e1_e3, double no_e2_e3, double e1_e2_e3, double no_e1_ni, double no_e2_ni, double e1_e2_ni, double no_e3_ni, double e1_e3_ni, double e2_e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2 coordinate.
	inline double get_no_e1_e2() const { return m_no_e1_e2;}
	/// Sets the no^e1^e2 coordinate.
	inline void set_no_e1_e2(double no_e1_e2) { m_no_e1_e2 = no_e1_e2;}
	/// Returns the no^e1^e3 coordinate.
	inline double get_no_e1_e3() const { return m_no_e1_e3;}
	/// Sets the no^e1^e3 coordinate.
	inline void set_no_e1_e3(double no_e1_e3) { m_no_e1_e3 = no_e1_e3;}
	/// Returns the no^e2^e3 coordinate.
	inline double get_no_e2_e3() const { return m_no_e2_e3;}
	/// Sets the no^e2^e3 coordinate.
	inline void set_no_e2_e3(double no_e2_e3) { m_no_e2_e3 = no_e2_e3;}
	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the no^e1^ni coordinate.
	inline double get_no_e1_ni() const { return m_no_e1_ni;}
	/// Sets the no^e1^ni coordinate.
	inline void set_no_e1_ni(double no_e1_ni) { m_no_e1_ni = no_e1_ni;}
	/// Returns the no^e2^ni coordinate.
	inline double get_no_e2_ni() const { return m_no_e2_ni;}
	/// Sets the no^e2^ni coordinate.
	inline void set_no_e2_ni(double no_e2_ni) { m_no_e2_ni = no_e2_ni;}
	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the no^e3^ni coordinate.
	inline double get_no_e3_ni() const { return m_no_e3_ni;}
	/// Sets the no^e3^ni coordinate.
	inline void set_no_e3_ni(double no_e3_ni) { m_no_e3_ni = no_e3_ni;}
	/// Returns the e1^e3^ni coordinate.
	inline double get_e1_e3_ni() const { return m_e1_e3_ni;}
	/// Sets the e1^e3^ni coordinate.
	inline void set_e1_e3_ni(double e1_e3_ni) { m_e1_e3_ni = e1_e3_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline double get_e2_e3_ni() const { return m_e2_e3_ni;}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(double e2_e3_ni) { m_e2_e3_ni = e2_e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class circle

/// This class can hold a specialized multivector of type sphere.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^e3^ni  (array index: E1_E2_E3_NI = 0)
///   - coordinate no^e2^e3^ni  (array index: NO_E2_E3_NI = 1)
///   - coordinate no^e1^e3^ni  (array index: NO_E1_E3_NI = 2)
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 3)
///   - coordinate no^e1^e2^e3  (array index: NO_E1_E2_E3 = 4)
/// 
/// The type has no constant coordinates.
/// 
/// 
class sphere
{
public:
	/// The e1^e2^e3^ni coordinate.
	double m_e1_e2_e3_ni;
	/// The no^e2^e3^ni coordinate.
	double m_no_e2_e3_ni;
	/// The no^e1^e3^ni coordinate.
	double m_no_e1_e3_ni;
	/// The no^e1^e2^ni coordinate.
	double m_no_e1_e2_ni;
	/// The no^e1^e2^e3 coordinate.
	double m_no_e1_e2_e3;
public:

	/// Floating point type used by sphere 
	typedef double Float;
	/// Array indices of sphere coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^e3^ni in sphere
		E1_E2_E3_NI = 0, 
		/// index of coordinate for no^e2^e3^ni in sphere
		NO_E2_E3_NI = 1, 
		/// index of coordinate for no^e1^e3^ni in sphere
		NO_E1_E3_NI = 2, 
		/// index of coordinate for no^e1^e2^ni in sphere
		NO_E1_E2_NI = 3, 
		/// index of coordinate for no^e1^e2^e3 in sphere
		NO_E1_E2_E3 = 4, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3
	} CoordinateOrder;

	/// Constructs a new sphere with variable coordinates set to 0.
	inline sphere() {set();}

	/// Copy constructor.
	inline sphere(const sphere &A) {set(A);}



	/// Constructs a new sphere from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline sphere(mv &A, int filler) {set(A);}

	/// Constructs a new sphere. Coordinate values come from 'A'.
	inline sphere(const CoordinateOrder co, const double A[5]) {set(co, A);}
	
	/// Constructs a new sphere with each coordinate specified.
	inline sphere(const CoordinateOrder co,  double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni, double no_e1_e2_e3) {
		set(co, e1_e2_e3_ni, no_e2_e3_ni, no_e1_e3_ni, no_e1_e2_ni, no_e1_e2_e3);
	}

	/// Assignment operator (sphere).
	inline sphere &operator=(const sphere &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline sphere &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const sphere &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[5]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni, double no_e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3^ni coordinate.
	inline double get_e1_e2_e3_ni() const { return m_e1_e2_e3_ni;}
	/// Sets the e1^e2^e3^ni coordinate.
	inline void set_e1_e2_e3_ni(double e1_e2_e3_ni) { m_e1_e2_e3_ni = e1_e2_e3_ni;}
	/// Returns the no^e2^e3^ni coordinate.
	inline double get_no_e2_e3_ni() const { return m_no_e2_e3_ni;}
	/// Sets the no^e2^e3^ni coordinate.
	inline void set_no_e2_e3_ni(double no_e2_e3_ni) { m_no_e2_e3_ni = no_e2_e3_ni;}
	/// Returns the no^e1^e3^ni coordinate.
	inline double get_no_e1_e3_ni() const { return m_no_e1_e3_ni;}
	/// Sets the no^e1^e3^ni coordinate.
	inline void set_no_e1_e3_ni(double no_e1_e3_ni) { m_no_e1_e3_ni = no_e1_e3_ni;}
	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return m_no_e1_e2_ni;}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(double no_e1_e2_ni) { m_no_e1_e2_ni = no_e1_e2_ni;}
	/// Returns the no^e1^e2^e3 coordinate.
	inline double get_no_e1_e2_e3() const { return m_no_e1_e2_e3;}
	/// Sets the no^e1^e2^e3 coordinate.
	inline void set_no_e1_e2_e3(double no_e1_e2_e3) { m_no_e1_e2_e3 = no_e1_e2_e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class sphere

/// This class can hold a specialized multivector of type plane.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^e3^ni  (array index: E1_E2_E3_NI = 0)
///   - coordinate no^e2^e3^ni  (array index: NO_E2_E3_NI = 1)
///   - coordinate no^e1^e3^ni  (array index: NO_E1_E3_NI = 2)
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class plane
{
public:
	/// The e1^e2^e3^ni coordinate.
	double m_e1_e2_e3_ni;
	/// The no^e2^e3^ni coordinate.
	double m_no_e2_e3_ni;
	/// The no^e1^e3^ni coordinate.
	double m_no_e1_e3_ni;
	/// The no^e1^e2^ni coordinate.
	double m_no_e1_e2_ni;
public:

	/// Floating point type used by plane 
	typedef double Float;
	/// Array indices of plane coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^e3^ni in plane
		E1_E2_E3_NI = 0, 
		/// index of coordinate for no^e2^e3^ni in plane
		NO_E2_E3_NI = 1, 
		/// index of coordinate for no^e1^e3^ni in plane
		NO_E1_E3_NI = 2, 
		/// index of coordinate for no^e1^e2^ni in plane
		NO_E1_E2_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni
	} CoordinateOrder;

	/// Constructs a new plane with variable coordinates set to 0.
	inline plane() {set();}

	/// Copy constructor.
	inline plane(const plane &A) {set(A);}



	/// Constructs a new plane from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline plane(mv &A, int filler) {set(A);}

	/// Constructs a new plane. Coordinate values come from 'A'.
	inline plane(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new plane with each coordinate specified.
	inline plane(const CoordinateOrder co,  double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni) {
		set(co, e1_e2_e3_ni, no_e2_e3_ni, no_e1_e3_ni, no_e1_e2_ni);
	}

	/// Assignment operator (plane).
	inline plane &operator=(const plane &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline plane &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const plane &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3^ni coordinate.
	inline double get_e1_e2_e3_ni() const { return m_e1_e2_e3_ni;}
	/// Sets the e1^e2^e3^ni coordinate.
	inline void set_e1_e2_e3_ni(double e1_e2_e3_ni) { m_e1_e2_e3_ni = e1_e2_e3_ni;}
	/// Returns the no^e2^e3^ni coordinate.
	inline double get_no_e2_e3_ni() const { return m_no_e2_e3_ni;}
	/// Sets the no^e2^e3^ni coordinate.
	inline void set_no_e2_e3_ni(double no_e2_e3_ni) { m_no_e2_e3_ni = no_e2_e3_ni;}
	/// Returns the no^e1^e3^ni coordinate.
	inline double get_no_e1_e3_ni() const { return m_no_e1_e3_ni;}
	/// Sets the no^e1^e3^ni coordinate.
	inline void set_no_e1_e3_ni(double no_e1_e3_ni) { m_no_e1_e3_ni = no_e1_e3_ni;}
	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return m_no_e1_e2_ni;}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(double no_e1_e2_ni) { m_no_e1_e2_ni = no_e1_e2_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class plane

/// This class can hold a specialized multivector of type pseudoscalar.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no^e1^e2^e3^ni  (array index: NO_E1_E2_E3_NI = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pseudoscalar
{
public:
	/// The no^e1^e2^e3^ni coordinate.
	double m_no_e1_e2_e3_ni;
public:

	/// Floating point type used by pseudoscalar 
	typedef double Float;
	/// Array indices of pseudoscalar coordinates.
	typedef enum {
		/// index of coordinate for no^e1^e2^e3^ni in pseudoscalar
		NO_E1_E2_E3_NI = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_noe1e2e3ni
	} CoordinateOrder;

	/// Constructs a new pseudoscalar with variable coordinates set to 0.
	inline pseudoscalar() {set();}

	/// Copy constructor.
	inline pseudoscalar(const pseudoscalar &A) {set(A);}



	/// Constructs a new pseudoscalar from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pseudoscalar(mv &A, int filler) {set(A);}

	/// Constructs a new pseudoscalar. Coordinate values come from 'A'.
	inline pseudoscalar(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new pseudoscalar with each coordinate specified.
	inline pseudoscalar(const CoordinateOrder co,  double no_e1_e2_e3_ni) {
		set(co, no_e1_e2_e3_ni);
	}

	/// Assignment operator (pseudoscalar).
	inline pseudoscalar &operator=(const pseudoscalar &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pseudoscalar &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pseudoscalar &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no_e1_e2_e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no^e1^e2^e3^ni coordinate.
	inline double get_no_e1_e2_e3_ni() const { return m_no_e1_e2_e3_ni;}
	/// Sets the no^e1^e2^e3^ni coordinate.
	inline void set_no_e1_e2_e3_ni(double no_e1_e2_e3_ni) { m_no_e1_e2_e3_ni = no_e1_e2_e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class pseudoscalar

/// This class can hold a specialized multivector of type normalizedTranslator.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^ni  (array index: E1_NI = 0)
///   - coordinate e2^ni  (array index: E2_NI = 1)
///   - coordinate e3^ni  (array index: E3_NI = 2)
/// 
/// The constant non-zero coordinates are:
///   - 1 = 1
/// 
/// 
class normalizedTranslator
{
public:
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
public:

	/// Floating point type used by normalizedTranslator 
	typedef double Float;
	/// Array indices of normalizedTranslator coordinates.
	typedef enum {
		/// index of coordinate for e1^ni in normalizedTranslator
		E1_NI = 0, 
		/// index of coordinate for e2^ni in normalizedTranslator
		E2_NI = 1, 
		/// index of coordinate for e3^ni in normalizedTranslator
		E3_NI = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1ni_e2ni_e3ni
	} CoordinateOrder;

	/// Constructs a new normalizedTranslator with variable coordinates set to 0.
	inline normalizedTranslator() {set();}

	/// Copy constructor.
	inline normalizedTranslator(const normalizedTranslator &A) {set(A);}


	/// Constructs a new normalizedTranslator with scalar value 'scalar'.
	inline normalizedTranslator(double scalar) {set(scalar);}

	/// Constructs a new normalizedTranslator from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline normalizedTranslator(mv &A, int filler) {set(A);}

	/// Constructs a new normalizedTranslator. Coordinate values come from 'A'.
	inline normalizedTranslator(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new normalizedTranslator with each coordinate specified.
	inline normalizedTranslator(const CoordinateOrder co,  double e1_ni, double e2_ni, double e3_ni) {
		set(co, e1_ni, e2_ni, e3_ni);
	}

	/// Assignment operator (normalizedTranslator).
	inline normalizedTranslator &operator=(const normalizedTranslator &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline normalizedTranslator &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline normalizedTranslator &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const normalizedTranslator &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_ni, double e2_ni, double e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the 1 coordinate.
	inline double get_scalar() const { return 1.0;}
}; // end of class normalizedTranslator

/// This class can hold a specialized multivector of type translator.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^ni  (array index: E1_NI = 1)
///   - coordinate e2^ni  (array index: E2_NI = 2)
///   - coordinate e3^ni  (array index: E3_NI = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class translator
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
public:

	/// Floating point type used by translator 
	typedef double Float;
	/// Array indices of translator coordinates.
	typedef enum {
		/// index of coordinate for 1 in translator
		SCALAR = 0, 
		/// index of coordinate for e1^ni in translator
		E1_NI = 1, 
		/// index of coordinate for e2^ni in translator
		E2_NI = 2, 
		/// index of coordinate for e3^ni in translator
		E3_NI = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1ni_e2ni_e3ni
	} CoordinateOrder;

	/// Constructs a new translator with variable coordinates set to 0.
	inline translator() {set();}

	/// Copy constructor.
	inline translator(const translator &A) {set(A);}


	/// Constructs a new translator with scalar value 'scalar'.
	inline translator(double scalar) {set(scalar);}

	/// Constructs a new translator from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline translator(mv &A, int filler) {set(A);}

	/// Constructs a new translator. Coordinate values come from 'A'.
	inline translator(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new translator with each coordinate specified.
	inline translator(const CoordinateOrder co,  double scalar, double e1_ni, double e2_ni, double e3_ni) {
		set(co, scalar, e1_ni, e2_ni, e3_ni);
	}

	/// Assignment operator (translator).
	inline translator &operator=(const translator &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline translator &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline translator &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const translator &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_ni, double e2_ni, double e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
}; // end of class translator

/// This class can hold a specialized multivector of type RBM.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^e2  (array index: E1_E2 = 1)
///   - coordinate e2^e3  (array index: E2_E3 = 2)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 3)
///   - coordinate e1^ni  (array index: E1_NI = 4)
///   - coordinate e2^ni  (array index: E2_NI = 5)
///   - coordinate e3^ni  (array index: E3_NI = 6)
///   - coordinate e1^e2^e3^ni  (array index: E1_E2_E3_NI = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class RBM
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
	/// The e1^e2^e3^ni coordinate.
	double m_e1_e2_e3_ni;
public:

	/// Floating point type used by RBM 
	typedef double Float;
	/// Array indices of RBM coordinates.
	typedef enum {
		/// index of coordinate for 1 in RBM
		SCALAR = 0, 
		/// index of coordinate for e1^e2 in RBM
		E1_E2 = 1, 
		/// index of coordinate for e2^e3 in RBM
		E2_E3 = 2, 
		/// index of coordinate for -1*e1^e3 in RBM
		E3_E1 = 3, 
		/// index of coordinate for e1^ni in RBM
		E1_NI = 4, 
		/// index of coordinate for e2^ni in RBM
		E2_NI = 5, 
		/// index of coordinate for e3^ni in RBM
		E3_NI = 6, 
		/// index of coordinate for e1^e2^e3^ni in RBM
		E1_E2_E3_NI = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_e1e2e3ni
	} CoordinateOrder;

	/// Constructs a new RBM with variable coordinates set to 0.
	inline RBM() {set();}

	/// Copy constructor.
	inline RBM(const RBM &A) {set(A);}


	/// Constructs a new RBM with scalar value 'scalar'.
	inline RBM(double scalar) {set(scalar);}

	/// Constructs a new RBM from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline RBM(mv &A, int filler) {set(A);}

	/// Constructs a new RBM. Coordinate values come from 'A'.
	inline RBM(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new RBM with each coordinate specified.
	inline RBM(const CoordinateOrder co,  double scalar, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double e1_e2_e3_ni) {
		set(co, scalar, e1_e2, e2_e3, e3_e1, e1_ni, e2_ni, e3_ni, e1_e2_e3_ni);
	}

	/// Assignment operator (RBM).
	inline RBM &operator=(const RBM &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline RBM &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline RBM &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const RBM &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double e1_e2_e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the e1^e2^e3^ni coordinate.
	inline double get_e1_e2_e3_ni() const { return m_e1_e2_e3_ni;}
	/// Sets the e1^e2^e3^ni coordinate.
	inline void set_e1_e2_e3_ni(double e1_e2_e3_ni) { m_e1_e2_e3_ni = e1_e2_e3_ni;}
}; // end of class RBM

/// This class can hold a specialized multivector of type evenVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate no^e1  (array index: NO_E1 = 1)
///   - coordinate no^e2  (array index: NO_E2 = 2)
///   - coordinate no^e3  (array index: NO_E3 = 3)
///   - coordinate e1^e2  (array index: E1_E2 = 4)
///   - coordinate e2^e3  (array index: E2_E3 = 5)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 6)
///   - coordinate e1^ni  (array index: E1_NI = 7)
///   - coordinate e2^ni  (array index: E2_NI = 8)
///   - coordinate e3^ni  (array index: E3_NI = 9)
///   - coordinate no^ni  (array index: NO_NI = 10)
///   - coordinate e1^e2^e3^ni  (array index: E1_E2_E3_NI = 11)
///   - coordinate no^e2^e3^ni  (array index: NO_E2_E3_NI = 12)
///   - coordinate no^e1^e3^ni  (array index: NO_E1_E3_NI = 13)
///   - coordinate no^e1^e2^ni  (array index: NO_E1_E2_NI = 14)
///   - coordinate no^e1^e2^e3  (array index: NO_E1_E2_E3 = 15)
/// 
/// The type has no constant coordinates.
/// 
/// 
class evenVersor
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The no^e1 coordinate.
	double m_no_e1;
	/// The no^e2 coordinate.
	double m_no_e2;
	/// The no^e3 coordinate.
	double m_no_e3;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
	/// The e1^ni coordinate.
	double m_e1_ni;
	/// The e2^ni coordinate.
	double m_e2_ni;
	/// The e3^ni coordinate.
	double m_e3_ni;
	/// The no^ni coordinate.
	double m_no_ni;
	/// The e1^e2^e3^ni coordinate.
	double m_e1_e2_e3_ni;
	/// The no^e2^e3^ni coordinate.
	double m_no_e2_e3_ni;
	/// The no^e1^e3^ni coordinate.
	double m_no_e1_e3_ni;
	/// The no^e1^e2^ni coordinate.
	double m_no_e1_e2_ni;
	/// The no^e1^e2^e3 coordinate.
	double m_no_e1_e2_e3;
public:

	/// Floating point type used by evenVersor 
	typedef double Float;
	/// Array indices of evenVersor coordinates.
	typedef enum {
		/// index of coordinate for 1 in evenVersor
		SCALAR = 0, 
		/// index of coordinate for no^e1 in evenVersor
		NO_E1 = 1, 
		/// index of coordinate for no^e2 in evenVersor
		NO_E2 = 2, 
		/// index of coordinate for no^e3 in evenVersor
		NO_E3 = 3, 
		/// index of coordinate for e1^e2 in evenVersor
		E1_E2 = 4, 
		/// index of coordinate for e2^e3 in evenVersor
		E2_E3 = 5, 
		/// index of coordinate for -1*e1^e3 in evenVersor
		E3_E1 = 6, 
		/// index of coordinate for e1^ni in evenVersor
		E1_NI = 7, 
		/// index of coordinate for e2^ni in evenVersor
		E2_NI = 8, 
		/// index of coordinate for e3^ni in evenVersor
		E3_NI = 9, 
		/// index of coordinate for no^ni in evenVersor
		NO_NI = 10, 
		/// index of coordinate for e1^e2^e3^ni in evenVersor
		E1_E2_E3_NI = 11, 
		/// index of coordinate for no^e2^e3^ni in evenVersor
		NO_E2_E3_NI = 12, 
		/// index of coordinate for no^e1^e3^ni in evenVersor
		NO_E1_E3_NI = 13, 
		/// index of coordinate for no^e1^e2^ni in evenVersor
		NO_E1_E2_NI = 14, 
		/// index of coordinate for no^e1^e2^e3 in evenVersor
		NO_E1_E2_E3 = 15, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3
	} CoordinateOrder;

	/// Constructs a new evenVersor with variable coordinates set to 0.
	inline evenVersor() {set();}

	/// Copy constructor.
	inline evenVersor(const evenVersor &A) {set(A);}


	/// Constructs a new evenVersor with scalar value 'scalar'.
	inline evenVersor(double scalar) {set(scalar);}

	/// Constructs a new evenVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline evenVersor(mv &A, int filler) {set(A);}

	/// Constructs a new evenVersor. Coordinate values come from 'A'.
	inline evenVersor(const CoordinateOrder co, const double A[16]) {set(co, A);}
	
	/// Constructs a new evenVersor with each coordinate specified.
	inline evenVersor(const CoordinateOrder co,  double scalar, double no_e1, double no_e2, double no_e3, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double no_ni, double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni, double no_e1_e2_e3) {
		set(co, scalar, no_e1, no_e2, no_e3, e1_e2, e2_e3, e3_e1, e1_ni, e2_ni, e3_ni, no_ni, e1_e2_e3_ni, no_e2_e3_ni, no_e1_e3_ni, no_e1_e2_ni, no_e1_e2_e3);
	}

	/// Assignment operator (evenVersor).
	inline evenVersor &operator=(const evenVersor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline evenVersor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline evenVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const evenVersor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[16]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double no_e1, double no_e2, double no_e3, double e1_e2, double e2_e3, double e3_e1, double e1_ni, double e2_ni, double e3_ni, double no_ni, double e1_e2_e3_ni, double no_e2_e3_ni, double no_e1_e3_ni, double no_e1_e2_ni, double no_e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the no^e1 coordinate.
	inline double get_no_e1() const { return m_no_e1;}
	/// Sets the no^e1 coordinate.
	inline void set_no_e1(double no_e1) { m_no_e1 = no_e1;}
	/// Returns the no^e2 coordinate.
	inline double get_no_e2() const { return m_no_e2;}
	/// Sets the no^e2 coordinate.
	inline void set_no_e2(double no_e2) { m_no_e2 = no_e2;}
	/// Returns the no^e3 coordinate.
	inline double get_no_e3() const { return m_no_e3;}
	/// Sets the no^e3 coordinate.
	inline void set_no_e3(double no_e3) { m_no_e3 = no_e3;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the e1^ni coordinate.
	inline double get_e1_ni() const { return m_e1_ni;}
	/// Sets the e1^ni coordinate.
	inline void set_e1_ni(double e1_ni) { m_e1_ni = e1_ni;}
	/// Returns the e2^ni coordinate.
	inline double get_e2_ni() const { return m_e2_ni;}
	/// Sets the e2^ni coordinate.
	inline void set_e2_ni(double e2_ni) { m_e2_ni = e2_ni;}
	/// Returns the e3^ni coordinate.
	inline double get_e3_ni() const { return m_e3_ni;}
	/// Sets the e3^ni coordinate.
	inline void set_e3_ni(double e3_ni) { m_e3_ni = e3_ni;}
	/// Returns the no^ni coordinate.
	inline double get_no_ni() const { return m_no_ni;}
	/// Sets the no^ni coordinate.
	inline void set_no_ni(double no_ni) { m_no_ni = no_ni;}
	/// Returns the e1^e2^e3^ni coordinate.
	inline double get_e1_e2_e3_ni() const { return m_e1_e2_e3_ni;}
	/// Sets the e1^e2^e3^ni coordinate.
	inline void set_e1_e2_e3_ni(double e1_e2_e3_ni) { m_e1_e2_e3_ni = e1_e2_e3_ni;}
	/// Returns the no^e2^e3^ni coordinate.
	inline double get_no_e2_e3_ni() const { return m_no_e2_e3_ni;}
	/// Sets the no^e2^e3^ni coordinate.
	inline void set_no_e2_e3_ni(double no_e2_e3_ni) { m_no_e2_e3_ni = no_e2_e3_ni;}
	/// Returns the no^e1^e3^ni coordinate.
	inline double get_no_e1_e3_ni() const { return m_no_e1_e3_ni;}
	/// Sets the no^e1^e3^ni coordinate.
	inline void set_no_e1_e3_ni(double no_e1_e3_ni) { m_no_e1_e3_ni = no_e1_e3_ni;}
	/// Returns the no^e1^e2^ni coordinate.
	inline double get_no_e1_e2_ni() const { return m_no_e1_e2_ni;}
	/// Sets the no^e1^e2^ni coordinate.
	inline void set_no_e1_e2_ni(double no_e1_e2_ni) { m_no_e1_e2_ni = no_e1_e2_ni;}
	/// Returns the no^e1^e2^e3 coordinate.
	inline double get_no_e1_e2_e3() const { return m_no_e1_e2_e3;}
	/// Sets the no^e1^e2^e3 coordinate.
	inline void set_no_e1_e2_e3(double no_e1_e2_e3) { m_no_e1_e2_e3 = no_e1_e2_e3;}
}; // end of class evenVersor

/// This class can hold a specialized multivector of type oddVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate no  (array index: NO = 0)
///   - coordinate e1  (array index: E1 = 1)
///   - coordinate e2  (array index: E2 = 2)
///   - coordinate e3  (array index: E3 = 3)
///   - coordinate ni  (array index: NI = 4)
///   - coordinate no^e1^e2  (array index: NO_E1_E2 = 5)
///   - coordinate no^e1^e3  (array index: NO_E1_E3 = 6)
///   - coordinate no^e2^e3  (array index: NO_E2_E3 = 7)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 8)
///   - coordinate no^e1^ni  (array index: NO_E1_NI = 9)
///   - coordinate no^e2^ni  (array index: NO_E2_NI = 10)
///   - coordinate e1^e2^ni  (array index: E1_E2_NI = 11)
///   - coordinate no^e3^ni  (array index: NO_E3_NI = 12)
///   - coordinate e1^e3^ni  (array index: E1_E3_NI = 13)
///   - coordinate e2^e3^ni  (array index: E2_E3_NI = 14)
///   - coordinate no^e1^e2^e3^ni  (array index: NO_E1_E2_E3_NI = 15)
/// 
/// The type has no constant coordinates.
/// 
/// 
class oddVersor
{
public:
	/// The no coordinate.
	double m_no;
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The ni coordinate.
	double m_ni;
	/// The no^e1^e2 coordinate.
	double m_no_e1_e2;
	/// The no^e1^e3 coordinate.
	double m_no_e1_e3;
	/// The no^e2^e3 coordinate.
	double m_no_e2_e3;
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
	/// The no^e1^ni coordinate.
	double m_no_e1_ni;
	/// The no^e2^ni coordinate.
	double m_no_e2_ni;
	/// The e1^e2^ni coordinate.
	double m_e1_e2_ni;
	/// The no^e3^ni coordinate.
	double m_no_e3_ni;
	/// The e1^e3^ni coordinate.
	double m_e1_e3_ni;
	/// The e2^e3^ni coordinate.
	double m_e2_e3_ni;
	/// The no^e1^e2^e3^ni coordinate.
	double m_no_e1_e2_e3_ni;
public:

	/// Floating point type used by oddVersor 
	typedef double Float;
	/// Array indices of oddVersor coordinates.
	typedef enum {
		/// index of coordinate for no in oddVersor
		NO = 0, 
		/// index of coordinate for e1 in oddVersor
		E1 = 1, 
		/// index of coordinate for e2 in oddVersor
		E2 = 2, 
		/// index of coordinate for e3 in oddVersor
		E3 = 3, 
		/// index of coordinate for ni in oddVersor
		NI = 4, 
		/// index of coordinate for no^e1^e2 in oddVersor
		NO_E1_E2 = 5, 
		/// index of coordinate for no^e1^e3 in oddVersor
		NO_E1_E3 = 6, 
		/// index of coordinate for no^e2^e3 in oddVersor
		NO_E2_E3 = 7, 
		/// index of coordinate for e1^e2^e3 in oddVersor
		E1_E2_E3 = 8, 
		/// index of coordinate for no^e1^ni in oddVersor
		NO_E1_NI = 9, 
		/// index of coordinate for no^e2^ni in oddVersor
		NO_E2_NI = 10, 
		/// index of coordinate for e1^e2^ni in oddVersor
		E1_E2_NI = 11, 
		/// index of coordinate for no^e3^ni in oddVersor
		NO_E3_NI = 12, 
		/// index of coordinate for e1^e3^ni in oddVersor
		E1_E3_NI = 13, 
		/// index of coordinate for e2^e3^ni in oddVersor
		E2_E3_NI = 14, 
		/// index of coordinate for no^e1^e2^e3^ni in oddVersor
		NO_E1_E2_E3_NI = 15, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni
	} CoordinateOrder;

	/// Constructs a new oddVersor with variable coordinates set to 0.
	inline oddVersor() {set();}

	/// Copy constructor.
	inline oddVersor(const oddVersor &A) {set(A);}



	/// Constructs a new oddVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline oddVersor(mv &A, int filler) {set(A);}

	/// Constructs a new oddVersor. Coordinate values come from 'A'.
	inline oddVersor(const CoordinateOrder co, const double A[16]) {set(co, A);}
	
	/// Constructs a new oddVersor with each coordinate specified.
	inline oddVersor(const CoordinateOrder co,  double no, double e1, double e2, double e3, double ni, double no_e1_e2, double no_e1_e3, double no_e2_e3, double e1_e2_e3, double no_e1_ni, double no_e2_ni, double e1_e2_ni, double no_e3_ni, double e1_e3_ni, double e2_e3_ni, double no_e1_e2_e3_ni) {
		set(co, no, e1, e2, e3, ni, no_e1_e2, no_e1_e3, no_e2_e3, e1_e2_e3, no_e1_ni, no_e2_ni, e1_e2_ni, no_e3_ni, e1_e3_ni, e2_e3_ni, no_e1_e2_e3_ni);
	}

	/// Assignment operator (oddVersor).
	inline oddVersor &operator=(const oddVersor &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline oddVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const oddVersor &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[16]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double no, double e1, double e2, double e3, double ni, double no_e1_e2, double no_e1_e3, double no_e2_e3, double e1_e2_e3, double no_e1_ni, double no_e2_ni, double e1_e2_ni, double no_e3_ni, double e1_e3_ni, double e2_e3_ni, double no_e1_e2_e3_ni);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::c3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::c3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the no coordinate.
	inline double get_no() const { return m_no;}
	/// Sets the no coordinate.
	inline void set_no(double no) { m_no = no;}
	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the ni coordinate.
	inline double get_ni() const { return m_ni;}
	/// Sets the ni coordinate.
	inline void set_ni(double ni) { m_ni = ni;}
	/// Returns the no^e1^e2 coordinate.
	inline double get_no_e1_e2() const { return m_no_e1_e2;}
	/// Sets the no^e1^e2 coordinate.
	inline void set_no_e1_e2(double no_e1_e2) { m_no_e1_e2 = no_e1_e2;}
	/// Returns the no^e1^e3 coordinate.
	inline double get_no_e1_e3() const { return m_no_e1_e3;}
	/// Sets the no^e1^e3 coordinate.
	inline void set_no_e1_e3(double no_e1_e3) { m_no_e1_e3 = no_e1_e3;}
	/// Returns the no^e2^e3 coordinate.
	inline double get_no_e2_e3() const { return m_no_e2_e3;}
	/// Sets the no^e2^e3 coordinate.
	inline void set_no_e2_e3(double no_e2_e3) { m_no_e2_e3 = no_e2_e3;}
	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the no^e1^ni coordinate.
	inline double get_no_e1_ni() const { return m_no_e1_ni;}
	/// Sets the no^e1^ni coordinate.
	inline void set_no_e1_ni(double no_e1_ni) { m_no_e1_ni = no_e1_ni;}
	/// Returns the no^e2^ni coordinate.
	inline double get_no_e2_ni() const { return m_no_e2_ni;}
	/// Sets the no^e2^ni coordinate.
	inline void set_no_e2_ni(double no_e2_ni) { m_no_e2_ni = no_e2_ni;}
	/// Returns the e1^e2^ni coordinate.
	inline double get_e1_e2_ni() const { return m_e1_e2_ni;}
	/// Sets the e1^e2^ni coordinate.
	inline void set_e1_e2_ni(double e1_e2_ni) { m_e1_e2_ni = e1_e2_ni;}
	/// Returns the no^e3^ni coordinate.
	inline double get_no_e3_ni() const { return m_no_e3_ni;}
	/// Sets the no^e3^ni coordinate.
	inline void set_no_e3_ni(double no_e3_ni) { m_no_e3_ni = no_e3_ni;}
	/// Returns the e1^e3^ni coordinate.
	inline double get_e1_e3_ni() const { return m_e1_e3_ni;}
	/// Sets the e1^e3^ni coordinate.
	inline void set_e1_e3_ni(double e1_e3_ni) { m_e1_e3_ni = e1_e3_ni;}
	/// Returns the e2^e3^ni coordinate.
	inline double get_e2_e3_ni() const { return m_e2_e3_ni;}
	/// Sets the e2^e3^ni coordinate.
	inline void set_e2_e3_ni(double e2_e3_ni) { m_e2_e3_ni = e2_e3_ni;}
	/// Returns the no^e1^e2^e3^ni coordinate.
	inline double get_no_e1_e2_e3_ni() const { return m_no_e1_e2_e3_ni;}
	/// Sets the no^e1^e2^e3^ni coordinate.
	inline void set_no_e1_e2_e3_ni(double no_e1_e2_e3_ni) { m_no_e1_e2_e3_ni = no_e1_e2_e3_ni;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class oddVersor

/// This class can hold a general outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 6 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: no, e1, e2, e3, ni.
/// Domain grade 2: no^e1, no^e2, e1^e2, no^e3, e1^e3, e2^e3, no^ni, e1^ni, e2^ni, e3^ni.
/// Domain grade 3: no^e1^e2, no^e1^e3, no^e2^e3, e1^e2^e3, no^e1^ni, no^e2^ni, e1^e2^ni, no^e3^ni, e1^e3^ni, e2^e3^ni.
/// Domain grade 4: no^e1^e2^e3, no^e1^e2^ni, no^e1^e3^ni, no^e2^e3^ni, e1^e2^e3^ni.
/// Domain grade 5: no^e1^e2^e3^ni.
/// 
/// The range and domain are equal.
/// 
class om
{
public:
	/// Matrix for grade 1; the size is 5 x 5
	double m_m1[25];
	/// Matrix for grade 2; the size is 10 x 10
	double m_m2[100];
	/// Matrix for grade 3; the size is 10 x 10
	double m_m3[100];
	/// Matrix for grade 4; the size is 5 x 5
	double m_m4[25];
	/// Matrix for grade 5; the size is 1 x 1
	double m_m5[1];
public:

	/// Floating point type used by om 
	typedef double Float;

	/// Constructs a new om, set to identity
	inline om() { setIdentity(); }

	/// Copy constructor.
	inline om(const om&M) { set(M); }

	/// Constructor from matrix
	inline om(const double *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline om(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini)
		{ set(ino, ie1, ie2, ie3, ini); }

	/// Converts a grade1OM_E3GA to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM_E3GA &M) { set(M); }
	
	/// Converts a grade1OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM &M) { set(M); }
	
	/// Converts a flatPointOM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const flatPointOM &M) { set(M); }
	

	/// Sets this to 'M'
	inline om &operator=(const om &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to grade1OM_E3GA.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM_E3GA &M) { set(M); return *this; }
	
	/// Sets this om to grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM &M) { set(M); return *this; }
	
	/// Sets this om to flatPointOM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const flatPointOM &M) { set(M); return *this; }
	

	/// Sets this om to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const om &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini);

	/// Sets this om to a grade1OM_E3GA.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM_E3GA &M);
	
	/// Sets this om to a grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM &M);
	
	/// Sets this om to a flatPointOM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const flatPointOM &M);
	
	private:
	void set_0();
	void set_1();
	void set_2();
	void set_3();
	void set_4();
	void set_grade_2_0();
	void set_grade_2_1();
	void set_grade_2_2();
	void set_grade_2_3();
	void set_grade_2_4();
	void set_grade_2_5();
	void set_grade_2_6();
	void set_grade_2_7();
	void set_grade_2_8();
	void set_grade_2_9();
	void set_grade_3_0();
	void set_grade_3_1();
	void set_grade_3_2();
	void set_grade_3_3();
	void set_grade_3_4();
	void set_grade_3_5();
	void set_grade_3_6();
	void set_grade_3_7();
	void set_grade_3_8();
	void set_grade_3_9();
	void set_grade_4_0();
	void set_grade_4_1();
	void set_grade_4_2();
	void set_grade_4_3();
	void set_grade_4_4();
	void set_grade_5_0();
	public:
}; // end of om

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 6 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2, e3.
/// Domain grade 2: .
/// Domain grade 3: .
/// Domain grade 4: .
/// Domain grade 5: .
/// 
/// The range and domain are equal.
/// 
class grade1OM_E3GA
{
public:
	/// Matrix for grade 1; the size is 3 x 3
	double m_m1[9];
public:

	/// Floating point type used by grade1OM_E3GA 
	typedef double Float;

	/// Constructs a new grade1OM_E3GA, set to identity
	inline grade1OM_E3GA() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM_E3GA(const grade1OM_E3GA&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM_E3GA(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM_E3GA(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM_E3GA(const vectorE3GA &ie1, const vectorE3GA &ie2, const vectorE3GA &ie3)
		{ set(ie1, ie2, ie3); }

	/// Converts a om to a grade1OM_E3GA.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM_E3GA(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM_E3GA &operator=(const grade1OM_E3GA &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM_E3GA.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM_E3GA &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM_E3GA to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM_E3GA &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vectorE3GA &ie1, const vectorE3GA &ie2, const vectorE3GA &ie3);

	/// Sets this grade1OM_E3GA to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM_E3GA

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 6 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: no, e1, e2, e3, ni.
/// Domain grade 2: .
/// Domain grade 3: .
/// Domain grade 4: .
/// Domain grade 5: .
/// 
/// The range and domain are equal.
/// 
class grade1OM
{
public:
	/// Matrix for grade 1; the size is 5 x 5
	double m_m1[25];
public:

	/// Floating point type used by grade1OM 
	typedef double Float;

	/// Constructs a new grade1OM, set to identity
	inline grade1OM() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM(const grade1OM&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini)
		{ set(ino, ie1, ie2, ie3, ini); }

	/// Converts a om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM &operator=(const grade1OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini);

	/// Sets this grade1OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 6 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: e1^ni, e2^ni, e3^ni, no^ni.
/// Domain grade 3: .
/// Domain grade 4: .
/// Domain grade 5: .
/// 
/// The range and domain are equal.
/// 
class flatPointOM
{
public:
	/// Matrix for grade 2; the size is 4 x 4
	double m_m2[16];
public:

	/// Floating point type used by flatPointOM 
	typedef double Float;

	/// Constructs a new flatPointOM, set to identity
	inline flatPointOM() { setIdentity(); }

	/// Copy constructor.
	inline flatPointOM(const flatPointOM&M) { set(M); }

	/// Constructor from matrix
	inline flatPointOM(const double *M) { set(M); }

	/// Constructor from matrix
	inline flatPointOM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline flatPointOM(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini)
		{ set(ino, ie1, ie2, ie3, ini); }

	/// Converts a om to a flatPointOM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline flatPointOM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline flatPointOM &operator=(const flatPointOM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a flatPointOM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline flatPointOM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this flatPointOM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const flatPointOM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini);

	/// Sets this flatPointOM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of flatPointOM
extern no_t no;
extern e1_t e1;
extern e2_t e2;
extern e3_t e3;
extern ni_t ni;
extern noni_t noni;
extern I3_t I3;
extern I5_t I5;
extern I5i_t I5i;
extern vectorE3GA vectorE1;
extern vectorE3GA vectorE2;
extern vectorE3GA vectorE3;
/** The point at the origin . . .  */
extern normalizedPoint pointAtOrigin;
/** The point at infinity . . .  */
extern dualSphere pointAtInfinity;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 63);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  no_t
double _double(const no_t &x);
/// Returns scalar part of  no_t
inline double _Float(const no_t &x) {return _double(x); };
/// Returns scalar part of  e1_t
double _double(const e1_t &x);
/// Returns scalar part of  e1_t
inline double _Float(const e1_t &x) {return _double(x); };
/// Returns scalar part of  e2_t
double _double(const e2_t &x);
/// Returns scalar part of  e2_t
inline double _Float(const e2_t &x) {return _double(x); };
/// Returns scalar part of  e3_t
double _double(const e3_t &x);
/// Returns scalar part of  e3_t
inline double _Float(const e3_t &x) {return _double(x); };
/// Returns scalar part of  ni_t
double _double(const ni_t &x);
/// Returns scalar part of  ni_t
inline double _Float(const ni_t &x) {return _double(x); };
/// Returns scalar part of  noni_t
double _double(const noni_t &x);
/// Returns scalar part of  noni_t
inline double _Float(const noni_t &x) {return _double(x); };
/// Returns scalar part of  I3_t
double _double(const I3_t &x);
/// Returns scalar part of  I3_t
inline double _Float(const I3_t &x) {return _double(x); };
/// Returns scalar part of  I5_t
double _double(const I5_t &x);
/// Returns scalar part of  I5_t
inline double _Float(const I5_t &x) {return _double(x); };
/// Returns scalar part of  I5i_t
double _double(const I5i_t &x);
/// Returns scalar part of  I5i_t
inline double _Float(const I5i_t &x) {return _double(x); };
/// Returns scalar part of  vectorE3GA
double _double(const vectorE3GA &x);
/// Returns scalar part of  vectorE3GA
inline double _Float(const vectorE3GA &x) {return _double(x); };
/// Returns scalar part of  bivectorE3GA
double _double(const bivectorE3GA &x);
/// Returns scalar part of  bivectorE3GA
inline double _Float(const bivectorE3GA &x) {return _double(x); };
/// Returns scalar part of  rotorE3GA
double _double(const rotorE3GA &x);
/// Returns scalar part of  rotorE3GA
inline double _Float(const rotorE3GA &x) {return _double(x); };
/// Returns scalar part of  normalizedPoint
double _double(const normalizedPoint &x);
/// Returns scalar part of  normalizedPoint
inline double _Float(const normalizedPoint &x) {return _double(x); };
/// Returns scalar part of  dualSphere
double _double(const dualSphere &x);
/// Returns scalar part of  dualSphere
inline double _Float(const dualSphere &x) {return _double(x); };
/// Returns scalar part of  dualPlane
double _double(const dualPlane &x);
/// Returns scalar part of  dualPlane
inline double _Float(const dualPlane &x) {return _double(x); };
/// Returns scalar part of  freeVector
double _double(const freeVector &x);
/// Returns scalar part of  freeVector
inline double _Float(const freeVector &x) {return _double(x); };
/// Returns scalar part of  freeBivector
double _double(const freeBivector &x);
/// Returns scalar part of  freeBivector
inline double _Float(const freeBivector &x) {return _double(x); };
/// Returns scalar part of  flatPoint
double _double(const flatPoint &x);
/// Returns scalar part of  flatPoint
inline double _Float(const flatPoint &x) {return _double(x); };
/// Returns scalar part of  pointPair
double _double(const pointPair &x);
/// Returns scalar part of  pointPair
inline double _Float(const pointPair &x) {return _double(x); };
/// Returns scalar part of  line
double _double(const line &x);
/// Returns scalar part of  line
inline double _Float(const line &x) {return _double(x); };
/// Returns scalar part of  circle
double _double(const circle &x);
/// Returns scalar part of  circle
inline double _Float(const circle &x) {return _double(x); };
/// Returns scalar part of  sphere
double _double(const sphere &x);
/// Returns scalar part of  sphere
inline double _Float(const sphere &x) {return _double(x); };
/// Returns scalar part of  plane
double _double(const plane &x);
/// Returns scalar part of  plane
inline double _Float(const plane &x) {return _double(x); };
/// Returns scalar part of  pseudoscalar
double _double(const pseudoscalar &x);
/// Returns scalar part of  pseudoscalar
inline double _Float(const pseudoscalar &x) {return _double(x); };
/// Returns scalar part of  normalizedTranslator
double _double(const normalizedTranslator &x);
/// Returns scalar part of  normalizedTranslator
inline double _Float(const normalizedTranslator &x) {return _double(x); };
/// Returns scalar part of  translator
double _double(const translator &x);
/// Returns scalar part of  translator
inline double _Float(const translator &x) {return _double(x); };
/// Returns scalar part of  RBM
double _double(const RBM &x);
/// Returns scalar part of  RBM
inline double _Float(const RBM &x) {return _double(x); };
/// Returns scalar part of  evenVersor
double _double(const evenVersor &x);
/// Returns scalar part of  evenVersor
inline double _Float(const evenVersor &x) {return _double(x); };
/// Returns scalar part of  oddVersor
double _double(const oddVersor &x);
/// Returns scalar part of  oddVersor
inline double _Float(const oddVersor &x) {return _double(x); };
/** Converts normalizedPoint to vectorE3GA: dst = P.
Extras vector part of point */
vectorE3GA _vectorE3GA(const normalizedPoint &P);
/** Converts dualSphere to vectorE3GA: dst = S.
Extras vector part of dual sphere */
vectorE3GA _vectorE3GA(const dualSphere &S);
/** Converts rotorE3GA to bivectorE3GA: dst = a.
Extracts Euclidean bivector part of Euclidean rotor */
bivectorE3GA _bivectorE3GA(const rotorE3GA &a);
/** Converts normalizedPoint to dualSphere: dst = P.
Converts a normalized point to a dual sphere */
dualSphere pointToSphere(const normalizedPoint &P);
/** Converts pointPair to evenVersor: dst = a. */
evenVersor _evenVersor(const pointPair &a);
/// Generates a random double in [0.0 1.0) interval using the c library rand() function
double genrand();
/// Seeds the random number generator for  double
void genrand_seed(unsigned int seed);
/// Seeds the random number generator for  double with the current time
void genrand_timeSeed();
/// Returns conformal point.
normalizedPoint cgaPoint(const vectorE3GA &a);
/// Returns conformal point.
normalizedPoint cgaPoint(const double a, const double b, const double c);

/** Returns a random conformal point where the coordinates lie in the interval [-scale, scale). */
normalizedPoint randomCgaPoint(double scale);
/// Returns distance of two conformal points.
double cgaPointDistance(const normalizedPoint &a, const normalizedPoint &b);
/// Returns distance of two conformal points.
double cgaPointDistance(const dualSphere &a, const dualSphere &b);
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns vectorE3GA + vectorE3GA.
vectorE3GA add(const vectorE3GA &a, const vectorE3GA &b);
/// Returns vectorE3GA + normalizedPoint.
normalizedPoint add(const vectorE3GA &a, const normalizedPoint &b);
/// Returns vectorE3GA + dualSphere.
dualSphere add(const vectorE3GA &a, const dualSphere &b);
/// Returns bivectorE3GA + bivectorE3GA.
bivectorE3GA add(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns plane + plane.
plane add(const plane &a, const plane &b);
/// Returns line + circle.
circle add(const line &a, const circle &b);
/// Returns circle + vectorE3GA.
oddVersor add(const circle &a, const vectorE3GA &b);
/// Returns e1_t + e2_t.
vectorE3GA add(const e1_t &a, const e2_t &b);
/// Returns I5_t + circle.
oddVersor add(const I5_t &a, const circle &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns vectorE3GA - vectorE3GA.
vectorE3GA subtract(const vectorE3GA &a, const vectorE3GA &b);
/// Returns bivectorE3GA - bivectorE3GA.
bivectorE3GA subtract(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns oddVersor - oddVersor.
oddVersor subtract(const oddVersor &a, const oddVersor &b);
/// Returns line - vectorE3GA.
oddVersor subtract(const line &a, const vectorE3GA &b);
/// Returns rotorE3GA - rotorE3GA.
rotorE3GA subtract(const rotorE3GA &a, const rotorE3GA &b);
/// Returns rotorE3GA - noni_t.
evenVersor subtract(const rotorE3GA &a, const noni_t &b);
/// Returns I5_t - circle.
oddVersor subtract(const I5_t &a, const circle &b);
/// Returns om * mv.
mv applyOM(const om &a, const mv &b);
/// Returns om * normalizedPoint.
dualSphere applyOM(const om &a, const normalizedPoint &b);
/// Returns om * circle.
circle applyOM(const om &a, const circle &b);
/// Returns om * sphere.
sphere applyOM(const om &a, const sphere &b);
/// Returns grade1OM_E3GA * vectorE3GA.
vectorE3GA applyOM(const grade1OM_E3GA &a, const vectorE3GA &b);
/// Returns grade1OM_E3GA * e1_t.
vectorE3GA applyOM(const grade1OM_E3GA &a, const e1_t &b);
/// Returns grade1OM_E3GA * no_t.
double applyOM(const grade1OM_E3GA &a, const no_t &b);
/// Returns grade1OM_E3GA * normalizedPoint.
vectorE3GA applyOM(const grade1OM_E3GA &a, const normalizedPoint &b);
/// Returns flatPointOM * flatPoint.
flatPoint applyOM(const flatPointOM &a, const flatPoint &b);
/// Returns flatPointOM * noni_t.
flatPoint applyOM(const flatPointOM &a, const noni_t &b);
/// Returns a * b * inverse(a) using default metric.
mv applyVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyUnitVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyVersorWI(const mv &a, const mv &b, const mv &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vectorE3GA applyUnitVersor(const rotorE3GA &a, const vectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const rotorE3GA &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const rotorE3GA &a, const dualSphere &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivectorE3GA applyUnitVersor(const rotorE3GA &a, const bivectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyUnitVersor(const rotorE3GA &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyUnitVersor(const rotorE3GA &a, const plane &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
flatPoint applyUnitVersor(const rotorE3GA &a, const noni_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const rotorE3GA &a, const no_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualPlane applyUnitVersor(const rotorE3GA &a, const ni_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
rotorE3GA applyUnitVersor(const rotorE3GA &a, const rotorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyUnitVersor(const rotorE3GA &a, const I5_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const evenVersor &a, const vectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const evenVersor &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const evenVersor &a, const dualSphere &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pointPair applyUnitVersor(const evenVersor &a, const bivectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
circle applyUnitVersor(const evenVersor &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
sphere applyUnitVersor(const evenVersor &a, const sphere &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const evenVersor &a, const ni_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
evenVersor applyUnitVersor(const evenVersor &a, const rotorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyUnitVersor(const evenVersor &a, const I5i_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const oddVersor &a, const vectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const oddVersor &a, const normalizedPoint &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyUnitVersor(const oddVersor &a, const dualSphere &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pointPair applyUnitVersor(const oddVersor &a, const bivectorE3GA &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
circle applyUnitVersor(const oddVersor &a, const line &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
sphere applyUnitVersor(const oddVersor &a, const plane &b);
/// Returns a * b * inverse(a) using default metric.
vectorE3GA applyVersor(const rotorE3GA &a, const vectorE3GA &b);
/// Returns a * b * inverse(a) using euclidean metric.
dualSphere applyVersor(const rotorE3GA &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const rotorE3GA &a, const dualSphere &b);
/// Returns a * b * inverse(a) using default metric.
bivectorE3GA applyVersor(const rotorE3GA &a, const bivectorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
line applyVersor(const rotorE3GA &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
plane applyVersor(const rotorE3GA &a, const plane &b);
/// Returns a * b * inverse(a) using default metric.
flatPoint applyVersor(const rotorE3GA &a, const noni_t &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const rotorE3GA &a, const no_t &b);
/// Returns a * b * inverse(a) using default metric.
dualPlane applyVersor(const rotorE3GA &a, const ni_t &b);
/// Returns a * b * inverse(a) using default metric.
rotorE3GA applyVersor(const rotorE3GA &a, const rotorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
pseudoscalar applyVersor(const rotorE3GA &a, const I5_t &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const evenVersor &a, const vectorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const evenVersor &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const evenVersor &a, const dualSphere &b);
/// Returns a * b * inverse(a) using default metric.
pointPair applyVersor(const evenVersor &a, const bivectorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
circle applyVersor(const evenVersor &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
sphere applyVersor(const evenVersor &a, const sphere &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const evenVersor &a, const ni_t &b);
/// Returns a * b * inverse(a) using default metric.
evenVersor applyVersor(const evenVersor &a, const rotorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
pseudoscalar applyVersor(const evenVersor &a, const I5i_t &b);
/// Returns a * b * inverse(a) using euclidean metric.
dualSphere applyVersor(const oddVersor &a, const vectorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const oddVersor &a, const normalizedPoint &b);
/// Returns a * b * inverse(a) using default metric.
dualSphere applyVersor(const oddVersor &a, const dualSphere &b);
/// Returns a * b * inverse(a) using default metric.
pointPair applyVersor(const oddVersor &a, const bivectorE3GA &b);
/// Returns a * b * inverse(a) using default metric.
circle applyVersor(const oddVersor &a, const line &b);
/// Returns a * b * inverse(a) using default metric.
sphere applyVersor(const oddVersor &a, const plane &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vectorE3GA applyVersorWI(const rotorE3GA &a, const vectorE3GA &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyVersorWI(const rotorE3GA &a, const normalizedPoint &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
dualSphere applyVersorWI(const rotorE3GA &a, const dualSphere &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivectorE3GA applyVersorWI(const rotorE3GA &a, const bivectorE3GA &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
line applyVersorWI(const rotorE3GA &a, const line &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
plane applyVersorWI(const rotorE3GA &a, const plane &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vectorE3GA applyVersorWI(const rotorE3GA &a, const e1_t &b, const rotorE3GA &c);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
pseudoscalar applyVersorWI(const rotorE3GA &a, const I5_t &b, const rotorE3GA &c);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns a / b
vectorE3GA div(const vectorE3GA &a, const double b);
/// Returns a / b
dualSphere div(const normalizedPoint &a, const double b);
/// Returns a / b
bivectorE3GA div(const bivectorE3GA &a, const double b);
/// Returns a / b
line div(const line &a, const double b);
/// Returns a / b
plane div(const plane &a, const double b);
/// Returns a / b
sphere div(const sphere &a, const double b);
/// Returns a / b
pseudoscalar div(const I5_t &a, const double b);
/// Returns a / b
evenVersor div(const evenVersor &a, const double b);
/// Returns a / b
oddVersor div(const oddVersor &a, const double b);
/// Returns a / b
circle div(const I3_t &a, const double b);
/// Returns a / b
flatPoint div(const noni_t &a, const double b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);
/// Returns dual of double using default metric.
pseudoscalar dual(const double a);
/// Returns undual of double using default metric.
pseudoscalar undual(const double a);
/// Returns dual of vectorE3GA using default metric.
plane dual(const vectorE3GA &a);
/// Returns undual of vectorE3GA using default metric.
plane undual(const vectorE3GA &a);
/// Returns dual of normalizedPoint using default metric.
sphere dual(const normalizedPoint &a);
/// Returns undual of normalizedPoint using default metric.
sphere undual(const normalizedPoint &a);
/// Returns dual of bivectorE3GA using default metric.
line dual(const bivectorE3GA &a);
/// Returns undual of bivectorE3GA using default metric.
line undual(const bivectorE3GA &a);
/// Returns dual of rotorE3GA using default metric.
oddVersor dual(const rotorE3GA &a);
/// Returns undual of rotorE3GA using default metric.
oddVersor undual(const rotorE3GA &a);
/// Returns dual of oddVersor using default metric.
evenVersor dual(const oddVersor &a);
/// Returns undual of oddVersor using default metric.
evenVersor undual(const oddVersor &a);
/// Returns dual of evenVersor using default metric.
oddVersor dual(const evenVersor &a);
/// Returns undual of evenVersor using default metric.
oddVersor undual(const evenVersor &a);
/// Returns dual of pointPair using default metric.
circle dual(const pointPair &a);
/// Returns undual of pointPair using default metric.
circle undual(const pointPair &a);
/// Returns dual of plane using default metric.
dualPlane dual(const plane &a);
/// Returns undual of plane using default metric.
dualPlane undual(const plane &a);
/// Returns dual of circle using euclidean metric.
pointPair dual(const circle &a);
/// Returns undual of circle using euclidean metric.
pointPair undual(const circle &a);
/// Returns dual of e1_t using default metric.
plane dual(const e1_t &a);
/// Returns undual of I3_t using default metric.
noni_t undual(const I3_t &a);
/// Returns dual of I5_t using default metric.
double dual(const I5_t &a);
/// Returns undual of I5i_t using default metric.
double undual(const I5i_t &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const vectorE3GA &a, const vectorE3GA &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivectorE3GA &a, const bivectorE3GA &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotorE3GA &a, const rotorE3GA &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivectorE3GA &a, const rotorE3GA &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotorE3GA &a, const bivectorE3GA &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotorE3GA &a, const line &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const evenVersor &a, const plane &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const circle &a, const line &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const plane &a, const plane &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const normalizedPoint &a, const normalizedPoint &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const e1_t &a, const e1_t &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const I5_t &a, const I5i_t &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const noni_t &a, const pointPair &b, const double c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 0 of  rotorE3GA.
double extractGrade0(const rotorE3GA &a);
/// Returns grade 2 of  rotorE3GA.
bivectorE3GA extractGrade2(const rotorE3GA &a);
/// Returns grade 1 of  oddVersor.
dualSphere extractGrade1(const oddVersor &a);
/// Returns grade 3 of  oddVersor.
circle extractGrade3(const oddVersor &a);
/// Returns grade 4 of  oddVersor.
double extractGrade4(const oddVersor &a);
/// Returns grade 0 of  evenVersor.
double extractGrade0(const evenVersor &a);
/// Returns grade 1 of  evenVersor.
double extractGrade1(const evenVersor &a);
/// Returns grade 4 of  evenVersor.
sphere extractGrade4(const evenVersor &a);
/// Returns grade 0 of  normalizedPoint.
double extractGrade0(const normalizedPoint &a);
/// Returns grade 1 of  normalizedPoint.
normalizedPoint extractGrade1(const normalizedPoint &a);
/// Returns grade 2 of  normalizedPoint.
double extractGrade2(const normalizedPoint &a);
/// Returns grade 3 of  dualSphere.
double extractGrade3(const dualSphere &a);
/// Returns grade 4 of  normalizedPoint.
double extractGrade4(const normalizedPoint &a);
/// Returns grade 5 of  normalizedPoint.
double extractGrade5(const normalizedPoint &a);
/// Returns grade 0 of  e1_t.
double extractGrade0(const e1_t &a);
/// Returns grade 1 of  e2_t.
e2_t extractGrade1(const e2_t &a);
/// Returns grade 2 of  e3_t.
double extractGrade2(const e3_t &a);
/// Returns grade 3 of  no_t.
double extractGrade3(const no_t &a);
/// Returns grade 4 of  e1_t.
double extractGrade4(const e1_t &a);
/// Returns grade 0 of  I5_t.
double extractGrade0(const I5_t &a);
/// Returns grade 1 of  I5i_t.
double extractGrade1(const I5i_t &a);
/// Returns grade 2 of  I5_t.
double extractGrade2(const I5_t &a);
/// Returns grade 3 of  I5i_t.
double extractGrade3(const I5i_t &a);
/// Returns grade 4 of  I5_t.
double extractGrade4(const I5_t &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of vectorE3GA and vectorE3GA.
rotorE3GA gp(const vectorE3GA &a, const vectorE3GA &b);
/// Returns geometric product of rotorE3GA and vectorE3GA.
oddVersor gp(const rotorE3GA &a, const vectorE3GA &b);
/// Returns geometric product of circle and line.
evenVersor gp(const circle &a, const line &b);
/// Returns geometric product of rotorE3GA and line.
oddVersor gp(const rotorE3GA &a, const line &b);
/// Returns geometric product of vectorE3GA and rotorE3GA.
oddVersor gp(const vectorE3GA &a, const rotorE3GA &b);
/// Returns geometric product of rotorE3GA and rotorE3GA.
rotorE3GA gp(const rotorE3GA &a, const rotorE3GA &b);
/// Returns geometric product of plane and rotorE3GA.
evenVersor gp(const plane &a, const rotorE3GA &b);
/// Returns geometric product of plane and oddVersor.
oddVersor gp(const plane &a, const oddVersor &b);
/// Returns geometric product of bivectorE3GA and bivectorE3GA.
rotorE3GA gp(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns geometric product of evenVersor and dualSphere.
oddVersor gp(const evenVersor &a, const dualSphere &b);
/// Returns geometric product of normalizedPoint and normalizedPoint.
evenVersor gp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns geometric product of flatPoint and oddVersor.
oddVersor gp(const flatPoint &a, const oddVersor &b);
/// Returns geometric product of e1_t and e2_t.
bivectorE3GA gp(const e1_t &a, const e2_t &b);
/// Returns geometric product of e3_t and ni_t.
freeVector gp(const e3_t &a, const ni_t &b);
/// Returns geometric product of no_t and ni_t.
evenVersor gp(const no_t &a, const ni_t &b);
/// Returns geometric product of e3_t and I5i_t.
plane gp(const e3_t &a, const I5i_t &b);
/// Returns geometric product of mv and mv.
mv gp_em(const mv &a, const mv &b);
/// Returns geometric product of vectorE3GA and vectorE3GA.
rotorE3GA gp_em(const vectorE3GA &a, const vectorE3GA &b);
/// Returns geometric product of rotorE3GA and vectorE3GA.
oddVersor gp_em(const rotorE3GA &a, const vectorE3GA &b);
/// Returns geometric product of vectorE3GA and line.
evenVersor gp_em(const vectorE3GA &a, const line &b);
/// Returns geometric product of rotorE3GA and circle.
oddVersor gp_em(const rotorE3GA &a, const circle &b);
/// Returns geometric product of vectorE3GA and rotorE3GA.
oddVersor gp_em(const vectorE3GA &a, const rotorE3GA &b);
/// Returns geometric product of rotorE3GA and rotorE3GA.
rotorE3GA gp_em(const rotorE3GA &a, const rotorE3GA &b);
/// Returns geometric product of plane and rotorE3GA.
evenVersor gp_em(const plane &a, const rotorE3GA &b);
/// Returns geometric product of sphere and circle.
oddVersor gp_em(const sphere &a, const circle &b);
/// Returns geometric product of bivectorE3GA and bivectorE3GA.
rotorE3GA gp_em(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const mv &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const rotorE3GA &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const oddVersor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const evenVersor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const vectorE3GA &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const bivectorE3GA &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const pseudoscalar &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const circle &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const pointPair &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e1_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e2_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const noni_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const I5i_t &a, const double b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv hp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and vectorE3GA.
vectorE3GA hp(const vectorE3GA &a, const vectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivectorE3GA and bivectorE3GA.
bivectorE3GA hp(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotorE3GA and rotorE3GA.
rotorE3GA hp(const rotorE3GA &a, const rotorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of oddVersor and oddVersor.
oddVersor hp(const oddVersor &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and oddVersor.
vectorE3GA hp(const vectorE3GA &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and evenVersor.
evenVersor hp(const evenVersor &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivectorE3GA and rotorE3GA.
bivectorE3GA hp(const bivectorE3GA &a, const rotorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of circle and evenVersor.
double hp(const circle &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and oddVersor.
pseudoscalar hp(const pseudoscalar &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotorE3GA and bivectorE3GA.
bivectorE3GA hp(const rotorE3GA &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and bivectorE3GA.
bivectorE3GA hp(const evenVersor &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of sphere and plane.
plane hp(const sphere &a, const plane &b);
/// Returns Hadamard product (coordinate-wise multiplication) of normalizedPoint and e1_t.
vectorE3GA hp(const normalizedPoint &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and e1_t.
vectorE3GA hp(const vectorE3GA &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of I5_t and pseudoscalar.
pseudoscalar hp(const I5_t &a, const pseudoscalar &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and I5i_t.
pseudoscalar hp(const pseudoscalar &a, const I5i_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv ihp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and vectorE3GA.
vectorE3GA ihp(const vectorE3GA &a, const vectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivectorE3GA and bivectorE3GA.
bivectorE3GA ihp(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotorE3GA and rotorE3GA.
rotorE3GA ihp(const rotorE3GA &a, const rotorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of circle and oddVersor.
circle ihp(const circle &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and oddVersor.
vectorE3GA ihp(const vectorE3GA &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and evenVersor.
evenVersor ihp(const evenVersor &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivectorE3GA and rotorE3GA.
bivectorE3GA ihp(const bivectorE3GA &a, const rotorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of plane and evenVersor.
plane ihp(const plane &a, const evenVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and oddVersor.
pseudoscalar ihp(const pseudoscalar &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotorE3GA and bivectorE3GA.
bivectorE3GA ihp(const rotorE3GA &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of evenVersor and bivectorE3GA.
bivectorE3GA ihp(const evenVersor &a, const bivectorE3GA &b);
/// Returns Hadamard product (coordinate-wise multiplication) of dualSphere and normalizedPoint.
dualSphere ihp(const dualSphere &a, const normalizedPoint &b);
/// Returns Hadamard product (coordinate-wise multiplication) of normalizedPoint and normalizedPoint.
normalizedPoint ihp(const normalizedPoint &a, const normalizedPoint &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vectorE3GA and e1_t.
vectorE3GA ihp(const vectorE3GA &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of I5_t and pseudoscalar.
pseudoscalar ihp(const I5_t &a, const pseudoscalar &b);
/// Returns Hadamard product (coordinate-wise multiplication) of pseudoscalar and I5i_t.
pseudoscalar ihp(const pseudoscalar &a, const I5i_t &b);
/// Returns (a + 1).
mv increment(const mv &a);
/// Returns (a + 1).
rotorE3GA increment(const bivectorE3GA &a);
/// Returns (a + 1).
rotorE3GA increment(const rotorE3GA &a);
/// Returns (a + 1).
evenVersor increment(const evenVersor &a);
/// Returns (a + 1).
evenVersor increment(const pointPair &a);
/// Returns (a + 1).
evenVersor increment(const noni_t &a);
/// Returns (a - 1).
mv decrement(const mv &a);
/// Returns (a - 1).
rotorE3GA decrement(const bivectorE3GA &a);
/// Returns (a - 1).
rotorE3GA decrement(const rotorE3GA &a);
/// Returns (a - 1).
evenVersor decrement(const evenVersor &a);
/// Returns (a - 1).
evenVersor decrement(const noni_t &a);
/// Returns (a - 1).
translator decrement(const freeVector &a);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns Hestenes inner product of mv and mv.
mv hip(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns scalar product of vectorE3GA and vectorE3GA.
double sp(const vectorE3GA &a, const vectorE3GA &b);
/// Returns left contraction of vectorE3GA and plane.
line lc(const vectorE3GA &a, const plane &b);
/// Returns right contraction of vectorE3GA and line.
double rc(const vectorE3GA &a, const line &b);
/// Returns Hestenes inner product of vectorE3GA and vectorE3GA.
double hip(const vectorE3GA &a, const vectorE3GA &b);
/// Returns Modified Hestenes inner product of pseudoscalar and vectorE3GA.
plane mhip(const pseudoscalar &a, const vectorE3GA &b);
/// Returns scalar product of bivectorE3GA and oddVersor.
double sp(const bivectorE3GA &a, const oddVersor &b);
/// Returns left contraction of bivectorE3GA and vectorE3GA.
double lc(const bivectorE3GA &a, const vectorE3GA &b);
/// Returns right contraction of evenVersor and vectorE3GA.
oddVersor rc(const evenVersor &a, const vectorE3GA &b);
/// Returns Hestenes inner product of oddVersor and vectorE3GA.
evenVersor hip(const oddVersor &a, const vectorE3GA &b);
/// Returns Modified Hestenes inner product of bivectorE3GA and vectorE3GA.
vectorE3GA mhip(const bivectorE3GA &a, const vectorE3GA &b);
/// Returns scalar product of vectorE3GA and pseudoscalar.
double sp(const vectorE3GA &a, const pseudoscalar &b);
/// Returns left contraction of vectorE3GA and evenVersor.
oddVersor lc(const vectorE3GA &a, const evenVersor &b);
/// Returns right contraction of vectorE3GA and bivectorE3GA.
double rc(const vectorE3GA &a, const bivectorE3GA &b);
/// Returns Hestenes inner product of vectorE3GA and plane.
line hip(const vectorE3GA &a, const plane &b);
/// Returns Modified Hestenes inner product of vectorE3GA and line.
flatPoint mhip(const vectorE3GA &a, const line &b);
/// Returns scalar product of evenVersor and rotorE3GA.
double sp(const evenVersor &a, const rotorE3GA &b);
/// Returns left contraction of evenVersor and rotorE3GA.
rotorE3GA lc(const evenVersor &a, const rotorE3GA &b);
/// Returns right contraction of oddVersor and rotorE3GA.
oddVersor rc(const oddVersor &a, const rotorE3GA &b);
/// Returns Hestenes inner product of oddVersor and rotorE3GA.
oddVersor hip(const oddVersor &a, const rotorE3GA &b);
/// Returns Modified Hestenes inner product of oddVersor and rotorE3GA.
oddVersor mhip(const oddVersor &a, const rotorE3GA &b);
/// Returns scalar product of e1_t and rotorE3GA.
double sp(const e1_t &a, const rotorE3GA &b);
/// Returns left contraction of e2_t and rotorE3GA.
vectorE3GA lc(const e2_t &a, const rotorE3GA &b);
/// Returns right contraction of I5_t and rotorE3GA.
oddVersor rc(const I5_t &a, const rotorE3GA &b);
/// Returns Hestenes inner product of I5i_t and rotorE3GA.
line hip(const I5i_t &a, const rotorE3GA &b);
/// Returns Modified Hestenes inner product of no_t and rotorE3GA.
dualSphere mhip(const no_t &a, const rotorE3GA &b);
/// Returns scalar product of e1_t and e1_t.
double sp(const e1_t &a, const e1_t &b);
/// Returns left contraction of e2_t and e3_t.
double lc(const e2_t &a, const e3_t &b);
/// Returns right contraction of I5_t and I5i_t.
double rc(const I5_t &a, const I5i_t &b);
/// Returns Hestenes inner product of I5i_t and ni_t.
plane hip(const I5i_t &a, const ni_t &b);
/// Returns Modified Hestenes inner product of no_t and e1_t.
double mhip(const no_t &a, const e1_t &b);
/// Returns scalar product of rotorE3GA and plane.
double sp(const rotorE3GA &a, const plane &b);
/// Returns left contraction of rotorE3GA and line.
oddVersor lc(const rotorE3GA &a, const line &b);
/// Returns right contraction of rotorE3GA and evenVersor.
rotorE3GA rc(const rotorE3GA &a, const evenVersor &b);
/// Returns Hestenes inner product of rotorE3GA and bivectorE3GA.
double hip(const rotorE3GA &a, const bivectorE3GA &b);
/// Returns Modified Hestenes inner product of rotorE3GA and pseudoscalar.
oddVersor mhip(const rotorE3GA &a, const pseudoscalar &b);
/// Returns Hestenes inner product of ni_t and normalizedPoint.
double hip(const ni_t &a, const normalizedPoint &b);
/// Returns Modified Hestenes inner product of ni_t and normalizedPoint.
double mhip(const ni_t &a, const normalizedPoint &b);
/// Returns left contraction of ni_t and normalizedPoint.
double lc(const ni_t &a, const normalizedPoint &b);
/// Returns right contraction of ni_t and normalizedPoint.
double rc(const ni_t &a, const normalizedPoint &b);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm of vectorE3GA using default metric.
double norm(const vectorE3GA &a);
/// internal conversion function
double norm_returns_scalar(const vectorE3GA &a);
/// Returns norm of bivectorE3GA using default metric.
double norm(const bivectorE3GA &a);
/// internal conversion function
double norm_returns_scalar(const bivectorE3GA &a);
/// Returns norm of line using default metric.
double norm(const line &a);
/// internal conversion function
double norm_returns_scalar(const line &a);
/// Returns norm of plane using default metric.
double norm(const plane &a);
/// internal conversion function
double norm_returns_scalar(const plane &a);
/// Returns norm of rotorE3GA using default metric.
double norm(const rotorE3GA &a);
/// internal conversion function
double norm_returns_scalar(const rotorE3GA &a);
/// Returns norm of oddVersor using default metric.
double norm(const oddVersor &a);
/// internal conversion function
double norm_returns_scalar(const oddVersor &a);
/// Returns norm of evenVersor using default metric.
double norm(const evenVersor &a);
/// internal conversion function
double norm_returns_scalar(const evenVersor &a);
/// Returns norm of normalizedPoint using default metric.
double norm(const normalizedPoint &a);
/// internal conversion function
double norm_returns_scalar(const normalizedPoint &a);
/// Returns norm of dualSphere using default metric.
double norm(const dualSphere &a);
/// internal conversion function
double norm_returns_scalar(const dualSphere &a);
/// Returns norm of pseudoscalar using default metric.
double norm(const pseudoscalar &a);
/// internal conversion function
double norm_returns_scalar(const pseudoscalar &a);
/// Returns norm of e1_t using default metric.
double norm(const e1_t &a);
/// internal conversion function
double norm_returns_scalar(const e1_t &a);
/// Returns norm of noni_t using default metric.
double norm(const noni_t &a);
/// internal conversion function
double norm_returns_scalar(const noni_t &a);
/// Returns norm of I5i_t using default metric.
double norm(const I5i_t &a);
/// internal conversion function
double norm_returns_scalar(const I5i_t &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns norm2 of vectorE3GA using default metric.
double norm2(const vectorE3GA &a);
/// internal conversion function
double norm2_returns_scalar(const vectorE3GA &a);
/// Returns norm2 of bivectorE3GA using default metric.
double norm2(const bivectorE3GA &a);
/// internal conversion function
double norm2_returns_scalar(const bivectorE3GA &a);
/// Returns norm2 of normalizedPoint using default metric.
double norm2(const normalizedPoint &a);
/// internal conversion function
double norm2_returns_scalar(const normalizedPoint &a);
/// Returns norm2 of dualSphere using default metric.
double norm2(const dualSphere &a);
/// internal conversion function
double norm2_returns_scalar(const dualSphere &a);
/// Returns norm2 of circle using default metric.
double norm2(const circle &a);
/// internal conversion function
double norm2_returns_scalar(const circle &a);
/// Returns norm2 of sphere using default metric.
double norm2(const sphere &a);
/// internal conversion function
double norm2_returns_scalar(const sphere &a);
/// Returns norm2 of rotorE3GA using default metric.
double norm2(const rotorE3GA &a);
/// internal conversion function
double norm2_returns_scalar(const rotorE3GA &a);
/// Returns norm2 of oddVersor using default metric.
double norm2(const oddVersor &a);
/// internal conversion function
double norm2_returns_scalar(const oddVersor &a);
/// Returns norm2 of evenVersor using default metric.
double norm2(const evenVersor &a);
/// internal conversion function
double norm2_returns_scalar(const evenVersor &a);
/// Returns norm2 of pseudoscalar using default metric.
double norm2(const pseudoscalar &a);
/// internal conversion function
double norm2_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of e3_t using default metric.
double norm2(const e3_t &a);
/// internal conversion function
double norm2_returns_scalar(const e3_t &a);
/// Returns norm2 of no_t using default metric.
double norm2(const no_t &a);
/// internal conversion function
double norm2_returns_scalar(const no_t &a);
/// Returns norm2 of I5_t using default metric.
double norm2(const I5_t &a);
/// internal conversion function
double norm2_returns_scalar(const I5_t &a);
/// Returns norm of mv using euclidean metric.
double norm_em(const mv &a);
/// internal conversion function
double norm_em_returns_scalar(const mv &a);
/// Returns norm of vectorE3GA using euclidean metric.
double norm_em(const vectorE3GA &a);
/// internal conversion function
double norm_em_returns_scalar(const vectorE3GA &a);
/// Returns norm of bivectorE3GA using euclidean metric.
double norm_em(const bivectorE3GA &a);
/// internal conversion function
double norm_em_returns_scalar(const bivectorE3GA &a);
/// Returns norm of freeVector using euclidean metric.
double norm_em(const freeVector &a);
/// internal conversion function
double norm_em_returns_scalar(const freeVector &a);
/// Returns norm of freeBivector using euclidean metric.
double norm_em(const freeBivector &a);
/// internal conversion function
double norm_em_returns_scalar(const freeBivector &a);
/// Returns norm of rotorE3GA using euclidean metric.
double norm_em(const rotorE3GA &a);
/// internal conversion function
double norm_em_returns_scalar(const rotorE3GA &a);
/// Returns norm of oddVersor using euclidean metric.
double norm_em(const oddVersor &a);
/// internal conversion function
double norm_em_returns_scalar(const oddVersor &a);
/// Returns norm of evenVersor using euclidean metric.
double norm_em(const evenVersor &a);
/// internal conversion function
double norm_em_returns_scalar(const evenVersor &a);
/// Returns norm of pseudoscalar using euclidean metric.
double norm_em(const pseudoscalar &a);
/// internal conversion function
double norm_em_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of mv using euclidean metric.
double norm2_em(const mv &a);
/// internal conversion function
double norm2_em_returns_scalar(const mv &a);
/// Returns norm2 of vectorE3GA using euclidean metric.
double norm2_em(const vectorE3GA &a);
/// internal conversion function
double norm2_em_returns_scalar(const vectorE3GA &a);
/// Returns norm2 of bivectorE3GA using euclidean metric.
double norm2_em(const bivectorE3GA &a);
/// internal conversion function
double norm2_em_returns_scalar(const bivectorE3GA &a);
/// Returns norm2 of line using euclidean metric.
double norm2_em(const line &a);
/// internal conversion function
double norm2_em_returns_scalar(const line &a);
/// Returns norm2 of plane using euclidean metric.
double norm2_em(const plane &a);
/// internal conversion function
double norm2_em_returns_scalar(const plane &a);
/// Returns norm2 of rotorE3GA using euclidean metric.
double norm2_em(const rotorE3GA &a);
/// internal conversion function
double norm2_em_returns_scalar(const rotorE3GA &a);
/// Returns norm2 of oddVersor using euclidean metric.
double norm2_em(const oddVersor &a);
/// internal conversion function
double norm2_em_returns_scalar(const oddVersor &a);
/// Returns norm2 of evenVersor using euclidean metric.
double norm2_em(const evenVersor &a);
/// internal conversion function
double norm2_em_returns_scalar(const evenVersor &a);
/// Returns norm2 of pseudoscalar using euclidean metric.
double norm2_em(const pseudoscalar &a);
/// internal conversion function
double norm2_em_returns_scalar(const pseudoscalar &a);
/// Returns norm2 of no_t using euclidean metric.
double norm2_em(const no_t &a);
/// internal conversion function
double norm2_em_returns_scalar(const no_t &a);
/// Returns norm2 of I5_t using euclidean metric.
double norm2_em(const I5_t &a);
/// internal conversion function
double norm2_em_returns_scalar(const I5_t &a);
/// Returns norm2 of e1_t using euclidean metric.
double norm2_em(const e1_t &a);
/// internal conversion function
double norm2_em_returns_scalar(const e1_t &a);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vectorE3GA and vectorE3GA.
bivectorE3GA op(const vectorE3GA &a, const vectorE3GA &b);
/// Returns outer product of rotorE3GA and vectorE3GA.
oddVersor op(const rotorE3GA &a, const vectorE3GA &b);
/// Returns outer product of vectorE3GA and line.
plane op(const vectorE3GA &a, const line &b);
/// Returns outer product of rotorE3GA and circle.
oddVersor op(const rotorE3GA &a, const circle &b);
/// Returns outer product of vectorE3GA and rotorE3GA.
oddVersor op(const vectorE3GA &a, const rotorE3GA &b);
/// Returns outer product of rotorE3GA and rotorE3GA.
rotorE3GA op(const rotorE3GA &a, const rotorE3GA &b);
/// Returns outer product of plane and rotorE3GA.
plane op(const plane &a, const rotorE3GA &b);
/// Returns outer product of circle and pointPair.
pseudoscalar op(const circle &a, const pointPair &b);
/// Returns outer product of bivectorE3GA and bivectorE3GA.
double op(const bivectorE3GA &a, const bivectorE3GA &b);
/// Returns outer product of pseudoscalar and oddVersor.
double op(const pseudoscalar &a, const oddVersor &b);
/// Returns outer product of no_t and ni_t.
noni_t op(const no_t &a, const ni_t &b);
/// Returns outer product of ni_t and no_t.
flatPoint op(const ni_t &a, const no_t &b);
/// Returns geometric product of mv and double.
mv gp(const mv &a, const double b);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);

/** Computes exp of pointPair.
 */
evenVersor exp(const pointPair &x, int order = 12);
/// exp of freeVector (uses fast special case)
normalizedTranslator exp(const freeVector &a);
/// exp of noni_t (uses fast special case)
evenVersor exp(const noni_t &a);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);
/// cosh of flatPoint (uses fast special case)
double cosh(const flatPoint &a);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);
/// sinh of bivectorE3GA (uses fast special case)
bivectorE3GA sinh(const bivectorE3GA &a);
/// sinh of freeVector (uses fast special case)
freeVector sinh(const freeVector &a);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);
/// cos of bivectorE3GA (uses fast special case)
double cos(const bivectorE3GA &a);

/** Computes cos of pointPair.
 */
evenVersor cos(const pointPair &x, int order = 12);
/// cos of freeVector (uses fast special case)
double cos(const freeVector &a);
/// cos of noni_t (uses fast special case)
double cos(const noni_t &a);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);
/// sin of bivectorE3GA (uses fast special case)
bivectorE3GA sin(const bivectorE3GA &a);

/** Computes sin of pointPair.
 */
evenVersor sin(const pointPair &x, int order = 12);
/// sin of freeVector (uses fast special case)
freeVector sin(const freeVector &a);
/// sin of noni_t (uses fast special case)
flatPoint sin(const noni_t &a);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns negation of vectorE3GA.
vectorE3GA negate(const vectorE3GA &a);
/// Returns negation of freeVector.
freeVector negate(const freeVector &a);
/// Returns negation of normalizedPoint.
dualSphere negate(const normalizedPoint &a);
/// Returns negation of dualSphere.
dualSphere negate(const dualSphere &a);
/// Returns negation of line.
line negate(const line &a);
/// Returns negation of sphere.
sphere negate(const sphere &a);
/// Returns negation of rotorE3GA.
rotorE3GA negate(const rotorE3GA &a);
/// Returns negation of oddVersor.
oddVersor negate(const oddVersor &a);
/// Returns negation of evenVersor.
evenVersor negate(const evenVersor &a);
/// Returns negation of pseudoscalar.
pseudoscalar negate(const pseudoscalar &a);
/// Returns negation of e1_t.
vectorE3GA negate(const e1_t &a);
/// Returns negation of e2_t.
vectorE3GA negate(const e2_t &a);
/// Returns negation of noni_t.
flatPoint negate(const noni_t &a);
/// Returns negation of double.
double negate(const double a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns reverse of vectorE3GA.
vectorE3GA reverse(const vectorE3GA &a);
/// Returns reverse of bivectorE3GA.
bivectorE3GA reverse(const bivectorE3GA &a);
/// Returns reverse of normalizedPoint.
normalizedPoint reverse(const normalizedPoint &a);
/// Returns reverse of dualSphere.
dualSphere reverse(const dualSphere &a);
/// Returns reverse of line.
line reverse(const line &a);
/// Returns reverse of circle.
circle reverse(const circle &a);
/// Returns reverse of rotorE3GA.
rotorE3GA reverse(const rotorE3GA &a);
/// Returns reverse of oddVersor.
oddVersor reverse(const oddVersor &a);
/// Returns reverse of evenVersor.
evenVersor reverse(const evenVersor &a);
/// Returns reverse of pseudoscalar.
pseudoscalar reverse(const pseudoscalar &a);
/// Returns reverse of double.
double reverse(const double a);
/// Returns reverse of e1_t.
e1_t reverse(const e1_t &a);
/// Returns reverse of e3_t.
e3_t reverse(const e3_t &a);
/// Returns reverse of I5i_t.
pseudoscalar reverse(const I5i_t &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns Clifford conjugate of vectorE3GA.
vectorE3GA cliffordConjugate(const vectorE3GA &a);
/// Returns Clifford conjugate of pointPair.
pointPair cliffordConjugate(const pointPair &a);
/// Returns Clifford conjugate of normalizedPoint.
dualSphere cliffordConjugate(const normalizedPoint &a);
/// Returns Clifford conjugate of freeVector.
freeVector cliffordConjugate(const freeVector &a);
/// Returns Clifford conjugate of line.
line cliffordConjugate(const line &a);
/// Returns Clifford conjugate of plane.
plane cliffordConjugate(const plane &a);
/// Returns Clifford conjugate of rotorE3GA.
rotorE3GA cliffordConjugate(const rotorE3GA &a);
/// Returns Clifford conjugate of oddVersor.
oddVersor cliffordConjugate(const oddVersor &a);
/// Returns Clifford conjugate of evenVersor.
evenVersor cliffordConjugate(const evenVersor &a);
/// Returns Clifford conjugate of pseudoscalar.
pseudoscalar cliffordConjugate(const pseudoscalar &a);
/// Returns Clifford conjugate of double.
double cliffordConjugate(const double a);
/// Returns Clifford conjugate of e1_t.
vectorE3GA cliffordConjugate(const e1_t &a);
/// Returns Clifford conjugate of noni_t.
flatPoint cliffordConjugate(const noni_t &a);
/// Returns Clifford conjugate of I3_t.
I3_t cliffordConjugate(const I3_t &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns grade involution of vectorE3GA.
vectorE3GA gradeInvolution(const vectorE3GA &a);
/// Returns grade involution of bivectorE3GA.
bivectorE3GA gradeInvolution(const bivectorE3GA &a);
/// Returns grade involution of normalizedPoint.
dualSphere gradeInvolution(const normalizedPoint &a);
/// Returns grade involution of dualSphere.
dualSphere gradeInvolution(const dualSphere &a);
/// Returns grade involution of line.
line gradeInvolution(const line &a);
/// Returns grade involution of plane.
plane gradeInvolution(const plane &a);
/// Returns grade involution of rotorE3GA.
rotorE3GA gradeInvolution(const rotorE3GA &a);
/// Returns grade involution of oddVersor.
oddVersor gradeInvolution(const oddVersor &a);
/// Returns grade involution of evenVersor.
evenVersor gradeInvolution(const evenVersor &a);
/// Returns grade involution of pseudoscalar.
pseudoscalar gradeInvolution(const pseudoscalar &a);
/// Returns grade involution of double.
double gradeInvolution(const double a);
/// Returns grade involution of no_t.
dualSphere gradeInvolution(const no_t &a);
/// Returns grade involution of ni_t.
dualPlane gradeInvolution(const ni_t &a);
/// Returns grade involution of I3_t.
circle gradeInvolution(const I3_t &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns unit of vectorE3GA using default metric.
vectorE3GA unit(const vectorE3GA &a);
/// Returns unit of bivectorE3GA using default metric.
bivectorE3GA unit(const bivectorE3GA &a);
/// Returns unit of line using default metric.
line unit(const line &a);
/// Returns unit of sphere using default metric.
sphere unit(const sphere &a);
/// Returns unit of rotorE3GA using default metric.
rotorE3GA unit(const rotorE3GA &a);
/// Returns unit of oddVersor using default metric.
oddVersor unit(const oddVersor &a);
/// Returns unit of evenVersor using default metric.
evenVersor unit(const evenVersor &a);
/// Returns unit of normalizedPoint using default metric.
dualSphere unit(const normalizedPoint &a);
/// Returns unit of dualSphere using default metric.
dualSphere unit(const dualSphere &a);
/// Returns unit of pseudoscalar using default metric.
pseudoscalar unit(const pseudoscalar &a);
/// Returns unit of pointPair using default metric.
pointPair unit(const pointPair &a);
/// Returns unit of e2_t using default metric.
e2_t unit(const e2_t &a);
/// Returns unit of I5_t using default metric.
I5_t unit(const I5_t &a);
/// Returns unit of mv using euclidean metric.
mv unit_em(const mv &a);
/// Returns unit of vectorE3GA using euclidean metric.
vectorE3GA unit_em(const vectorE3GA &a);
/// Returns unit of bivectorE3GA using euclidean metric.
bivectorE3GA unit_em(const bivectorE3GA &a);
/// Returns unit of circle using euclidean metric.
circle unit_em(const circle &a);
/// Returns unit of plane using euclidean metric.
plane unit_em(const plane &a);
/// Returns unit of rotorE3GA using euclidean metric.
rotorE3GA unit_em(const rotorE3GA &a);
/// Returns unit of oddVersor using euclidean metric.
oddVersor unit_em(const oddVersor &a);
/// Returns unit of evenVersor using euclidean metric.
evenVersor unit_em(const evenVersor &a);
/// Returns unit of pseudoscalar using euclidean metric.
pseudoscalar unit_em(const pseudoscalar &a);
/// Returns evenVersor + evenVersor.
evenVersor add(const evenVersor &a, const evenVersor &b);
/// Returns geometric product of pointPair and pointPair.
evenVersor gp(const pointPair &a, const pointPair &b);
/// Returns evenVersor - evenVersor.
evenVersor subtract(const evenVersor &a, const evenVersor &b);
/// Returns geometric product of evenVersor and pointPair.
evenVersor gp(const evenVersor &a, const pointPair &b);
/// Returns geometric product of evenVersor and evenVersor.
evenVersor gp(const evenVersor &a, const evenVersor &b);
/// Returns double b * pointPair a + double c.
evenVersor sas(const pointPair &a, const double b, const double c);
/// Returns geometric product of evenVersor and double.
evenVersor gp(const evenVersor &a, const double b);
/// Returns geometric product of pointPair and double.
pointPair gp(const pointPair &a, const double b);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns versor inverse of a using euclidean metric.
mv versorInverse_em(const mv &a);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vectorE3GA operator+(const vectorE3GA &a, const vectorE3GA &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline vectorE3GA &operator+=(vectorE3GA &a, const vectorE3GA &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline normalizedPoint operator+(const vectorE3GA &a, const normalizedPoint &b) {
	return add(a, b);
}
/// returns add(a, b)
inline dualSphere operator+(const vectorE3GA &a, const dualSphere &b) {
	return add(a, b);
}
/// returns add(a, b)
inline bivectorE3GA operator+(const bivectorE3GA &a, const bivectorE3GA &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline bivectorE3GA &operator+=(bivectorE3GA &a, const bivectorE3GA &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline plane operator+(const plane &a, const plane &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline plane &operator+=(plane &a, const plane &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline circle operator+(const line &a, const circle &b) {
	return add(a, b);
}
/// returns add(a, b)
inline oddVersor operator+(const circle &a, const vectorE3GA &b) {
	return add(a, b);
}
/// returns add(a, b)
inline vectorE3GA operator+(const e1_t &a, const e2_t &b) {
	return add(a, b);
}
/// returns add(a, b)
inline oddVersor operator+(const I5_t &a, const circle &b) {
	return add(a, b);
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vectorE3GA operator-(const vectorE3GA &a, const vectorE3GA &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vectorE3GA &operator-=(vectorE3GA &a, const vectorE3GA &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivectorE3GA operator-(const bivectorE3GA &a, const bivectorE3GA &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivectorE3GA &operator-=(bivectorE3GA &a, const bivectorE3GA &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline oddVersor operator-(const oddVersor &a, const oddVersor &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline oddVersor &operator-=(oddVersor &a, const oddVersor &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline oddVersor operator-(const line &a, const vectorE3GA &b) {
	return subtract(a, b);
}
/// returns subtract(a, b)
inline rotorE3GA operator-(const rotorE3GA &a, const rotorE3GA &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline rotorE3GA &operator-=(rotorE3GA &a, const rotorE3GA &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline evenVersor operator-(const rotorE3GA &a, const noni_t &b) {
	return subtract(a, b);
}
/// returns subtract(a, b)
inline oddVersor operator-(const I5_t &a, const circle &b) {
	return subtract(a, b);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns dual(a)
inline plane operator*(const vectorE3GA &a) {
	return dual(a);
}
/// returns dual(a)
inline sphere operator*(const normalizedPoint &a) {
	return dual(a);
}
/// returns dual(a)
inline line operator*(const bivectorE3GA &a) {
	return dual(a);
}
/// returns dual(a)
inline oddVersor operator*(const rotorE3GA &a) {
	return dual(a);
}
/// returns dual(a)
inline evenVersor operator*(const oddVersor &a) {
	return dual(a);
}
/// returns dual(a)
inline oddVersor operator*(const evenVersor &a) {
	return dual(a);
}
/// returns dual(a)
inline circle operator*(const pointPair &a) {
	return dual(a);
}
/// returns dual(a)
inline dualPlane operator*(const plane &a) {
	return dual(a);
}
/// returns dual(a)
inline pointPair operator*(const circle &a) {
	return dual(a);
}
/// returns dual(a)
inline plane operator*(const e1_t &a) {
	return dual(a);
}
/// returns dual(a)
inline double operator*(const I5_t &a) {
	return dual(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotorE3GA operator*(const vectorE3GA &a, const vectorE3GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const rotorE3GA &a, const vectorE3GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const circle &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const rotorE3GA &a, const line &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const vectorE3GA &a, const rotorE3GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline rotorE3GA operator*(const rotorE3GA &a, const rotorE3GA &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline rotorE3GA &operator*=(rotorE3GA &a, const rotorE3GA &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline evenVersor operator*(const plane &a, const rotorE3GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const plane &a, const oddVersor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline rotorE3GA operator*(const bivectorE3GA &a, const bivectorE3GA &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const evenVersor &a, const dualSphere &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const normalizedPoint &a, const normalizedPoint &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const flatPoint &a, const oddVersor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline bivectorE3GA operator*(const e1_t &a, const e2_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline freeVector operator*(const e3_t &a, const ni_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline evenVersor operator*(const no_t &a, const ni_t &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline plane operator*(const e3_t &a, const I5i_t &b) {
	return gp(a, b);
}
/// returns (a = increment(a))
inline mv &operator++(mv &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline rotorE3GA operator++(const bivectorE3GA &a) {
	return increment(a);
}
/// returns (a = increment(a))
inline rotorE3GA &operator++(rotorE3GA &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline evenVersor &operator++(evenVersor &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline evenVersor operator++(const pointPair &a) {
	return increment(a);
}
/// returns (a = increment(a))
inline evenVersor operator++(const noni_t &a) {
	return increment(a);
}
/// returns (a = decrement(a))
inline mv &operator--(mv &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline rotorE3GA operator--(const bivectorE3GA &a) {
	return decrement(a);
}
/// returns (a = decrement(a))
inline rotorE3GA &operator--(rotorE3GA &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline evenVersor &operator--(evenVersor &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline evenVersor operator--(const noni_t &a) {
	return decrement(a);
}
/// returns (a = decrement(a))
inline translator operator--(const freeVector &a) {
	return decrement(a);
}
/// returns sp(a, b)
inline mv operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns (a = sp(a, b))
inline mv &operator%=(mv &a, const mv &b) {
	return (a = sp(a, b));
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline mv operator>>(const mv &a, const mv &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline mv &operator>>=(mv &a, const mv &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const vectorE3GA &a, const vectorE3GA &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline line operator<<(const vectorE3GA &a, const plane &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const vectorE3GA &a, const line &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivectorE3GA &a, const oddVersor &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const bivectorE3GA &a, const vectorE3GA &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline oddVersor operator>>(const evenVersor &a, const vectorE3GA &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const vectorE3GA &a, const pseudoscalar &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline oddVersor operator<<(const vectorE3GA &a, const evenVersor &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const vectorE3GA &a, const bivectorE3GA &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const evenVersor &a, const rotorE3GA &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline rotorE3GA operator<<(const evenVersor &a, const rotorE3GA &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline oddVersor operator>>(const oddVersor &a, const rotorE3GA &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline oddVersor &operator>>=(oddVersor &a, const rotorE3GA &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const e1_t &a, const rotorE3GA &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline vectorE3GA operator<<(const e2_t &a, const rotorE3GA &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline oddVersor operator>>(const I5_t &a, const rotorE3GA &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const e1_t &a, const e1_t &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const e2_t &a, const e3_t &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const I5_t &a, const I5i_t &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const rotorE3GA &a, const plane &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline oddVersor operator<<(const rotorE3GA &a, const line &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline rotorE3GA operator>>(const rotorE3GA &a, const evenVersor &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline rotorE3GA &operator>>=(rotorE3GA &a, const evenVersor &b) {
	return (a = rc(a, b));
}
/// returns lc(a, b)
inline double operator<<(const ni_t &a, const normalizedPoint &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const ni_t &a, const normalizedPoint &b) {
	return rc(a, b);
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline bivectorE3GA operator^(const vectorE3GA &a, const vectorE3GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const rotorE3GA &a, const vectorE3GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline plane operator^(const vectorE3GA &a, const line &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const rotorE3GA &a, const circle &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const vectorE3GA &a, const rotorE3GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline rotorE3GA operator^(const rotorE3GA &a, const rotorE3GA &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline rotorE3GA &operator^=(rotorE3GA &a, const rotorE3GA &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline plane operator^(const plane &a, const rotorE3GA &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline plane &operator^=(plane &a, const rotorE3GA &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline pseudoscalar operator^(const circle &a, const pointPair &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivectorE3GA &a, const bivectorE3GA &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const pseudoscalar &a, const oddVersor &b) {
	return op(a, b);
}
/// returns op(a, b)
inline noni_t operator^(const no_t &a, const ni_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline flatPoint operator^(const ni_t &a, const no_t &b) {
	return op(a, b);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const double &b) {
	return (a = gp(a, b));
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns negate(a)
inline vectorE3GA operator-(const vectorE3GA &a) {
	return negate(a);
}
/// returns negate(a)
inline freeVector operator-(const freeVector &a) {
	return negate(a);
}
/// returns negate(a)
inline dualSphere operator-(const normalizedPoint &a) {
	return negate(a);
}
/// returns negate(a)
inline dualSphere operator-(const dualSphere &a) {
	return negate(a);
}
/// returns negate(a)
inline line operator-(const line &a) {
	return negate(a);
}
/// returns negate(a)
inline sphere operator-(const sphere &a) {
	return negate(a);
}
/// returns negate(a)
inline rotorE3GA operator-(const rotorE3GA &a) {
	return negate(a);
}
/// returns negate(a)
inline oddVersor operator-(const oddVersor &a) {
	return negate(a);
}
/// returns negate(a)
inline evenVersor operator-(const evenVersor &a) {
	return negate(a);
}
/// returns negate(a)
inline pseudoscalar operator-(const pseudoscalar &a) {
	return negate(a);
}
/// returns negate(a)
inline vectorE3GA operator-(const e1_t &a) {
	return negate(a);
}
/// returns negate(a)
inline vectorE3GA operator-(const e2_t &a) {
	return negate(a);
}
/// returns negate(a)
inline flatPoint operator-(const noni_t &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns reverse(a)
inline vectorE3GA operator~(const vectorE3GA &a) {
	return reverse(a);
}
/// returns reverse(a)
inline bivectorE3GA operator~(const bivectorE3GA &a) {
	return reverse(a);
}
/// returns reverse(a)
inline normalizedPoint operator~(const normalizedPoint &a) {
	return reverse(a);
}
/// returns reverse(a)
inline dualSphere operator~(const dualSphere &a) {
	return reverse(a);
}
/// returns reverse(a)
inline line operator~(const line &a) {
	return reverse(a);
}
/// returns reverse(a)
inline circle operator~(const circle &a) {
	return reverse(a);
}
/// returns reverse(a)
inline rotorE3GA operator~(const rotorE3GA &a) {
	return reverse(a);
}
/// returns reverse(a)
inline oddVersor operator~(const oddVersor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline evenVersor operator~(const evenVersor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline pseudoscalar operator~(const pseudoscalar &a) {
	return reverse(a);
}
/// returns reverse(a)
inline e1_t operator~(const e1_t &a) {
	return reverse(a);
}
/// returns reverse(a)
inline e3_t operator~(const e3_t &a) {
	return reverse(a);
}
/// returns reverse(a)
inline pseudoscalar operator~(const I5i_t &a) {
	return reverse(a);
}
/// returns add(a, b)
inline evenVersor operator+(const evenVersor &a, const evenVersor &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline evenVersor &operator+=(evenVersor &a, const evenVersor &b) {
	return (a = add(a, b));
}
/// returns gp(a, b)
inline evenVersor operator*(const pointPair &a, const pointPair &b) {
	return gp(a, b);
}
/// returns subtract(a, b)
inline evenVersor operator-(const evenVersor &a, const evenVersor &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline evenVersor &operator-=(evenVersor &a, const evenVersor &b) {
	return (a = subtract(a, b));
}
/// returns gp(a, b)
inline evenVersor operator*(const evenVersor &a, const pointPair &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline evenVersor &operator*=(evenVersor &a, const pointPair &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline evenVersor operator*(const evenVersor &a, const evenVersor &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline evenVersor &operator*=(evenVersor &a, const evenVersor &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline evenVersor operator*(const evenVersor &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline evenVersor &operator*=(evenVersor &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline pointPair operator*(const pointPair &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline pointPair &operator*=(pointPair &a, const double &b) {
	return (a = gp(a, b));
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
}
inline void mv::set(double val) {
	setGroupUsage(1);
	m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
	setGroupUsage(gu);
	c3ga::copy_N(m_c, arr, c3ga_mvSize[gu]);

}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const double*srcC = src.getC();
	c3ga::copy_N(m_c, srcC, c3ga_mvSize[src.gu()]);

}
inline void no_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e1_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void ni_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void noni_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
	}
	else {
	}
}
inline void I3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
	}
	else {
	}
}
inline void I5_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		ptr += 5;
	}
	if (src.gu() & 32) {
	}
	else {
	}
}
inline void I5i_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		ptr += 5;
	}
	if (src.gu() & 32) {
	}
	else {
	}
}
inline void vectorE3GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_e3 = ptr[3];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
	}
}
inline void bivectorE3GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[2];
		m_e2_e3 = ptr[5];
		m_e3_e1 = -ptr[4];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void rotorE3GA::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[2];
		m_e2_e3 = ptr[5];
		m_e3_e1 = -ptr[4];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void normalizedPoint::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_e3 = ptr[3];
		m_ni = ptr[4];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_ni = 0.0;
	}
}
inline void dualSphere::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_no = ptr[0];
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_e3 = ptr[3];
		m_ni = ptr[4];
	}
	else {
		m_no = 0.0;
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_ni = 0.0;
	}
}
inline void dualPlane::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_e3 = ptr[3];
		m_ni = ptr[4];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_ni = 0.0;
	}
}
inline void freeVector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
	}
}
inline void freeBivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_e1_e2_ni = ptr[6];
		m_e2_e3_ni = ptr[9];
		m_e3_e1_ni = -ptr[8];
	}
	else {
		m_e1_e2_ni = 0.0;
		m_e2_e3_ni = 0.0;
		m_e3_e1_ni = 0.0;
	}
}
inline void flatPoint::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
		m_no_ni = ptr[6];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
		m_no_ni = 0.0;
	}
}
inline void pointPair::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_no_e1 = ptr[0];
		m_no_e2 = ptr[1];
		m_no_e3 = ptr[3];
		m_e1_e2 = ptr[2];
		m_e2_e3 = ptr[5];
		m_e3_e1 = -ptr[4];
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
		m_no_ni = ptr[6];
	}
	else {
		m_no_e1 = 0.0;
		m_no_e2 = 0.0;
		m_no_e3 = 0.0;
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
		m_no_ni = 0.0;
	}
}
inline void line::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_e1_e2_ni = ptr[6];
		m_e1_e3_ni = ptr[8];
		m_e2_e3_ni = ptr[9];
		m_e1_no_ni = -ptr[4];
		m_e2_no_ni = -ptr[5];
		m_e3_no_ni = -ptr[7];
	}
	else {
		m_e1_e2_ni = 0.0;
		m_e1_e3_ni = 0.0;
		m_e2_e3_ni = 0.0;
		m_e1_no_ni = 0.0;
		m_e2_no_ni = 0.0;
		m_e3_no_ni = 0.0;
	}
}
inline void circle::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_no_e1_e2 = ptr[0];
		m_no_e1_e3 = ptr[1];
		m_no_e2_e3 = ptr[2];
		m_e1_e2_e3 = ptr[3];
		m_no_e1_ni = ptr[4];
		m_no_e2_ni = ptr[5];
		m_e1_e2_ni = ptr[6];
		m_no_e3_ni = ptr[7];
		m_e1_e3_ni = ptr[8];
		m_e2_e3_ni = ptr[9];
	}
	else {
		m_no_e1_e2 = 0.0;
		m_no_e1_e3 = 0.0;
		m_no_e2_e3 = 0.0;
		m_e1_e2_e3 = 0.0;
		m_no_e1_ni = 0.0;
		m_no_e2_ni = 0.0;
		m_e1_e2_ni = 0.0;
		m_no_e3_ni = 0.0;
		m_e1_e3_ni = 0.0;
		m_e2_e3_ni = 0.0;
	}
}
inline void sphere::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		m_e1_e2_e3_ni = ptr[4];
		m_no_e2_e3_ni = ptr[3];
		m_no_e1_e3_ni = ptr[2];
		m_no_e1_e2_ni = ptr[1];
		m_no_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e3_ni = 0.0;
		m_no_e2_e3_ni = 0.0;
		m_no_e1_e3_ni = 0.0;
		m_no_e1_e2_ni = 0.0;
		m_no_e1_e2_e3 = 0.0;
	}
}
inline void plane::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		m_e1_e2_e3_ni = ptr[4];
		m_no_e2_e3_ni = ptr[3];
		m_no_e1_e3_ni = ptr[2];
		m_no_e1_e2_ni = ptr[1];
	}
	else {
		m_e1_e2_e3_ni = 0.0;
		m_no_e2_e3_ni = 0.0;
		m_no_e1_e3_ni = 0.0;
		m_no_e1_e2_ni = 0.0;
	}
}
inline void pseudoscalar::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		ptr += 5;
	}
	if (src.gu() & 32) {
		m_no_e1_e2_e3_ni = ptr[0];
	}
	else {
		m_no_e1_e2_e3_ni = 0.0;
	}
}
inline void normalizedTranslator::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	else {
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
	}
}
inline void translator::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
	}
	else {
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
	}
}
inline void RBM::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[2];
		m_e2_e3 = ptr[5];
		m_e3_e1 = -ptr[4];
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
		ptr += 10;
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		m_e1_e2_e3_ni = ptr[4];
	}
	else {
		m_e1_e2_e3_ni = 0.0;
	}
}
inline void evenVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 5;
	}
	if (src.gu() & 4) {
		m_no_e1 = ptr[0];
		m_no_e2 = ptr[1];
		m_no_e3 = ptr[3];
		m_e1_e2 = ptr[2];
		m_e2_e3 = ptr[5];
		m_e3_e1 = -ptr[4];
		m_e1_ni = ptr[7];
		m_e2_ni = ptr[8];
		m_e3_ni = ptr[9];
		m_no_ni = ptr[6];
		ptr += 10;
	}
	else {
		m_no_e1 = 0.0;
		m_no_e2 = 0.0;
		m_no_e3 = 0.0;
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
		m_e1_ni = 0.0;
		m_e2_ni = 0.0;
		m_e3_ni = 0.0;
		m_no_ni = 0.0;
	}
	if (src.gu() & 8) {
		ptr += 10;
	}
	if (src.gu() & 16) {
		m_e1_e2_e3_ni = ptr[4];
		m_no_e2_e3_ni = ptr[3];
		m_no_e1_e3_ni = ptr[2];
		m_no_e1_e2_ni = ptr[1];
		m_no_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e3_ni = 0.0;
		m_no_e2_e3_ni = 0.0;
		m_no_e1_e3_ni = 0.0;
		m_no_e1_e2_ni = 0.0;
		m_no_e1_e2_e3 = 0.0;
	}
}
inline void oddVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_no = ptr[0];
		m_e1 = ptr[1];
		m_e2 = ptr[2];
		m_e3 = ptr[3];
		m_ni = ptr[4];
		ptr += 5;
	}
	else {
		m_no = 0.0;
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
		m_ni = 0.0;
	}
	if (src.gu() & 4) {
		ptr += 10;
	}
	if (src.gu() & 8) {
		m_no_e1_e2 = ptr[0];
		m_no_e1_e3 = ptr[1];
		m_no_e2_e3 = ptr[2];
		m_e1_e2_e3 = ptr[3];
		m_no_e1_ni = ptr[4];
		m_no_e2_ni = ptr[5];
		m_e1_e2_ni = ptr[6];
		m_no_e3_ni = ptr[7];
		m_e1_e3_ni = ptr[8];
		m_e2_e3_ni = ptr[9];
		ptr += 10;
	}
	else {
		m_no_e1_e2 = 0.0;
		m_no_e1_e3 = 0.0;
		m_no_e2_e3 = 0.0;
		m_e1_e2_e3 = 0.0;
		m_no_e1_ni = 0.0;
		m_no_e2_ni = 0.0;
		m_e1_e2_ni = 0.0;
		m_no_e3_ni = 0.0;
		m_e1_e3_ni = 0.0;
		m_e2_e3_ni = 0.0;
	}
	if (src.gu() & 16) {
		ptr += 5;
	}
	if (src.gu() & 32) {
		m_no_e1_e2_e3_ni = ptr[0];
	}
	else {
		m_no_e1_e2_e3_ni = 0.0;
	}
}
inline void mv::set(const no_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = ptr[2] = ptr[3] = ptr[4] = 0.0;
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = ptr[4] = 0.0;
	ptr[1] = 1.0;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[4] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const e3_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[4] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const ni_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = 1.0;
}
inline void mv::set(const noni_t &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[7] = ptr[8] = ptr[9] = 0.0;
	ptr[6] = 1.0;
}
inline void mv::set(const I3_t &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[4] = ptr[5] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const I5_t &src) {
	setGroupUsage(32);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const I5i_t &src) {
	setGroupUsage(32);
	double *ptr = m_c;
	ptr[0] = -1.0;
}
inline void mv::set(const vectorE3GA &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[4] = 0.0;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_e3;
}
inline void mv::set(const bivectorE3GA &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0;
	ptr[2] = src.m_e1_e2;
	ptr[4] = -src.m_e3_e1;
	ptr[5] = src.m_e2_e3;
}
inline void mv::set(const rotorE3GA &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[3] = ptr[6] = ptr[7] = ptr[8] = ptr[9] = 0.0;
	ptr[2] = src.m_e1_e2;
	ptr[4] = -src.m_e3_e1;
	ptr[5] = src.m_e2_e3;
}
inline void mv::set(const normalizedPoint &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_e3;
	ptr[4] = src.m_ni;
}
inline void mv::set(const dualSphere &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_no;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_e3;
	ptr[4] = src.m_ni;
}
inline void mv::set(const dualPlane &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 0.0;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_e3;
	ptr[4] = src.m_ni;
}
inline void mv::set(const freeVector &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = 0.0;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
}
inline void mv::set(const freeBivector &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[7] = 0.0;
	ptr[6] = src.m_e1_e2_ni;
	ptr[8] = -src.m_e3_e1_ni;
	ptr[9] = src.m_e2_e3_ni;
}
inline void mv::set(const flatPoint &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
	ptr[6] = src.m_no_ni;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
}
inline void mv::set(const pointPair &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1;
	ptr[1] = src.m_no_e2;
	ptr[2] = src.m_e1_e2;
	ptr[3] = src.m_no_e3;
	ptr[4] = -src.m_e3_e1;
	ptr[5] = src.m_e2_e3;
	ptr[6] = src.m_no_ni;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
}
inline void mv::set(const line &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = -src.m_e1_no_ni;
	ptr[5] = -src.m_e2_no_ni;
	ptr[6] = src.m_e1_e2_ni;
	ptr[7] = -src.m_e3_no_ni;
	ptr[8] = src.m_e1_e3_ni;
	ptr[9] = src.m_e2_e3_ni;
}
inline void mv::set(const circle &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1_e2;
	ptr[1] = src.m_no_e1_e3;
	ptr[2] = src.m_no_e2_e3;
	ptr[3] = src.m_e1_e2_e3;
	ptr[4] = src.m_no_e1_ni;
	ptr[5] = src.m_no_e2_ni;
	ptr[6] = src.m_e1_e2_ni;
	ptr[7] = src.m_no_e3_ni;
	ptr[8] = src.m_e1_e3_ni;
	ptr[9] = src.m_e2_e3_ni;
}
inline void mv::set(const sphere &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1_e2_e3;
	ptr[1] = src.m_no_e1_e2_ni;
	ptr[2] = src.m_no_e1_e3_ni;
	ptr[3] = src.m_no_e2_e3_ni;
	ptr[4] = src.m_e1_e2_e3_ni;
}
inline void mv::set(const plane &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = 0.0;
	ptr[1] = src.m_no_e1_e2_ni;
	ptr[2] = src.m_no_e1_e3_ni;
	ptr[3] = src.m_no_e2_e3_ni;
	ptr[4] = src.m_e1_e2_e3_ni;
}
inline void mv::set(const pseudoscalar &src) {
	setGroupUsage(32);
	double *ptr = m_c;
	ptr[0] = src.m_no_e1_e2_e3_ni;
}
inline void mv::set(const normalizedTranslator &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = 0.0;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
}
inline void mv::set(const translator &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = ptr[6] = 0.0;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
}
inline void mv::set(const RBM &src) {
	setGroupUsage(21);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = ptr[1] = ptr[3] = ptr[6] = 0.0;
	ptr[2] = src.m_e1_e2;
	ptr[4] = -src.m_e3_e1;
	ptr[5] = src.m_e2_e3;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
	ptr += 10;
	ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
	ptr[4] = src.m_e1_e2_e3_ni;
}
inline void mv::set(const evenVersor &src) {
	setGroupUsage(21);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = src.m_no_e1;
	ptr[1] = src.m_no_e2;
	ptr[2] = src.m_e1_e2;
	ptr[3] = src.m_no_e3;
	ptr[4] = -src.m_e3_e1;
	ptr[5] = src.m_e2_e3;
	ptr[6] = src.m_no_ni;
	ptr[7] = src.m_e1_ni;
	ptr[8] = src.m_e2_ni;
	ptr[9] = src.m_e3_ni;
	ptr += 10;
	ptr[0] = src.m_no_e1_e2_e3;
	ptr[1] = src.m_no_e1_e2_ni;
	ptr[2] = src.m_no_e1_e3_ni;
	ptr[3] = src.m_no_e2_e3_ni;
	ptr[4] = src.m_e1_e2_e3_ni;
}
inline void mv::set(const oddVersor &src) {
	setGroupUsage(42);
	double *ptr = m_c;
	ptr[0] = src.m_no;
	ptr[1] = src.m_e1;
	ptr[2] = src.m_e2;
	ptr[3] = src.m_e3;
	ptr[4] = src.m_ni;
	ptr += 5;
	ptr[0] = src.m_no_e1_e2;
	ptr[1] = src.m_no_e1_e3;
	ptr[2] = src.m_no_e2_e3;
	ptr[3] = src.m_e1_e2_e3;
	ptr[4] = src.m_no_e1_ni;
	ptr[5] = src.m_no_e2_ni;
	ptr[6] = src.m_e1_e2_ni;
	ptr[7] = src.m_no_e3_ni;
	ptr[8] = src.m_e1_e3_ni;
	ptr[9] = src.m_e2_e3_ni;
	ptr += 10;
	ptr[0] = src.m_no_e1_e2_e3_ni;
}

inline double _double(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void vectorE3GA::set()
{
	m_e1 = m_e2 = m_e3 = 0.0;

}
inline void bivectorE3GA::set()
{
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void rotorE3GA::set()
{
	m_scalar = m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void normalizedPoint::set()
{
	m_e1 = m_e2 = m_e3 = m_ni = 0.0;

}
inline void dualSphere::set()
{
	m_no = m_e1 = m_e2 = m_e3 = m_ni = 0.0;

}
inline void dualPlane::set()
{
	m_e1 = m_e2 = m_e3 = m_ni = 0.0;

}
inline void freeVector::set()
{
	m_e1_ni = m_e2_ni = m_e3_ni = 0.0;

}
inline void freeBivector::set()
{
	m_e1_e2_ni = m_e2_e3_ni = m_e3_e1_ni = 0.0;

}
inline void flatPoint::set()
{
	m_e1_ni = m_e2_ni = m_e3_ni = m_no_ni = 0.0;

}
inline void pointPair::set()
{
	m_no_e1 = m_no_e2 = m_no_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e1_ni = m_e2_ni = m_e3_ni = m_no_ni = 0.0;

}
inline void line::set()
{
	m_e1_e2_ni = m_e1_e3_ni = m_e2_e3_ni = m_e1_no_ni = m_e2_no_ni = m_e3_no_ni = 0.0;

}
inline void circle::set()
{
	m_no_e1_e2 = m_no_e1_e3 = m_no_e2_e3 = m_e1_e2_e3 = m_no_e1_ni = m_no_e2_ni = m_e1_e2_ni = m_no_e3_ni = m_e1_e3_ni = m_e2_e3_ni = 0.0;

}
inline void sphere::set()
{
	m_e1_e2_e3_ni = m_no_e2_e3_ni = m_no_e1_e3_ni = m_no_e1_e2_ni = m_no_e1_e2_e3 = 0.0;

}
inline void plane::set()
{
	m_e1_e2_e3_ni = m_no_e2_e3_ni = m_no_e1_e3_ni = m_no_e1_e2_ni = 0.0;

}
inline void pseudoscalar::set()
{
	m_no_e1_e2_e3_ni = 0.0;

}
inline void normalizedTranslator::set()
{
	m_e1_ni = m_e2_ni = m_e3_ni = 0.0;

}
inline void translator::set()
{
	m_scalar = m_e1_ni = m_e2_ni = m_e3_ni = 0.0;

}
inline void RBM::set()
{
	m_scalar = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e1_ni = m_e2_ni = m_e3_ni = m_e1_e2_e3_ni = 0.0;

}
inline void evenVersor::set()
{
	m_scalar = m_no_e1 = m_no_e2 = m_no_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e1_ni = m_e2_ni = m_e3_ni = m_no_ni = m_e1_e2_e3_ni = m_no_e2_e3_ni = m_no_e1_e3_ni = m_no_e1_e2_ni = m_no_e1_e2_e3 = 0.0;

}
inline void oddVersor::set()
{
	m_no = m_e1 = m_e2 = m_e3 = m_ni = m_no_e1_e2 = m_no_e1_e3 = m_no_e2_e3 = m_e1_e2_e3 = m_no_e1_ni = m_no_e2_ni = m_e1_e2_ni = m_no_e3_ni = m_e1_e3_ni = m_e2_e3_ni = m_no_e1_e2_e3_ni = 0.0;

}

inline void rotorE3GA::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void normalizedTranslator::set(const double scalarVal)
{
	m_e1_ni = m_e2_ni = m_e3_ni = 0.0;

}
inline void translator::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_ni = m_e2_ni = m_e3_ni = 0.0;

}
inline void RBM::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e1_ni = m_e2_ni = m_e3_ni = m_e1_e2_e3_ni = 0.0;

}
inline void evenVersor::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_no_e1 = m_no_e2 = m_no_e3 = m_e1_e2 = m_e2_e3 = m_e3_e1 = m_e1_ni = m_e2_ni = m_e3_ni = m_no_ni = m_e1_e2_e3_ni = m_no_e2_e3_ni = m_no_e1_e3_ni = m_no_e1_e2_ni = m_no_e1_e2_e3 = 0.0;

}

inline void vectorE3GA::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;

}
inline void bivectorE3GA::set(const CoordinateOrder co, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void rotorE3GA::set(const CoordinateOrder co, const double _scalar, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_scalar = _scalar;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void normalizedPoint::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3, const double _ni)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_ni = _ni;

}
inline void dualSphere::set(const CoordinateOrder co, const double _no, const double _e1, const double _e2, const double _e3, const double _ni)
{
	m_no = _no;
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_ni = _ni;

}
inline void dualPlane::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3, const double _ni)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_ni = _ni;

}
inline void freeVector::set(const CoordinateOrder co, const double _e1_ni, const double _e2_ni, const double _e3_ni)
{
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;

}
inline void freeBivector::set(const CoordinateOrder co, const double _e1_e2_ni, const double _e2_e3_ni, const double _e3_e1_ni)
{
	m_e1_e2_ni = _e1_e2_ni;
	m_e2_e3_ni = _e2_e3_ni;
	m_e3_e1_ni = _e3_e1_ni;

}
inline void flatPoint::set(const CoordinateOrder co, const double _e1_ni, const double _e2_ni, const double _e3_ni, const double _no_ni)
{
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;
	m_no_ni = _no_ni;

}
inline void pointPair::set(const CoordinateOrder co, const double _no_e1, const double _no_e2, const double _no_e3, const double _e1_e2, const double _e2_e3, const double _e3_e1, const double _e1_ni, const double _e2_ni, const double _e3_ni, const double _no_ni)
{
	m_no_e1 = _no_e1;
	m_no_e2 = _no_e2;
	m_no_e3 = _no_e3;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;
	m_no_ni = _no_ni;

}
inline void line::set(const CoordinateOrder co, const double _e1_e2_ni, const double _e1_e3_ni, const double _e2_e3_ni, const double _e1_no_ni, const double _e2_no_ni, const double _e3_no_ni)
{
	m_e1_e2_ni = _e1_e2_ni;
	m_e1_e3_ni = _e1_e3_ni;
	m_e2_e3_ni = _e2_e3_ni;
	m_e1_no_ni = _e1_no_ni;
	m_e2_no_ni = _e2_no_ni;
	m_e3_no_ni = _e3_no_ni;

}
inline void circle::set(const CoordinateOrder co, const double _no_e1_e2, const double _no_e1_e3, const double _no_e2_e3, const double _e1_e2_e3, const double _no_e1_ni, const double _no_e2_ni, const double _e1_e2_ni, const double _no_e3_ni, const double _e1_e3_ni, const double _e2_e3_ni)
{
	m_no_e1_e2 = _no_e1_e2;
	m_no_e1_e3 = _no_e1_e3;
	m_no_e2_e3 = _no_e2_e3;
	m_e1_e2_e3 = _e1_e2_e3;
	m_no_e1_ni = _no_e1_ni;
	m_no_e2_ni = _no_e2_ni;
	m_e1_e2_ni = _e1_e2_ni;
	m_no_e3_ni = _no_e3_ni;
	m_e1_e3_ni = _e1_e3_ni;
	m_e2_e3_ni = _e2_e3_ni;

}
inline void sphere::set(const CoordinateOrder co, const double _e1_e2_e3_ni, const double _no_e2_e3_ni, const double _no_e1_e3_ni, const double _no_e1_e2_ni, const double _no_e1_e2_e3)
{
	m_e1_e2_e3_ni = _e1_e2_e3_ni;
	m_no_e2_e3_ni = _no_e2_e3_ni;
	m_no_e1_e3_ni = _no_e1_e3_ni;
	m_no_e1_e2_ni = _no_e1_e2_ni;
	m_no_e1_e2_e3 = _no_e1_e2_e3;

}
inline void plane::set(const CoordinateOrder co, const double _e1_e2_e3_ni, const double _no_e2_e3_ni, const double _no_e1_e3_ni, const double _no_e1_e2_ni)
{
	m_e1_e2_e3_ni = _e1_e2_e3_ni;
	m_no_e2_e3_ni = _no_e2_e3_ni;
	m_no_e1_e3_ni = _no_e1_e3_ni;
	m_no_e1_e2_ni = _no_e1_e2_ni;

}
inline void pseudoscalar::set(const CoordinateOrder co, const double _no_e1_e2_e3_ni)
{
	m_no_e1_e2_e3_ni = _no_e1_e2_e3_ni;

}
inline void normalizedTranslator::set(const CoordinateOrder co, const double _e1_ni, const double _e2_ni, const double _e3_ni)
{
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;

}
inline void translator::set(const CoordinateOrder co, const double _scalar, const double _e1_ni, const double _e2_ni, const double _e3_ni)
{
	m_scalar = _scalar;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;

}
inline void RBM::set(const CoordinateOrder co, const double _scalar, const double _e1_e2, const double _e2_e3, const double _e3_e1, const double _e1_ni, const double _e2_ni, const double _e3_ni, const double _e1_e2_e3_ni)
{
	m_scalar = _scalar;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;
	m_e1_e2_e3_ni = _e1_e2_e3_ni;

}
inline void evenVersor::set(const CoordinateOrder co, const double _scalar, const double _no_e1, const double _no_e2, const double _no_e3, const double _e1_e2, const double _e2_e3, const double _e3_e1, const double _e1_ni, const double _e2_ni, const double _e3_ni, const double _no_ni, const double _e1_e2_e3_ni, const double _no_e2_e3_ni, const double _no_e1_e3_ni, const double _no_e1_e2_ni, const double _no_e1_e2_e3)
{
	m_scalar = _scalar;
	m_no_e1 = _no_e1;
	m_no_e2 = _no_e2;
	m_no_e3 = _no_e3;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;
	m_e1_ni = _e1_ni;
	m_e2_ni = _e2_ni;
	m_e3_ni = _e3_ni;
	m_no_ni = _no_ni;
	m_e1_e2_e3_ni = _e1_e2_e3_ni;
	m_no_e2_e3_ni = _no_e2_e3_ni;
	m_no_e1_e3_ni = _no_e1_e3_ni;
	m_no_e1_e2_ni = _no_e1_e2_ni;
	m_no_e1_e2_e3 = _no_e1_e2_e3;

}
inline void oddVersor::set(const CoordinateOrder co, const double _no, const double _e1, const double _e2, const double _e3, const double _ni, const double _no_e1_e2, const double _no_e1_e3, const double _no_e2_e3, const double _e1_e2_e3, const double _no_e1_ni, const double _no_e2_ni, const double _e1_e2_ni, const double _no_e3_ni, const double _e1_e3_ni, const double _e2_e3_ni, const double _no_e1_e2_e3_ni)
{
	m_no = _no;
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_ni = _ni;
	m_no_e1_e2 = _no_e1_e2;
	m_no_e1_e3 = _no_e1_e3;
	m_no_e2_e3 = _no_e2_e3;
	m_e1_e2_e3 = _e1_e2_e3;
	m_no_e1_ni = _no_e1_ni;
	m_no_e2_ni = _no_e2_ni;
	m_e1_e2_ni = _e1_e2_ni;
	m_no_e3_ni = _no_e3_ni;
	m_e1_e3_ni = _e1_e3_ni;
	m_e2_e3_ni = _e2_e3_ni;
	m_no_e1_e2_e3_ni = _no_e1_e2_e3_ni;

}

inline void vectorE3GA::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];

}
inline void bivectorE3GA::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2 = A[0];
	m_e2_e3 = A[1];
	m_e3_e1 = A[2];

}
inline void rotorE3GA::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_e2 = A[1];
	m_e2_e3 = A[2];
	m_e3_e1 = A[3];

}
inline void normalizedPoint::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];
	m_ni = A[3];

}
inline void dualSphere::set(const CoordinateOrder co, const double *A)
{
	m_no = A[0];
	m_e1 = A[1];
	m_e2 = A[2];
	m_e3 = A[3];
	m_ni = A[4];

}
inline void dualPlane::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];
	m_ni = A[3];

}
inline void freeVector::set(const CoordinateOrder co, const double *A)
{
	m_e1_ni = A[0];
	m_e2_ni = A[1];
	m_e3_ni = A[2];

}
inline void freeBivector::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_ni = A[0];
	m_e2_e3_ni = A[1];
	m_e3_e1_ni = A[2];

}
inline void flatPoint::set(const CoordinateOrder co, const double *A)
{
	m_e1_ni = A[0];
	m_e2_ni = A[1];
	m_e3_ni = A[2];
	m_no_ni = A[3];

}
inline void pointPair::set(const CoordinateOrder co, const double *A)
{
	m_no_e1 = A[0];
	m_no_e2 = A[1];
	m_no_e3 = A[2];
	m_e1_e2 = A[3];
	m_e2_e3 = A[4];
	m_e3_e1 = A[5];
	m_e1_ni = A[6];
	m_e2_ni = A[7];
	m_e3_ni = A[8];
	m_no_ni = A[9];

}
inline void line::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_ni = A[0];
	m_e1_e3_ni = A[1];
	m_e2_e3_ni = A[2];
	m_e1_no_ni = A[3];
	m_e2_no_ni = A[4];
	m_e3_no_ni = A[5];

}
inline void circle::set(const CoordinateOrder co, const double *A)
{
	m_no_e1_e2 = A[0];
	m_no_e1_e3 = A[1];
	m_no_e2_e3 = A[2];
	m_e1_e2_e3 = A[3];
	m_no_e1_ni = A[4];
	m_no_e2_ni = A[5];
	m_e1_e2_ni = A[6];
	m_no_e3_ni = A[7];
	m_e1_e3_ni = A[8];
	m_e2_e3_ni = A[9];

}
inline void sphere::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_e3_ni = A[0];
	m_no_e2_e3_ni = A[1];
	m_no_e1_e3_ni = A[2];
	m_no_e1_e2_ni = A[3];
	m_no_e1_e2_e3 = A[4];

}
inline void plane::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_e3_ni = A[0];
	m_no_e2_e3_ni = A[1];
	m_no_e1_e3_ni = A[2];
	m_no_e1_e2_ni = A[3];

}
inline void pseudoscalar::set(const CoordinateOrder co, const double *A)
{
	m_no_e1_e2_e3_ni = A[0];

}
inline void normalizedTranslator::set(const CoordinateOrder co, const double *A)
{
	m_e1_ni = A[0];
	m_e2_ni = A[1];
	m_e3_ni = A[2];

}
inline void translator::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_ni = A[1];
	m_e2_ni = A[2];
	m_e3_ni = A[3];

}
inline void RBM::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_e2 = A[1];
	m_e2_e3 = A[2];
	m_e3_e1 = A[3];
	m_e1_ni = A[4];
	m_e2_ni = A[5];
	m_e3_ni = A[6];
	m_e1_e2_e3_ni = A[7];

}
inline void evenVersor::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_no_e1 = A[1];
	m_no_e2 = A[2];
	m_no_e3 = A[3];
	m_e1_e2 = A[4];
	m_e2_e3 = A[5];
	m_e3_e1 = A[6];
	m_e1_ni = A[7];
	m_e2_ni = A[8];
	m_e3_ni = A[9];
	m_no_ni = A[10];
	m_e1_e2_e3_ni = A[11];
	m_no_e2_e3_ni = A[12];
	m_no_e1_e3_ni = A[13];
	m_no_e1_e2_ni = A[14];
	m_no_e1_e2_e3 = A[15];

}
inline void oddVersor::set(const CoordinateOrder co, const double *A)
{
	m_no = A[0];
	m_e1 = A[1];
	m_e2 = A[2];
	m_e3 = A[3];
	m_ni = A[4];
	m_no_e1_e2 = A[5];
	m_no_e1_e3 = A[6];
	m_no_e2_e3 = A[7];
	m_e1_e2_e3 = A[8];
	m_no_e1_ni = A[9];
	m_no_e2_ni = A[10];
	m_e1_e2_ni = A[11];
	m_no_e3_ni = A[12];
	m_e1_e3_ni = A[13];
	m_e2_e3_ni = A[14];
	m_no_e1_e2_e3_ni = A[15];

}

inline void no_t::set(const no_t &a)
{

}
inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void e3_t::set(const e3_t &a)
{

}
inline void ni_t::set(const ni_t &a)
{

}
inline void noni_t::set(const noni_t &a)
{

}
inline void I3_t::set(const I3_t &a)
{

}
inline void I5_t::set(const I5_t &a)
{

}
inline void I5i_t::set(const I5i_t &a)
{

}
inline void vectorE3GA::set(const vectorE3GA &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;

}
inline void bivectorE3GA::set(const bivectorE3GA &a)
{
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void rotorE3GA::set(const rotorE3GA &a)
{
	m_scalar = a.m_scalar;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void normalizedPoint::set(const normalizedPoint &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_ni = a.m_ni;

}
inline void dualSphere::set(const dualSphere &a)
{
	m_no = a.m_no;
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_ni = a.m_ni;

}
inline void dualPlane::set(const dualPlane &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_ni = a.m_ni;

}
inline void freeVector::set(const freeVector &a)
{
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;

}
inline void freeBivector::set(const freeBivector &a)
{
	m_e1_e2_ni = a.m_e1_e2_ni;
	m_e2_e3_ni = a.m_e2_e3_ni;
	m_e3_e1_ni = a.m_e3_e1_ni;

}
inline void flatPoint::set(const flatPoint &a)
{
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;
	m_no_ni = a.m_no_ni;

}
inline void pointPair::set(const pointPair &a)
{
	m_no_e1 = a.m_no_e1;
	m_no_e2 = a.m_no_e2;
	m_no_e3 = a.m_no_e3;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;
	m_no_ni = a.m_no_ni;

}
inline void line::set(const line &a)
{
	m_e1_e2_ni = a.m_e1_e2_ni;
	m_e1_e3_ni = a.m_e1_e3_ni;
	m_e2_e3_ni = a.m_e2_e3_ni;
	m_e1_no_ni = a.m_e1_no_ni;
	m_e2_no_ni = a.m_e2_no_ni;
	m_e3_no_ni = a.m_e3_no_ni;

}
inline void circle::set(const circle &a)
{
	m_no_e1_e2 = a.m_no_e1_e2;
	m_no_e1_e3 = a.m_no_e1_e3;
	m_no_e2_e3 = a.m_no_e2_e3;
	m_e1_e2_e3 = a.m_e1_e2_e3;
	m_no_e1_ni = a.m_no_e1_ni;
	m_no_e2_ni = a.m_no_e2_ni;
	m_e1_e2_ni = a.m_e1_e2_ni;
	m_no_e3_ni = a.m_no_e3_ni;
	m_e1_e3_ni = a.m_e1_e3_ni;
	m_e2_e3_ni = a.m_e2_e3_ni;

}
inline void sphere::set(const sphere &a)
{
	m_e1_e2_e3_ni = a.m_e1_e2_e3_ni;
	m_no_e2_e3_ni = a.m_no_e2_e3_ni;
	m_no_e1_e3_ni = a.m_no_e1_e3_ni;
	m_no_e1_e2_ni = a.m_no_e1_e2_ni;
	m_no_e1_e2_e3 = a.m_no_e1_e2_e3;

}
inline void plane::set(const plane &a)
{
	m_e1_e2_e3_ni = a.m_e1_e2_e3_ni;
	m_no_e2_e3_ni = a.m_no_e2_e3_ni;
	m_no_e1_e3_ni = a.m_no_e1_e3_ni;
	m_no_e1_e2_ni = a.m_no_e1_e2_ni;

}
inline void pseudoscalar::set(const pseudoscalar &a)
{
	m_no_e1_e2_e3_ni = a.m_no_e1_e2_e3_ni;

}
inline void normalizedTranslator::set(const normalizedTranslator &a)
{
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;

}
inline void translator::set(const translator &a)
{
	m_scalar = a.m_scalar;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;

}
inline void RBM::set(const RBM &a)
{
	m_scalar = a.m_scalar;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;
	m_e1_e2_e3_ni = a.m_e1_e2_e3_ni;

}
inline void evenVersor::set(const evenVersor &a)
{
	m_scalar = a.m_scalar;
	m_no_e1 = a.m_no_e1;
	m_no_e2 = a.m_no_e2;
	m_no_e3 = a.m_no_e3;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;
	m_e1_ni = a.m_e1_ni;
	m_e2_ni = a.m_e2_ni;
	m_e3_ni = a.m_e3_ni;
	m_no_ni = a.m_no_ni;
	m_e1_e2_e3_ni = a.m_e1_e2_e3_ni;
	m_no_e2_e3_ni = a.m_no_e2_e3_ni;
	m_no_e1_e3_ni = a.m_no_e1_e3_ni;
	m_no_e1_e2_ni = a.m_no_e1_e2_ni;
	m_no_e1_e2_e3 = a.m_no_e1_e2_e3;

}
inline void oddVersor::set(const oddVersor &a)
{
	m_no = a.m_no;
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_ni = a.m_ni;
	m_no_e1_e2 = a.m_no_e1_e2;
	m_no_e1_e3 = a.m_no_e1_e3;
	m_no_e2_e3 = a.m_no_e2_e3;
	m_e1_e2_e3 = a.m_e1_e2_e3;
	m_no_e1_ni = a.m_no_e1_ni;
	m_no_e2_ni = a.m_no_e2_ni;
	m_e1_e2_ni = a.m_e1_e2_ni;
	m_no_e3_ni = a.m_no_e3_ni;
	m_e1_e3_ni = a.m_e1_e3_ni;
	m_e2_e3_ni = a.m_e2_e3_ni;
	m_no_e1_e2_e3_ni = a.m_no_e1_e2_e3_ni;

}


inline double no_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double no_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	return maxValue;
}
inline double e1_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e1_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 2;
	return maxValue;
}
inline double e2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 4;
	return maxValue;
}
inline double e3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 8;
	return maxValue;
}
inline double ni_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double ni_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 16;
	return maxValue;
}
inline double noni_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double noni_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 17;
	return maxValue;
}
inline double I3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 14;
	return maxValue;
}
inline double I5_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I5_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 31;
	return maxValue;
}
inline double I5i_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I5i_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 31;
	return maxValue;
}
inline double vectorE3GA::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	return maxValue;
}
inline double vectorE3GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 8; }
	return maxValue;
}
inline double bivectorE3GA::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2);
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double bivectorE3GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2);
	bm = 0;
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 12; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 10; }
	return maxValue;
}
inline double rotorE3GA::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double rotorE3GA::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 12; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 10; }
	return maxValue;
}
inline double normalizedPoint::largestCoordinate() const {
	double maxValue = 1.0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	return maxValue;
}
inline double normalizedPoint::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 8; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 16; }
	return maxValue;
}
inline double dualSphere::largestCoordinate() const {
	double maxValue = ::fabs(m_no);
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	return maxValue;
}
inline double dualSphere::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no);
	bm = 0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 8; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 16; }
	return maxValue;
}
inline double dualPlane::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	return maxValue;
}
inline double dualPlane::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 8; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 16; }
	return maxValue;
}
inline double freeVector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_ni);
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	return maxValue;
}
inline double freeVector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_ni);
	bm = 0;
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	return maxValue;
}
inline double freeBivector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_ni);
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); }
	if (::fabs(m_e3_e1_ni) > maxValue) { maxValue = ::fabs(m_e3_e1_ni); }
	return maxValue;
}
inline double freeBivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_ni);
	bm = 0;
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); bm = 28; }
	if (::fabs(m_e3_e1_ni) > maxValue) { maxValue = ::fabs(m_e3_e1_ni); bm = 26; }
	return maxValue;
}
inline double flatPoint::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_ni);
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); }
	return maxValue;
}
inline double flatPoint::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_ni);
	bm = 0;
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); bm = 17; }
	return maxValue;
}
inline double pointPair::largestCoordinate() const {
	double maxValue = ::fabs(m_no_e1);
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); }
	if (::fabs(m_no_e3) > maxValue) { maxValue = ::fabs(m_no_e3); }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); }
	return maxValue;
}
inline double pointPair::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no_e1);
	bm = 0;
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); bm = 5; }
	if (::fabs(m_no_e3) > maxValue) { maxValue = ::fabs(m_no_e3); bm = 9; }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 12; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 10; }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 18; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); bm = 17; }
	return maxValue;
}
inline double line::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_ni);
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); }
	if (::fabs(m_e1_no_ni) > maxValue) { maxValue = ::fabs(m_e1_no_ni); }
	if (::fabs(m_e2_no_ni) > maxValue) { maxValue = ::fabs(m_e2_no_ni); }
	if (::fabs(m_e3_no_ni) > maxValue) { maxValue = ::fabs(m_e3_no_ni); }
	return maxValue;
}
inline double line::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_ni);
	bm = 0;
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); bm = 26; }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); bm = 28; }
	if (::fabs(m_e1_no_ni) > maxValue) { maxValue = ::fabs(m_e1_no_ni); bm = 19; }
	if (::fabs(m_e2_no_ni) > maxValue) { maxValue = ::fabs(m_e2_no_ni); bm = 21; }
	if (::fabs(m_e3_no_ni) > maxValue) { maxValue = ::fabs(m_e3_no_ni); bm = 25; }
	return maxValue;
}
inline double circle::largestCoordinate() const {
	double maxValue = ::fabs(m_no_e1_e2);
	if (::fabs(m_no_e1_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e3); }
	if (::fabs(m_no_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e2_e3); }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); }
	if (::fabs(m_no_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e3_ni); }
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); }
	return maxValue;
}
inline double circle::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no_e1_e2);
	bm = 0;
	if (::fabs(m_no_e1_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e3); bm = 11; }
	if (::fabs(m_no_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e2_e3); bm = 13; }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); bm = 14; }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); bm = 19; }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); bm = 21; }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); bm = 22; }
	if (::fabs(m_no_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e3_ni); bm = 25; }
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); bm = 26; }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); bm = 28; }
	return maxValue;
}
inline double sphere::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_e3_ni);
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); }
	if (::fabs(m_no_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3); }
	return maxValue;
}
inline double sphere::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_e3_ni);
	bm = 0;
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); bm = 29; }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); bm = 27; }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); bm = 23; }
	if (::fabs(m_no_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3); bm = 15; }
	return maxValue;
}
inline double plane::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_e3_ni);
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); }
	return maxValue;
}
inline double plane::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_e3_ni);
	bm = 0;
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); bm = 29; }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); bm = 27; }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); bm = 23; }
	return maxValue;
}
inline double pseudoscalar::largestCoordinate() const {
	double maxValue = ::fabs(m_no_e1_e2_e3_ni);
	return maxValue;
}
inline double pseudoscalar::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no_e1_e2_e3_ni);
	bm = 0;
	return maxValue;
}
inline double normalizedTranslator::largestCoordinate() const {
	double maxValue = 1.0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	return maxValue;
}
inline double normalizedTranslator::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 18; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	return maxValue;
}
inline double translator::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	return maxValue;
}
inline double translator::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 18; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	return maxValue;
}
inline double RBM::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	if (::fabs(m_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_e3_ni); }
	return maxValue;
}
inline double RBM::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 12; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 10; }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 18; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	if (::fabs(m_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_e3_ni); bm = 30; }
	return maxValue;
}
inline double evenVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_no_e1) > maxValue) { maxValue = ::fabs(m_no_e1); }
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); }
	if (::fabs(m_no_e3) > maxValue) { maxValue = ::fabs(m_no_e3); }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); }
	if (::fabs(m_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_e3_ni); }
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); }
	if (::fabs(m_no_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3); }
	return maxValue;
}
inline double evenVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_no_e1) > maxValue) { maxValue = ::fabs(m_no_e1); bm = 3; }
	if (::fabs(m_no_e2) > maxValue) { maxValue = ::fabs(m_no_e2); bm = 5; }
	if (::fabs(m_no_e3) > maxValue) { maxValue = ::fabs(m_no_e3); bm = 9; }
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 6; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 12; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 10; }
	if (::fabs(m_e1_ni) > maxValue) { maxValue = ::fabs(m_e1_ni); bm = 18; }
	if (::fabs(m_e2_ni) > maxValue) { maxValue = ::fabs(m_e2_ni); bm = 20; }
	if (::fabs(m_e3_ni) > maxValue) { maxValue = ::fabs(m_e3_ni); bm = 24; }
	if (::fabs(m_no_ni) > maxValue) { maxValue = ::fabs(m_no_ni); bm = 17; }
	if (::fabs(m_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_e3_ni); bm = 30; }
	if (::fabs(m_no_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e2_e3_ni); bm = 29; }
	if (::fabs(m_no_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e3_ni); bm = 27; }
	if (::fabs(m_no_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_ni); bm = 23; }
	if (::fabs(m_no_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3); bm = 15; }
	return maxValue;
}
inline double oddVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_no);
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); }
	if (::fabs(m_no_e1_e2) > maxValue) { maxValue = ::fabs(m_no_e1_e2); }
	if (::fabs(m_no_e1_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e3); }
	if (::fabs(m_no_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e2_e3); }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); }
	if (::fabs(m_no_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e3_ni); }
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); }
	if (::fabs(m_no_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3_ni); }
	return maxValue;
}
inline double oddVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_no);
	bm = 0;
	if (::fabs(m_e1) > maxValue) { maxValue = ::fabs(m_e1); bm = 2; }
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 4; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 8; }
	if (::fabs(m_ni) > maxValue) { maxValue = ::fabs(m_ni); bm = 16; }
	if (::fabs(m_no_e1_e2) > maxValue) { maxValue = ::fabs(m_no_e1_e2); bm = 7; }
	if (::fabs(m_no_e1_e3) > maxValue) { maxValue = ::fabs(m_no_e1_e3); bm = 11; }
	if (::fabs(m_no_e2_e3) > maxValue) { maxValue = ::fabs(m_no_e2_e3); bm = 13; }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); bm = 14; }
	if (::fabs(m_no_e1_ni) > maxValue) { maxValue = ::fabs(m_no_e1_ni); bm = 19; }
	if (::fabs(m_no_e2_ni) > maxValue) { maxValue = ::fabs(m_no_e2_ni); bm = 21; }
	if (::fabs(m_e1_e2_ni) > maxValue) { maxValue = ::fabs(m_e1_e2_ni); bm = 22; }
	if (::fabs(m_no_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e3_ni); bm = 25; }
	if (::fabs(m_e1_e3_ni) > maxValue) { maxValue = ::fabs(m_e1_e3_ni); bm = 26; }
	if (::fabs(m_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_e2_e3_ni); bm = 28; }
	if (::fabs(m_no_e1_e2_e3_ni) > maxValue) { maxValue = ::fabs(m_no_e1_e2_e3_ni); bm = 31; }
	return maxValue;
}

inline double _double(const no_t &x) {
	return 0.0;
}
inline double _double(const e1_t &x) {
	return 0.0;
}
inline double _double(const e2_t &x) {
	return 0.0;
}
inline double _double(const e3_t &x) {
	return 0.0;
}
inline double _double(const ni_t &x) {
	return 0.0;
}
inline double _double(const noni_t &x) {
	return 0.0;
}
inline double _double(const I3_t &x) {
	return 0.0;
}
inline double _double(const I5_t &x) {
	return 0.0;
}
inline double _double(const I5i_t &x) {
	return 0.0;
}
inline double _double(const vectorE3GA &x) {
	return 0.0;
}
inline double _double(const bivectorE3GA &x) {
	return 0.0;
}
inline double _double(const rotorE3GA &x) {
	return x.m_scalar;
}
inline double _double(const normalizedPoint &x) {
	return 0.0;
}
inline double _double(const dualSphere &x) {
	return 0.0;
}
inline double _double(const dualPlane &x) {
	return 0.0;
}
inline double _double(const freeVector &x) {
	return 0.0;
}
inline double _double(const freeBivector &x) {
	return 0.0;
}
inline double _double(const flatPoint &x) {
	return 0.0;
}
inline double _double(const pointPair &x) {
	return 0.0;
}
inline double _double(const line &x) {
	return 0.0;
}
inline double _double(const circle &x) {
	return 0.0;
}
inline double _double(const sphere &x) {
	return 0.0;
}
inline double _double(const plane &x) {
	return 0.0;
}
inline double _double(const pseudoscalar &x) {
	return 0.0;
}
inline double _double(const normalizedTranslator &x) {
	return 1.0;
}
inline double _double(const translator &x) {
	return x.m_scalar;
}
inline double _double(const RBM &x) {
	return x.m_scalar;
}
inline double _double(const evenVersor &x) {
	return x.m_scalar;
}
inline double _double(const oddVersor &x) {
	return 0.0;
}

inline void om::setIdentity() {
	c3ga::zero_N(m_m1, 25);

	c3ga::zero_N(m_m2, 100);

	c3ga::zero_N(m_m3, 100);

	c3ga::zero_N(m_m4, 25);

	c3ga::zero_1(m_m5);

	m_m1[0] = m_m1[6] = m_m1[12] = m_m1[18] = m_m1[24] = m_m2[0] = m_m2[11] = m_m2[22] = 
		m_m2[33] = m_m2[44] = m_m2[55] = m_m2[66] = m_m2[77] = m_m2[88] = m_m2[99] = m_m3[0] = 
		m_m3[11] = m_m3[22] = m_m3[33] = m_m3[44] = m_m3[55] = m_m3[66] = m_m3[77] = m_m3[88] = 
		m_m3[99] = m_m4[0] = m_m4[6] = m_m4[12] = m_m4[18] = m_m4[24] = m_m5[0] = 1.0;
}

inline void om::set(const om &src) {
	c3ga::copy_N(m_m1, src.m_m1, 25);

	c3ga::copy_N(m_m2, src.m_m2, 100);

	c3ga::copy_N(m_m3, src.m_m3, 100);

	c3ga::copy_N(m_m4, src.m_m4, 25);

	c3ga::copy_1(m_m5, src.m_m5);

}
inline void grade1OM_E3GA::set(const om &src) {
	m_m1[0] =  src.m_m1[6];
	m_m1[1] =  src.m_m1[7];
	m_m1[2] =  src.m_m1[8];
	m_m1[3] =  src.m_m1[11];
	m_m1[4] =  src.m_m1[12];
	m_m1[5] =  src.m_m1[13];
	m_m1[6] =  src.m_m1[16];
	m_m1[7] =  src.m_m1[17];
	m_m1[8] =  src.m_m1[18];
}
inline void grade1OM::set(const om &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
	m_m1[16] =  src.m_m1[16];
	m_m1[17] =  src.m_m1[17];
	m_m1[18] =  src.m_m1[18];
	m_m1[19] =  src.m_m1[19];
	m_m1[20] =  src.m_m1[20];
	m_m1[21] =  src.m_m1[21];
	m_m1[22] =  src.m_m1[22];
	m_m1[23] =  src.m_m1[23];
	m_m1[24] =  src.m_m1[24];
}
inline void flatPointOM::set(const om &src) {
	m_m2[0] =  src.m_m2[77];
	m_m2[1] =  src.m_m2[78];
	m_m2[2] =  src.m_m2[79];
	m_m2[3] =  src.m_m2[76];
	m_m2[4] =  src.m_m2[87];
	m_m2[5] =  src.m_m2[88];
	m_m2[6] =  src.m_m2[89];
	m_m2[7] =  src.m_m2[86];
	m_m2[8] =  src.m_m2[97];
	m_m2[9] =  src.m_m2[98];
	m_m2[10] =  src.m_m2[99];
	m_m2[11] =  src.m_m2[96];
	m_m2[12] =  src.m_m2[67];
	m_m2[13] =  src.m_m2[68];
	m_m2[14] =  src.m_m2[69];
	m_m2[15] =  src.m_m2[66];
}
inline void om::set(const grade1OM_E3GA &src) {
	m_m1[6] =  src.m_m1[0];
	m_m1[7] =  src.m_m1[1];
	m_m1[8] =  src.m_m1[2];
	m_m1[11] =  src.m_m1[3];
	m_m1[12] =  src.m_m1[4];
	m_m1[13] =  src.m_m1[5];
	m_m1[16] =  src.m_m1[6];
	m_m1[17] =  src.m_m1[7];
	m_m1[18] =  src.m_m1[8];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[9] = m_m1[10] = m_m1[14] = 
		m_m1[15] = m_m1[19] = m_m1[20] = m_m1[21] = m_m1[22] = m_m1[23] = m_m1[24] = m_m2[0] = m_m2[1] = 
		m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = m_m2[9] = m_m2[10] = 
		m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = m_m2[18] = m_m2[19] = 
		m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = m_m2[27] = m_m2[28] = 
		m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = m_m2[36] = m_m2[37] = 
		m_m2[38] = m_m2[39] = m_m2[40] = m_m2[41] = m_m2[42] = m_m2[43] = m_m2[44] = m_m2[45] = m_m2[46] = 
		m_m2[47] = m_m2[48] = m_m2[49] = m_m2[50] = m_m2[51] = m_m2[52] = m_m2[53] = m_m2[54] = m_m2[55] = 
		m_m2[56] = m_m2[57] = m_m2[58] = m_m2[59] = m_m2[60] = m_m2[61] = m_m2[62] = m_m2[63] = m_m2[64] = 
		m_m2[65] = m_m2[66] = m_m2[67] = m_m2[68] = m_m2[69] = m_m2[70] = m_m2[71] = m_m2[72] = m_m2[73] = 
		m_m2[74] = m_m2[75] = m_m2[76] = m_m2[77] = m_m2[78] = m_m2[79] = m_m2[80] = m_m2[81] = m_m2[82] = 
		m_m2[83] = m_m2[84] = m_m2[85] = m_m2[86] = m_m2[87] = m_m2[88] = m_m2[89] = m_m2[90] = m_m2[91] = 
		m_m2[92] = m_m2[93] = m_m2[94] = m_m2[95] = m_m2[96] = m_m2[97] = m_m2[98] = m_m2[99] = m_m3[0] = 
		m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = m_m3[8] = m_m3[9] = 
		m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m3[16] = m_m3[17] = m_m3[18] = 
		m_m3[19] = m_m3[20] = m_m3[21] = m_m3[22] = m_m3[23] = m_m3[24] = m_m3[25] = m_m3[26] = m_m3[27] = 
		m_m3[28] = m_m3[29] = m_m3[30] = m_m3[31] = m_m3[32] = m_m3[33] = m_m3[34] = m_m3[35] = m_m3[36] = 
		m_m3[37] = m_m3[38] = m_m3[39] = m_m3[40] = m_m3[41] = m_m3[42] = m_m3[43] = m_m3[44] = m_m3[45] = 
		m_m3[46] = m_m3[47] = m_m3[48] = m_m3[49] = m_m3[50] = m_m3[51] = m_m3[52] = m_m3[53] = m_m3[54] = 
		m_m3[55] = m_m3[56] = m_m3[57] = m_m3[58] = m_m3[59] = m_m3[60] = m_m3[61] = m_m3[62] = m_m3[63] = 
		m_m3[64] = m_m3[65] = m_m3[66] = m_m3[67] = m_m3[68] = m_m3[69] = m_m3[70] = m_m3[71] = m_m3[72] = 
		m_m3[73] = m_m3[74] = m_m3[75] = m_m3[76] = m_m3[77] = m_m3[78] = m_m3[79] = m_m3[80] = m_m3[81] = 
		m_m3[82] = m_m3[83] = m_m3[84] = m_m3[85] = m_m3[86] = m_m3[87] = m_m3[88] = m_m3[89] = m_m3[90] = 
		m_m3[91] = m_m3[92] = m_m3[93] = m_m3[94] = m_m3[95] = m_m3[96] = m_m3[97] = m_m3[98] = m_m3[99] = 
		m_m4[0] = m_m4[1] = m_m4[2] = m_m4[3] = m_m4[4] = m_m4[5] = m_m4[6] = m_m4[7] = m_m4[8] = 
		m_m4[9] = m_m4[10] = m_m4[11] = m_m4[12] = m_m4[13] = m_m4[14] = m_m4[15] = m_m4[16] = m_m4[17] = 
		m_m4[18] = m_m4[19] = m_m4[20] = m_m4[21] = m_m4[22] = m_m4[23] = m_m4[24] = m_m5[0] = 0.0;
}
inline void om::set(const grade1OM &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m1[9] =  src.m_m1[9];
	m_m1[10] =  src.m_m1[10];
	m_m1[11] =  src.m_m1[11];
	m_m1[12] =  src.m_m1[12];
	m_m1[13] =  src.m_m1[13];
	m_m1[14] =  src.m_m1[14];
	m_m1[15] =  src.m_m1[15];
	m_m1[16] =  src.m_m1[16];
	m_m1[17] =  src.m_m1[17];
	m_m1[18] =  src.m_m1[18];
	m_m1[19] =  src.m_m1[19];
	m_m1[20] =  src.m_m1[20];
	m_m1[21] =  src.m_m1[21];
	m_m1[22] =  src.m_m1[22];
	m_m1[23] =  src.m_m1[23];
	m_m1[24] =  src.m_m1[24];
	m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = 
		m_m2[9] = m_m2[10] = m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = 
		m_m2[18] = m_m2[19] = m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = 
		m_m2[27] = m_m2[28] = m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = 
		m_m2[36] = m_m2[37] = m_m2[38] = m_m2[39] = m_m2[40] = m_m2[41] = m_m2[42] = m_m2[43] = m_m2[44] = 
		m_m2[45] = m_m2[46] = m_m2[47] = m_m2[48] = m_m2[49] = m_m2[50] = m_m2[51] = m_m2[52] = m_m2[53] = 
		m_m2[54] = m_m2[55] = m_m2[56] = m_m2[57] = m_m2[58] = m_m2[59] = m_m2[60] = m_m2[61] = m_m2[62] = 
		m_m2[63] = m_m2[64] = m_m2[65] = m_m2[66] = m_m2[67] = m_m2[68] = m_m2[69] = m_m2[70] = m_m2[71] = 
		m_m2[72] = m_m2[73] = m_m2[74] = m_m2[75] = m_m2[76] = m_m2[77] = m_m2[78] = m_m2[79] = m_m2[80] = 
		m_m2[81] = m_m2[82] = m_m2[83] = m_m2[84] = m_m2[85] = m_m2[86] = m_m2[87] = m_m2[88] = m_m2[89] = 
		m_m2[90] = m_m2[91] = m_m2[92] = m_m2[93] = m_m2[94] = m_m2[95] = m_m2[96] = m_m2[97] = m_m2[98] = 
		m_m2[99] = m_m3[0] = m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = 
		m_m3[8] = m_m3[9] = m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m3[16] = 
		m_m3[17] = m_m3[18] = m_m3[19] = m_m3[20] = m_m3[21] = m_m3[22] = m_m3[23] = m_m3[24] = m_m3[25] = 
		m_m3[26] = m_m3[27] = m_m3[28] = m_m3[29] = m_m3[30] = m_m3[31] = m_m3[32] = m_m3[33] = m_m3[34] = 
		m_m3[35] = m_m3[36] = m_m3[37] = m_m3[38] = m_m3[39] = m_m3[40] = m_m3[41] = m_m3[42] = m_m3[43] = 
		m_m3[44] = m_m3[45] = m_m3[46] = m_m3[47] = m_m3[48] = m_m3[49] = m_m3[50] = m_m3[51] = m_m3[52] = 
		m_m3[53] = m_m3[54] = m_m3[55] = m_m3[56] = m_m3[57] = m_m3[58] = m_m3[59] = m_m3[60] = m_m3[61] = 
		m_m3[62] = m_m3[63] = m_m3[64] = m_m3[65] = m_m3[66] = m_m3[67] = m_m3[68] = m_m3[69] = m_m3[70] = 
		m_m3[71] = m_m3[72] = m_m3[73] = m_m3[74] = m_m3[75] = m_m3[76] = m_m3[77] = m_m3[78] = m_m3[79] = 
		m_m3[80] = m_m3[81] = m_m3[82] = m_m3[83] = m_m3[84] = m_m3[85] = m_m3[86] = m_m3[87] = m_m3[88] = 
		m_m3[89] = m_m3[90] = m_m3[91] = m_m3[92] = m_m3[93] = m_m3[94] = m_m3[95] = m_m3[96] = m_m3[97] = 
		m_m3[98] = m_m3[99] = m_m4[0] = m_m4[1] = m_m4[2] = m_m4[3] = m_m4[4] = m_m4[5] = m_m4[6] = 
		m_m4[7] = m_m4[8] = m_m4[9] = m_m4[10] = m_m4[11] = m_m4[12] = m_m4[13] = m_m4[14] = m_m4[15] = 
		m_m4[16] = m_m4[17] = m_m4[18] = m_m4[19] = m_m4[20] = m_m4[21] = m_m4[22] = m_m4[23] = m_m4[24] = 
		m_m5[0] = 0.0;
}
inline void om::set(const flatPointOM &src) {
	m_m2[66] =  src.m_m2[15];
	m_m2[67] =  src.m_m2[12];
	m_m2[68] =  src.m_m2[13];
	m_m2[69] =  src.m_m2[14];
	m_m2[76] =  src.m_m2[3];
	m_m2[77] =  src.m_m2[0];
	m_m2[78] =  src.m_m2[1];
	m_m2[79] =  src.m_m2[2];
	m_m2[86] =  src.m_m2[7];
	m_m2[87] =  src.m_m2[4];
	m_m2[88] =  src.m_m2[5];
	m_m2[89] =  src.m_m2[6];
	m_m2[96] =  src.m_m2[11];
	m_m2[97] =  src.m_m2[8];
	m_m2[98] =  src.m_m2[9];
	m_m2[99] =  src.m_m2[10];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m1[9] = m_m1[10] = m_m1[11] = m_m1[12] = m_m1[13] = m_m1[14] = m_m1[15] = m_m1[16] = m_m1[17] = 
		m_m1[18] = m_m1[19] = m_m1[20] = m_m1[21] = m_m1[22] = m_m1[23] = m_m1[24] = m_m2[0] = m_m2[1] = 
		m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = m_m2[9] = m_m2[10] = 
		m_m2[11] = m_m2[12] = m_m2[13] = m_m2[14] = m_m2[15] = m_m2[16] = m_m2[17] = m_m2[18] = m_m2[19] = 
		m_m2[20] = m_m2[21] = m_m2[22] = m_m2[23] = m_m2[24] = m_m2[25] = m_m2[26] = m_m2[27] = m_m2[28] = 
		m_m2[29] = m_m2[30] = m_m2[31] = m_m2[32] = m_m2[33] = m_m2[34] = m_m2[35] = m_m2[36] = m_m2[37] = 
		m_m2[38] = m_m2[39] = m_m2[40] = m_m2[41] = m_m2[42] = m_m2[43] = m_m2[44] = m_m2[45] = m_m2[46] = 
		m_m2[47] = m_m2[48] = m_m2[49] = m_m2[50] = m_m2[51] = m_m2[52] = m_m2[53] = m_m2[54] = m_m2[55] = 
		m_m2[56] = m_m2[57] = m_m2[58] = m_m2[59] = m_m2[60] = m_m2[61] = m_m2[62] = m_m2[63] = m_m2[64] = 
		m_m2[65] = m_m2[70] = m_m2[71] = m_m2[72] = m_m2[73] = m_m2[74] = m_m2[75] = m_m2[80] = m_m2[81] = 
		m_m2[82] = m_m2[83] = m_m2[84] = m_m2[85] = m_m2[90] = m_m2[91] = m_m2[92] = m_m2[93] = m_m2[94] = 
		m_m2[95] = m_m3[0] = m_m3[1] = m_m3[2] = m_m3[3] = m_m3[4] = m_m3[5] = m_m3[6] = m_m3[7] = 
		m_m3[8] = m_m3[9] = m_m3[10] = m_m3[11] = m_m3[12] = m_m3[13] = m_m3[14] = m_m3[15] = m_m3[16] = 
		m_m3[17] = m_m3[18] = m_m3[19] = m_m3[20] = m_m3[21] = m_m3[22] = m_m3[23] = m_m3[24] = m_m3[25] = 
		m_m3[26] = m_m3[27] = m_m3[28] = m_m3[29] = m_m3[30] = m_m3[31] = m_m3[32] = m_m3[33] = m_m3[34] = 
		m_m3[35] = m_m3[36] = m_m3[37] = m_m3[38] = m_m3[39] = m_m3[40] = m_m3[41] = m_m3[42] = m_m3[43] = 
		m_m3[44] = m_m3[45] = m_m3[46] = m_m3[47] = m_m3[48] = m_m3[49] = m_m3[50] = m_m3[51] = m_m3[52] = 
		m_m3[53] = m_m3[54] = m_m3[55] = m_m3[56] = m_m3[57] = m_m3[58] = m_m3[59] = m_m3[60] = m_m3[61] = 
		m_m3[62] = m_m3[63] = m_m3[64] = m_m3[65] = m_m3[66] = m_m3[67] = m_m3[68] = m_m3[69] = m_m3[70] = 
		m_m3[71] = m_m3[72] = m_m3[73] = m_m3[74] = m_m3[75] = m_m3[76] = m_m3[77] = m_m3[78] = m_m3[79] = 
		m_m3[80] = m_m3[81] = m_m3[82] = m_m3[83] = m_m3[84] = m_m3[85] = m_m3[86] = m_m3[87] = m_m3[88] = 
		m_m3[89] = m_m3[90] = m_m3[91] = m_m3[92] = m_m3[93] = m_m3[94] = m_m3[95] = m_m3[96] = m_m3[97] = 
		m_m3[98] = m_m3[99] = m_m4[0] = m_m4[1] = m_m4[2] = m_m4[3] = m_m4[4] = m_m4[5] = m_m4[6] = 
		m_m4[7] = m_m4[8] = m_m4[9] = m_m4[10] = m_m4[11] = m_m4[12] = m_m4[13] = m_m4[14] = m_m4[15] = 
		m_m4[16] = m_m4[17] = m_m4[18] = m_m4[19] = m_m4[20] = m_m4[21] = m_m4[22] = m_m4[23] = m_m4[24] = 
		m_m5[0] = 0.0;
}

inline void grade1OM_E3GA::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[3] = m_m1[6] = 0.0;

	m_m1[1] = m_m1[7] = 0.0;
	m_m1[4] = 1.0;

	m_m1[2] = m_m1[5] = 0.0;
	m_m1[8] = 1.0;

}

inline void grade1OM::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[5] = m_m1[10] = m_m1[15] = m_m1[20] = 0.0;

	m_m1[1] = m_m1[11] = m_m1[16] = m_m1[21] = 0.0;
	m_m1[6] = 1.0;

	m_m1[2] = m_m1[7] = m_m1[17] = m_m1[22] = 0.0;
	m_m1[12] = 1.0;

	m_m1[3] = m_m1[8] = m_m1[13] = m_m1[23] = 0.0;
	m_m1[18] = 1.0;

	m_m1[4] = m_m1[9] = m_m1[14] = m_m1[19] = 0.0;
	m_m1[24] = 1.0;

}

inline void flatPointOM::setIdentity()
{
	m_m2[0] = 1.0;
	m_m2[4] = m_m2[8] = m_m2[12] = 0.0;

	m_m2[1] = m_m2[9] = m_m2[13] = 0.0;
	m_m2[5] = 1.0;

	m_m2[2] = m_m2[6] = m_m2[14] = 0.0;
	m_m2[10] = 1.0;

	m_m2[3] = m_m2[7] = m_m2[11] = 0.0;
	m_m2[15] = 1.0;

}

inline void grade1OM_E3GA::set(const grade1OM_E3GA &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[3] = src.m_m1[3];
	m_m1[6] = src.m_m1[6];

	m_m1[1] = src.m_m1[1];
	m_m1[4] = src.m_m1[4];
	m_m1[7] = src.m_m1[7];

	m_m1[2] = src.m_m1[2];
	m_m1[5] = src.m_m1[5];
	m_m1[8] = src.m_m1[8];

}

inline void grade1OM::set(const grade1OM &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[5] = src.m_m1[5];
	m_m1[10] = src.m_m1[10];
	m_m1[15] = src.m_m1[15];
	m_m1[20] = src.m_m1[20];

	m_m1[1] = src.m_m1[1];
	m_m1[6] = src.m_m1[6];
	m_m1[11] = src.m_m1[11];
	m_m1[16] = src.m_m1[16];
	m_m1[21] = src.m_m1[21];

	m_m1[2] = src.m_m1[2];
	m_m1[7] = src.m_m1[7];
	m_m1[12] = src.m_m1[12];
	m_m1[17] = src.m_m1[17];
	m_m1[22] = src.m_m1[22];

	m_m1[3] = src.m_m1[3];
	m_m1[8] = src.m_m1[8];
	m_m1[13] = src.m_m1[13];
	m_m1[18] = src.m_m1[18];
	m_m1[23] = src.m_m1[23];

	m_m1[4] = src.m_m1[4];
	m_m1[9] = src.m_m1[9];
	m_m1[14] = src.m_m1[14];
	m_m1[19] = src.m_m1[19];
	m_m1[24] = src.m_m1[24];

}

inline void flatPointOM::set(const flatPointOM &src)
{
	m_m2[0] = src.m_m2[0];
	m_m2[4] = src.m_m2[4];
	m_m2[8] = src.m_m2[8];
	m_m2[12] = src.m_m2[12];

	m_m2[1] = src.m_m2[1];
	m_m2[5] = src.m_m2[5];
	m_m2[9] = src.m_m2[9];
	m_m2[13] = src.m_m2[13];

	m_m2[2] = src.m_m2[2];
	m_m2[6] = src.m_m2[6];
	m_m2[10] = src.m_m2[10];
	m_m2[14] = src.m_m2[14];

	m_m2[3] = src.m_m2[3];
	m_m2[7] = src.m_m2[7];
	m_m2[11] = src.m_m2[11];
	m_m2[15] = src.m_m2[15];

}
inline void grade1OM_E3GA::set(const vectorE3GA &ie1, const vectorE3GA &ie2, const vectorE3GA &ie3)
{
	// Set image of e1
	m_m1[0] = ie1.m_e1;
	m_m1[3] = ie1.m_e2;
	m_m1[6] = ie1.m_e3;

	// Set image of e2
	m_m1[1] = ie2.m_e1;
	m_m1[4] = ie2.m_e2;
	m_m1[7] = ie2.m_e3;

	// Set image of e3
	m_m1[2] = ie3.m_e1;
	m_m1[5] = ie3.m_e2;
	m_m1[8] = ie3.m_e3;

}
inline void grade1OM::set(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini)
{
	// Set image of no
	m_m1[0] = ino.m_no;
	m_m1[5] = ino.m_e1;
	m_m1[10] = ino.m_e2;
	m_m1[15] = ino.m_e3;
	m_m1[20] = ino.m_ni;

	// Set image of e1
	m_m1[1] = ie1.m_no;
	m_m1[6] = ie1.m_e1;
	m_m1[11] = ie1.m_e2;
	m_m1[16] = ie1.m_e3;
	m_m1[21] = ie1.m_ni;

	// Set image of e2
	m_m1[2] = ie2.m_no;
	m_m1[7] = ie2.m_e1;
	m_m1[12] = ie2.m_e2;
	m_m1[17] = ie2.m_e3;
	m_m1[22] = ie2.m_ni;

	// Set image of e3
	m_m1[3] = ie3.m_no;
	m_m1[8] = ie3.m_e1;
	m_m1[13] = ie3.m_e2;
	m_m1[18] = ie3.m_e3;
	m_m1[23] = ie3.m_ni;

	// Set image of ni
	m_m1[4] = ini.m_no;
	m_m1[9] = ini.m_e1;
	m_m1[14] = ini.m_e2;
	m_m1[19] = ini.m_e3;
	m_m1[24] = ini.m_ni;

}
inline void flatPointOM::set(const dualSphere &ino, const dualSphere &ie1, const dualSphere &ie2, const dualSphere &ie3, const dualSphere &ini)
{
	// Set image of e1^ni
	m_m2[0] = (ie1.m_e1*ini.m_ni-ie1.m_ni*ini.m_e1);
	m_m2[4] = (ie1.m_e2*ini.m_ni-ie1.m_ni*ini.m_e2);
	m_m2[8] = (ie1.m_e3*ini.m_ni-ie1.m_ni*ini.m_e3);
	m_m2[12] = (-ie1.m_ni*ini.m_no+ie1.m_no*ini.m_ni);

	// Set image of e2^ni
	m_m2[1] = (ie2.m_e1*ini.m_ni-ie2.m_ni*ini.m_e1);
	m_m2[5] = (ie2.m_e2*ini.m_ni-ie2.m_ni*ini.m_e2);
	m_m2[9] = (ie2.m_e3*ini.m_ni-ie2.m_ni*ini.m_e3);
	m_m2[13] = (-ie2.m_ni*ini.m_no+ie2.m_no*ini.m_ni);

	// Set image of e3^ni
	m_m2[2] = (ie3.m_e1*ini.m_ni-ie3.m_ni*ini.m_e1);
	m_m2[6] = (ie3.m_e2*ini.m_ni-ie3.m_ni*ini.m_e2);
	m_m2[10] = (ie3.m_e3*ini.m_ni-ie3.m_ni*ini.m_e3);
	m_m2[14] = (-ie3.m_ni*ini.m_no+ie3.m_no*ini.m_ni);

	// Set image of no^ni
	m_m2[3] = (-ini.m_e1*ino.m_ni+ini.m_ni*ino.m_e1);
	m_m2[7] = (-ini.m_e2*ino.m_ni+ini.m_ni*ino.m_e2);
	m_m2[11] = (-ini.m_e3*ino.m_ni+ini.m_ni*ino.m_e3);
	m_m2[15] = (ini.m_ni*ino.m_no-ini.m_no*ino.m_ni);

}
inline void grade1OM_E3GA::set(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[3] = M[3];
	m_m1[6] = M[6];

	// Set image of e2
	m_m1[1] = M[1];
	m_m1[4] = M[4];
	m_m1[7] = M[7];

	// Set image of e3
	m_m1[2] = M[2];
	m_m1[5] = M[5];
	m_m1[8] = M[8];

}
inline void grade1OM::set(const double *M)
{
	// Set image of no
	m_m1[0] = M[0];
	m_m1[5] = M[5];
	m_m1[10] = M[10];
	m_m1[15] = M[15];
	m_m1[20] = M[20];

	// Set image of e1
	m_m1[1] = M[1];
	m_m1[6] = M[6];
	m_m1[11] = M[11];
	m_m1[16] = M[16];
	m_m1[21] = M[21];

	// Set image of e2
	m_m1[2] = M[2];
	m_m1[7] = M[7];
	m_m1[12] = M[12];
	m_m1[17] = M[17];
	m_m1[22] = M[22];

	// Set image of e3
	m_m1[3] = M[3];
	m_m1[8] = M[8];
	m_m1[13] = M[13];
	m_m1[18] = M[18];
	m_m1[23] = M[23];

	// Set image of ni
	m_m1[4] = M[4];
	m_m1[9] = M[9];
	m_m1[14] = M[14];
	m_m1[19] = M[19];
	m_m1[24] = M[24];

}
inline void flatPointOM::set(const double *M)
{
	// Set image of e1^ni
	m_m2[0] = (-M[21]*M[9]+M[24]*M[6]);
	m_m2[4] = (M[11]*M[24]-M[14]*M[21]);
	m_m2[8] = (M[16]*M[24]-M[19]*M[21]);
	m_m2[12] = (M[1]*M[24]-M[21]*M[4]);

	// Set image of e2^ni
	m_m2[1] = (-M[22]*M[9]+M[24]*M[7]);
	m_m2[5] = (M[12]*M[24]-M[14]*M[22]);
	m_m2[9] = (M[17]*M[24]-M[19]*M[22]);
	m_m2[13] = (M[2]*M[24]-M[22]*M[4]);

	// Set image of e3^ni
	m_m2[2] = (-M[23]*M[9]+M[24]*M[8]);
	m_m2[6] = (M[13]*M[24]-M[14]*M[23]);
	m_m2[10] = (M[18]*M[24]-M[19]*M[23]);
	m_m2[14] = (-M[23]*M[4]+M[24]*M[3]);

	// Set image of no^ni
	m_m2[3] = (-M[20]*M[9]+M[24]*M[5]);
	m_m2[7] = (M[10]*M[24]-M[14]*M[20]);
	m_m2[11] = (M[15]*M[24]-M[19]*M[20]);
	m_m2[15] = (M[0]*M[24]-M[20]*M[4]);

}
inline void grade1OM_E3GA::setTranspose(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[3] = M[1];
	m_m1[6] = M[2];

	// Set image of e2
	m_m1[1] = M[3];
	m_m1[4] = M[4];
	m_m1[7] = M[5];

	// Set image of e3
	m_m1[2] = M[6];
	m_m1[5] = M[7];
	m_m1[8] = M[8];

}
inline void grade1OM::setTranspose(const double *M)
{
	// Set image of no
	m_m1[0] = M[0];
	m_m1[5] = M[1];
	m_m1[10] = M[2];
	m_m1[15] = M[3];
	m_m1[20] = M[4];

	// Set image of e1
	m_m1[1] = M[5];
	m_m1[6] = M[6];
	m_m1[11] = M[7];
	m_m1[16] = M[8];
	m_m1[21] = M[9];

	// Set image of e2
	m_m1[2] = M[10];
	m_m1[7] = M[11];
	m_m1[12] = M[12];
	m_m1[17] = M[13];
	m_m1[22] = M[14];

	// Set image of e3
	m_m1[3] = M[15];
	m_m1[8] = M[16];
	m_m1[13] = M[17];
	m_m1[18] = M[18];
	m_m1[23] = M[19];

	// Set image of ni
	m_m1[4] = M[20];
	m_m1[9] = M[21];
	m_m1[14] = M[22];
	m_m1[19] = M[23];
	m_m1[24] = M[24];

}
inline void flatPointOM::setTranspose(const double *M)
{
	// Set image of e1^ni
	m_m2[0] = (-M[21]*M[9]+M[24]*M[6]);
	m_m2[4] = (-M[22]*M[9]+M[24]*M[7]);
	m_m2[8] = (-M[23]*M[9]+M[24]*M[8]);
	m_m2[12] = (-M[20]*M[9]+M[24]*M[5]);

	// Set image of e2^ni
	m_m2[1] = (M[11]*M[24]-M[14]*M[21]);
	m_m2[5] = (M[12]*M[24]-M[14]*M[22]);
	m_m2[9] = (M[13]*M[24]-M[14]*M[23]);
	m_m2[13] = (M[10]*M[24]-M[14]*M[20]);

	// Set image of e3^ni
	m_m2[2] = (M[16]*M[24]-M[19]*M[21]);
	m_m2[6] = (M[17]*M[24]-M[19]*M[22]);
	m_m2[10] = (M[18]*M[24]-M[19]*M[23]);
	m_m2[14] = (M[15]*M[24]-M[19]*M[20]);

	// Set image of no^ni
	m_m2[3] = (M[1]*M[24]-M[21]*M[4]);
	m_m2[7] = (M[2]*M[24]-M[22]*M[4]);
	m_m2[11] = (-M[23]*M[4]+M[24]*M[3]);
	m_m2[15] = (M[0]*M[24]-M[20]*M[4]);

}
inline vectorE3GA _vectorE3GA(const normalizedPoint &P)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			P.m_e1, // e1
			P.m_e2, // e2
			P.m_e3 // e3
		);

}
inline vectorE3GA _vectorE3GA(const dualSphere &S)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			S.m_e1, // e1
			S.m_e2, // e2
			S.m_e3 // e3
		);

}
inline bivectorE3GA _bivectorE3GA(const rotorE3GA &a)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline dualSphere pointToSphere(const normalizedPoint &P)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			1.0, // no
			P.m_e1, // e1
			P.m_e2, // e2
			P.m_e3, // e3
			P.m_ni // ni
		);

}
inline evenVersor _evenVersor(const pointPair &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			0.0, // scalar
			a.m_no_e1, // no_e1
			a.m_no_e2, // no_e2
			a.m_no_e3, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni, // e3_ni
			a.m_no_ni, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline double genrand() {
return (double)((double)(rand() & 0x7FFF) / 32768.0) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0 * 32768.0)); 
}
inline void genrand_seed(unsigned int seed) {
	srand(seed);
}

inline void genrand_timeSeed() {
	genrand_seed((unsigned int)time(NULL));
}

inline normalizedPoint cgaPoint(const vectorE3GA &a)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			(0.5*a.m_e1*a.m_e1+0.5*a.m_e2*a.m_e2+0.5*a.m_e3*a.m_e3) // ni
		);

}
inline normalizedPoint cgaPoint(const double a, const double b, const double c)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a, // e1
			b, // e2
			c, // e3
			(0.5*a*a+0.5*b*b+0.5*c*c) // ni
		);

}

inline normalizedPoint randomCgaPoint(double scale) {
	double ce1 = scale * (-1.0 + 2.0 * genrand());
	double ce2 = scale * (-1.0 + 2.0 * genrand());
	double ce3 = scale * (-1.0 + 2.0 * genrand());
	return cgaPoint(ce1, ce2, ce3);
}
inline double cgaPointDistance(const normalizedPoint &a, const normalizedPoint &b)
{
	return ::sqrt(::fabs(-2.0*(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3-a.m_ni-b.m_ni)));

}
inline double cgaPointDistance(const dualSphere &a, const dualSphere &b)
{
	return ::sqrt(::fabs(-2.0*(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3-a.m_ni*b.m_no-a.m_no*b.m_ni)));

}
inline vectorE3GA add(const vectorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3) // e3
		);

}
inline normalizedPoint add(const vectorE3GA &a, const normalizedPoint &b)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3), // e3
			b.m_ni // ni
		);

}
inline dualSphere add(const vectorE3GA &a, const dualSphere &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			b.m_no, // no
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3), // e3
			b.m_ni // ni
		);

}
inline bivectorE3GA add(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1) // e3_e1
		);

}
inline plane add(const plane &a, const plane &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			(a.m_e1_e2_e3_ni+b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(a.m_no_e2_e3_ni+b.m_no_e2_e3_ni), // no_e2_e3_ni
			(a.m_no_e1_e3_ni+b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_no_e1_e2_ni+b.m_no_e1_e2_ni) // no_e1_e2_ni
		);

}
inline circle add(const line &a, const circle &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			b.m_no_e1_e2, // no_e1_e2
			b.m_no_e1_e3, // no_e1_e3
			b.m_no_e2_e3, // no_e2_e3
			b.m_e1_e2_e3, // e1_e2_e3
			(-a.m_e1_no_ni+b.m_no_e1_ni), // no_e1_ni
			(-a.m_e2_no_ni+b.m_no_e2_ni), // no_e2_ni
			(a.m_e1_e2_ni+b.m_e1_e2_ni), // e1_e2_ni
			(-a.m_e3_no_ni+b.m_no_e3_ni), // no_e3_ni
			(a.m_e1_e3_ni+b.m_e1_e3_ni), // e1_e3_ni
			(a.m_e2_e3_ni+b.m_e2_e3_ni) // e2_e3_ni
		);

}
inline oddVersor add(const circle &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			b.m_e1, // e1
			b.m_e2, // e2
			b.m_e3, // e3
			0.0, // ni
			a.m_no_e1_e2, // no_e1_e2
			a.m_no_e1_e3, // no_e1_e3
			a.m_no_e2_e3, // no_e2_e3
			a.m_e1_e2_e3, // e1_e2_e3
			a.m_no_e1_ni, // no_e1_ni
			a.m_no_e2_ni, // no_e2_ni
			a.m_e1_e2_ni, // e1_e2_ni
			a.m_no_e3_ni, // no_e3_ni
			a.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline vectorE3GA add(const e1_t &a, const e2_t &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			1.0, // e1
			1.0, // e2
			0.0 // e3
		);

}
inline oddVersor add(const I5_t &a, const circle &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			b.m_no_e1_e2, // no_e1_e2
			b.m_no_e1_e3, // no_e1_e3
			b.m_no_e2_e3, // no_e2_e3
			b.m_e1_e2_e3, // e1_e2_e3
			b.m_no_e1_ni, // no_e1_ni
			b.m_no_e2_ni, // no_e2_ni
			b.m_e1_e2_ni, // e1_e2_ni
			b.m_no_e3_ni, // no_e3_ni
			b.m_e1_e3_ni, // e1_e3_ni
			b.m_e2_e3_ni, // e2_e3_ni
			1.0 // no_e1_e2_e3_ni
		);

}
inline vectorE3GA subtract(const vectorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_e1-b.m_e1), // e1
			(a.m_e2-b.m_e2), // e2
			(a.m_e3-b.m_e3) // e3
		);

}
inline bivectorE3GA subtract(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline oddVersor subtract(const oddVersor &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no-b.m_no), // no
			(a.m_e1-b.m_e1), // e1
			(a.m_e2-b.m_e2), // e2
			(a.m_e3-b.m_e3), // e3
			(a.m_ni-b.m_ni), // ni
			(a.m_no_e1_e2-b.m_no_e1_e2), // no_e1_e2
			(a.m_no_e1_e3-b.m_no_e1_e3), // no_e1_e3
			(a.m_no_e2_e3-b.m_no_e2_e3), // no_e2_e3
			(a.m_e1_e2_e3-b.m_e1_e2_e3), // e1_e2_e3
			(a.m_no_e1_ni-b.m_no_e1_ni), // no_e1_ni
			(a.m_no_e2_ni-b.m_no_e2_ni), // no_e2_ni
			(a.m_e1_e2_ni-b.m_e1_e2_ni), // e1_e2_ni
			(a.m_no_e3_ni-b.m_no_e3_ni), // no_e3_ni
			(a.m_e1_e3_ni-b.m_e1_e3_ni), // e1_e3_ni
			(a.m_e2_e3_ni-b.m_e2_e3_ni), // e2_e3_ni
			(a.m_no_e1_e2_e3_ni-b.m_no_e1_e2_e3_ni) // no_e1_e2_e3_ni
		);

}
inline oddVersor subtract(const line &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			-b.m_e1, // e1
			-b.m_e2, // e2
			-b.m_e3, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-a.m_e1_no_ni, // no_e1_ni
			-a.m_e2_no_ni, // no_e2_ni
			a.m_e1_e2_ni, // e1_e2_ni
			-a.m_e3_no_ni, // no_e3_ni
			a.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA subtract(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_scalar-b.m_scalar), // scalar
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline evenVersor subtract(const rotorE3GA &a, const noni_t &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			-1.0, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline oddVersor subtract(const I5_t &a, const circle &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			-b.m_no_e1_e2, // no_e1_e2
			-b.m_no_e1_e3, // no_e1_e3
			-b.m_no_e2_e3, // no_e2_e3
			-b.m_e1_e2_e3, // e1_e2_e3
			-b.m_no_e1_ni, // no_e1_ni
			-b.m_no_e2_ni, // no_e2_ni
			-b.m_e1_e2_ni, // e1_e2_ni
			-b.m_no_e3_ni, // no_e3_ni
			-b.m_e1_e3_ni, // e1_e3_ni
			-b.m_e2_e3_ni, // e2_e3_ni
			1.0 // no_e1_e2_e3_ni
		);

}
inline dualSphere applyOM(const om &a, const normalizedPoint &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_m1[0]+a.m_m1[1]*b.m_e1+a.m_m1[2]*b.m_e2+a.m_m1[3]*b.m_e3+a.m_m1[4]*b.m_ni), // no
			(a.m_m1[5]+a.m_m1[6]*b.m_e1+a.m_m1[7]*b.m_e2+a.m_m1[8]*b.m_e3+a.m_m1[9]*b.m_ni), // e1
			(a.m_m1[10]+a.m_m1[11]*b.m_e1+a.m_m1[12]*b.m_e2+a.m_m1[13]*b.m_e3+a.m_m1[14]*b.m_ni), // e2
			(a.m_m1[15]+a.m_m1[16]*b.m_e1+a.m_m1[17]*b.m_e2+a.m_m1[18]*b.m_e3+a.m_m1[19]*b.m_ni), // e3
			(a.m_m1[20]+a.m_m1[21]*b.m_e1+a.m_m1[22]*b.m_e2+a.m_m1[23]*b.m_e3+a.m_m1[24]*b.m_ni) // ni
		);

}
inline circle applyOM(const om &a, const circle &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			(a.m_m3[0]*b.m_no_e1_e2+a.m_m3[1]*b.m_no_e1_e3+a.m_m3[2]*b.m_no_e2_e3+a.m_m3[3]*b.m_e1_e2_e3+a.m_m3[4]*b.m_no_e1_ni+a.m_m3[5]*b.m_no_e2_ni+a.m_m3[6]*b.m_e1_e2_ni+a.m_m3[7]*b.m_no_e3_ni+a.m_m3[8]*b.m_e1_e3_ni+a.m_m3[9]*b.m_e2_e3_ni), // no_e1_e2
			(a.m_m3[10]*b.m_no_e1_e2+a.m_m3[11]*b.m_no_e1_e3+a.m_m3[12]*b.m_no_e2_e3+a.m_m3[13]*b.m_e1_e2_e3+a.m_m3[14]*b.m_no_e1_ni+a.m_m3[15]*b.m_no_e2_ni+a.m_m3[16]*b.m_e1_e2_ni+a.m_m3[17]*b.m_no_e3_ni+a.m_m3[18]*b.m_e1_e3_ni+a.m_m3[19]*b.m_e2_e3_ni), // no_e1_e3
			(a.m_m3[20]*b.m_no_e1_e2+a.m_m3[21]*b.m_no_e1_e3+a.m_m3[22]*b.m_no_e2_e3+a.m_m3[23]*b.m_e1_e2_e3+a.m_m3[24]*b.m_no_e1_ni+a.m_m3[25]*b.m_no_e2_ni+a.m_m3[26]*b.m_e1_e2_ni+a.m_m3[27]*b.m_no_e3_ni+a.m_m3[28]*b.m_e1_e3_ni+a.m_m3[29]*b.m_e2_e3_ni), // no_e2_e3
			(a.m_m3[30]*b.m_no_e1_e2+a.m_m3[31]*b.m_no_e1_e3+a.m_m3[32]*b.m_no_e2_e3+a.m_m3[33]*b.m_e1_e2_e3+a.m_m3[34]*b.m_no_e1_ni+a.m_m3[35]*b.m_no_e2_ni+a.m_m3[36]*b.m_e1_e2_ni+a.m_m3[37]*b.m_no_e3_ni+a.m_m3[38]*b.m_e1_e3_ni+a.m_m3[39]*b.m_e2_e3_ni), // e1_e2_e3
			(a.m_m3[40]*b.m_no_e1_e2+a.m_m3[41]*b.m_no_e1_e3+a.m_m3[42]*b.m_no_e2_e3+a.m_m3[43]*b.m_e1_e2_e3+a.m_m3[44]*b.m_no_e1_ni+a.m_m3[45]*b.m_no_e2_ni+a.m_m3[46]*b.m_e1_e2_ni+a.m_m3[47]*b.m_no_e3_ni+a.m_m3[48]*b.m_e1_e3_ni+a.m_m3[49]*b.m_e2_e3_ni), // no_e1_ni
			(a.m_m3[50]*b.m_no_e1_e2+a.m_m3[51]*b.m_no_e1_e3+a.m_m3[52]*b.m_no_e2_e3+a.m_m3[53]*b.m_e1_e2_e3+a.m_m3[54]*b.m_no_e1_ni+a.m_m3[55]*b.m_no_e2_ni+a.m_m3[56]*b.m_e1_e2_ni+a.m_m3[57]*b.m_no_e3_ni+a.m_m3[58]*b.m_e1_e3_ni+a.m_m3[59]*b.m_e2_e3_ni), // no_e2_ni
			(a.m_m3[60]*b.m_no_e1_e2+a.m_m3[61]*b.m_no_e1_e3+a.m_m3[62]*b.m_no_e2_e3+a.m_m3[63]*b.m_e1_e2_e3+a.m_m3[64]*b.m_no_e1_ni+a.m_m3[65]*b.m_no_e2_ni+a.m_m3[66]*b.m_e1_e2_ni+a.m_m3[67]*b.m_no_e3_ni+a.m_m3[68]*b.m_e1_e3_ni+a.m_m3[69]*b.m_e2_e3_ni), // e1_e2_ni
			(a.m_m3[70]*b.m_no_e1_e2+a.m_m3[71]*b.m_no_e1_e3+a.m_m3[72]*b.m_no_e2_e3+a.m_m3[73]*b.m_e1_e2_e3+a.m_m3[74]*b.m_no_e1_ni+a.m_m3[75]*b.m_no_e2_ni+a.m_m3[76]*b.m_e1_e2_ni+a.m_m3[77]*b.m_no_e3_ni+a.m_m3[78]*b.m_e1_e3_ni+a.m_m3[79]*b.m_e2_e3_ni), // no_e3_ni
			(a.m_m3[80]*b.m_no_e1_e2+a.m_m3[81]*b.m_no_e1_e3+a.m_m3[82]*b.m_no_e2_e3+a.m_m3[83]*b.m_e1_e2_e3+a.m_m3[84]*b.m_no_e1_ni+a.m_m3[85]*b.m_no_e2_ni+a.m_m3[86]*b.m_e1_e2_ni+a.m_m3[87]*b.m_no_e3_ni+a.m_m3[88]*b.m_e1_e3_ni+a.m_m3[89]*b.m_e2_e3_ni), // e1_e3_ni
			(a.m_m3[90]*b.m_no_e1_e2+a.m_m3[91]*b.m_no_e1_e3+a.m_m3[92]*b.m_no_e2_e3+a.m_m3[93]*b.m_e1_e2_e3+a.m_m3[94]*b.m_no_e1_ni+a.m_m3[95]*b.m_no_e2_ni+a.m_m3[96]*b.m_e1_e2_ni+a.m_m3[97]*b.m_no_e3_ni+a.m_m3[98]*b.m_e1_e3_ni+a.m_m3[99]*b.m_e2_e3_ni) // e2_e3_ni
		);

}
inline sphere applyOM(const om &a, const sphere &b)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_m4[20]*b.m_no_e1_e2_e3+a.m_m4[21]*b.m_no_e1_e2_ni+a.m_m4[22]*b.m_no_e1_e3_ni+a.m_m4[23]*b.m_no_e2_e3_ni+a.m_m4[24]*b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(a.m_m4[15]*b.m_no_e1_e2_e3+a.m_m4[16]*b.m_no_e1_e2_ni+a.m_m4[17]*b.m_no_e1_e3_ni+a.m_m4[18]*b.m_no_e2_e3_ni+a.m_m4[19]*b.m_e1_e2_e3_ni), // no_e2_e3_ni
			(a.m_m4[10]*b.m_no_e1_e2_e3+a.m_m4[11]*b.m_no_e1_e2_ni+a.m_m4[12]*b.m_no_e1_e3_ni+a.m_m4[13]*b.m_no_e2_e3_ni+a.m_m4[14]*b.m_e1_e2_e3_ni), // no_e1_e3_ni
			(a.m_m4[5]*b.m_no_e1_e2_e3+a.m_m4[6]*b.m_no_e1_e2_ni+a.m_m4[7]*b.m_no_e1_e3_ni+a.m_m4[8]*b.m_no_e2_e3_ni+a.m_m4[9]*b.m_e1_e2_e3_ni), // no_e1_e2_ni
			(a.m_m4[0]*b.m_no_e1_e2_e3+a.m_m4[1]*b.m_no_e1_e2_ni+a.m_m4[2]*b.m_no_e1_e3_ni+a.m_m4[3]*b.m_no_e2_e3_ni+a.m_m4[4]*b.m_e1_e2_e3_ni) // no_e1_e2_e3
		);

}
inline vectorE3GA applyOM(const grade1OM_E3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_m1[0]*b.m_e1+a.m_m1[1]*b.m_e2+a.m_m1[2]*b.m_e3), // e1
			(a.m_m1[3]*b.m_e1+a.m_m1[4]*b.m_e2+a.m_m1[5]*b.m_e3), // e2
			(a.m_m1[6]*b.m_e1+a.m_m1[7]*b.m_e2+a.m_m1[8]*b.m_e3) // e3
		);

}
inline vectorE3GA applyOM(const grade1OM_E3GA &a, const e1_t &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_m1[0], // e1
			a.m_m1[3], // e2
			a.m_m1[6] // e3
		);

}
inline double applyOM(const grade1OM_E3GA &a, const no_t &b)
{
	return 0.0;

}
inline vectorE3GA applyOM(const grade1OM_E3GA &a, const normalizedPoint &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_m1[0]*b.m_e1+a.m_m1[1]*b.m_e2+a.m_m1[2]*b.m_e3), // e1
			(a.m_m1[3]*b.m_e1+a.m_m1[4]*b.m_e2+a.m_m1[5]*b.m_e3), // e2
			(a.m_m1[6]*b.m_e1+a.m_m1[7]*b.m_e2+a.m_m1[8]*b.m_e3) // e3
		);

}
inline flatPoint applyOM(const flatPointOM &a, const flatPoint &b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			(a.m_m2[0]*b.m_e1_ni+a.m_m2[1]*b.m_e2_ni+a.m_m2[2]*b.m_e3_ni+a.m_m2[3]*b.m_no_ni), // e1_ni
			(a.m_m2[4]*b.m_e1_ni+a.m_m2[5]*b.m_e2_ni+a.m_m2[6]*b.m_e3_ni+a.m_m2[7]*b.m_no_ni), // e2_ni
			(a.m_m2[10]*b.m_e3_ni+a.m_m2[11]*b.m_no_ni+a.m_m2[8]*b.m_e1_ni+a.m_m2[9]*b.m_e2_ni), // e3_ni
			(a.m_m2[12]*b.m_e1_ni+a.m_m2[13]*b.m_e2_ni+a.m_m2[14]*b.m_e3_ni+a.m_m2[15]*b.m_no_ni) // no_ni
		);

}
inline flatPoint applyOM(const flatPointOM &a, const noni_t &b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			a.m_m2[3], // e1_ni
			a.m_m2[7], // e2_ni
			a.m_m2[11], // e3_ni
			a.m_m2[15] // no_ni
		);

}
inline vectorE3GA applyUnitVersor(const rotorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3) // e3
		);
}
inline dualSphere applyUnitVersor(const rotorE3GA &a, const normalizedPoint &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar), // no
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2*b.m_ni+a.m_e2_e3*a.m_e2_e3*b.m_ni+a.m_e3_e1*a.m_e3_e1*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni) // ni
		);
}
inline dualSphere applyUnitVersor(const rotorE3GA &a, const dualSphere &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_e1_e2*a.m_e1_e2*b.m_no+a.m_e2_e3*a.m_e2_e3*b.m_no+a.m_e3_e1*a.m_e3_e1*b.m_no+a.m_scalar*a.m_scalar*b.m_no), // no
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2*b.m_ni+a.m_e2_e3*a.m_e2_e3*b.m_ni+a.m_e3_e1*a.m_e3_e1*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni) // ni
		);
}
inline bivectorE3GA applyUnitVersor(const rotorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline line applyUnitVersor(const rotorE3GA &a, const line &b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_ni), // e1_e2_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_e2_e3_ni), // e2_e3_ni
			-(a.m_e1_e2*a.m_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e2_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e3_no_ni-a.m_scalar*a.m_scalar*b.m_e1_no_ni), // e1_no_ni
			-(a.m_e1_e2*a.m_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_no_ni-a.m_scalar*a.m_scalar*b.m_e2_no_ni), // e2_no_ni
			-(-a.m_e1_e2*a.m_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_no_ni-a.m_scalar*a.m_scalar*b.m_e3_no_ni) // e3_no_ni
		);
}
inline plane applyUnitVersor(const rotorE3GA &a, const plane &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_no_e1_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_no_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_no_e2_e3_ni), // no_e2_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e2_ni+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_no_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e2_ni) // no_e1_e2_ni
		);
}
inline flatPoint applyUnitVersor(const rotorE3GA &a, const noni_t &b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // no_ni
		);
}
inline dualSphere applyUnitVersor(const rotorE3GA &a, const no_t &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar), // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0 // ni
		);
}
inline dualPlane applyUnitVersor(const rotorE3GA &a, const ni_t &b)
{
	return dualPlane(dualPlane::coord_e1_e2_e3_ni,
			0.0, // e1
			0.0, // e2
			0.0, // e3
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // ni
		);
}
inline rotorE3GA applyUnitVersor(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1_e2*a.m_e1_e2*b.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_scalar+a.m_scalar*a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline pseudoscalar applyUnitVersor(const rotorE3GA &a, const I5_t &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // no_e1_e2_e3_ni
		);
}
inline dualSphere applyUnitVersor(const evenVersor &a, const vectorE3GA &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3), // no
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3) // ni
		);
}
inline dualSphere applyUnitVersor(const evenVersor &a, const normalizedPoint &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_e1*b.m_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e2*a.m_no_e2*b.m_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+2.0*a.m_no_e3*a.m_no_e3*b.m_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3+a.m_no_ni*a.m_no_ni+-2.0*a.m_no_ni*a.m_scalar+a.m_scalar*a.m_scalar), // no
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+2.0*a.m_e1_ni*a.m_no_ni+-2.0*a.m_e1_ni*a.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+2.0*a.m_e3_e1*a.m_e3_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e1_e3_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_ni*b.m_ni+2.0*a.m_no_e1*a.m_scalar*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e1_ni+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+-2.0*a.m_e2_e3*a.m_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_ni+-2.0*a.m_e2_ni*a.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_ni+2.0*a.m_no_e2*a.m_scalar*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+-2.0*a.m_e1_ni*a.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+2.0*a.m_e2_e3*a.m_e2_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3+2.0*a.m_e3_ni*a.m_no_ni+-2.0*a.m_e3_ni*a.m_scalar+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2+2.0*a.m_no_e3*a.m_no_ni*b.m_ni+2.0*a.m_no_e3*a.m_scalar*b.m_ni-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2*b.m_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e1_ni+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_ni+2.0*a.m_e2_ni*a.m_e2_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_e3_ni*a.m_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_ni+a.m_no_ni*a.m_no_ni*b.m_ni+2.0*a.m_no_ni*a.m_scalar*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni) // ni
		);
}
inline dualSphere applyUnitVersor(const evenVersor &a, const dualSphere &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(a.m_e1_e2*a.m_e1_e2*b.m_no+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_no+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_no+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_e1*b.m_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e2*a.m_no_e2*b.m_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+2.0*a.m_no_e3*a.m_no_e3*b.m_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3+a.m_no_ni*a.m_no_ni*b.m_no+-2.0*a.m_no_ni*a.m_scalar*b.m_no+a.m_scalar*a.m_scalar*b.m_no), // no
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_no+2.0*a.m_e1_e2*a.m_no_e2*b.m_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+2.0*a.m_e1_ni*a.m_no_ni*b.m_no+-2.0*a.m_e1_ni*a.m_scalar*b.m_no+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+2.0*a.m_e3_e1*a.m_e3_ni*b.m_no+-2.0*a.m_e3_e1*a.m_no_e3*b.m_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_ni*b.m_ni+2.0*a.m_no_e1*a.m_scalar*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e1_ni*b.m_no+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_no+2.0*a.m_e2_e3*a.m_no_e3*b.m_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_ni*b.m_no+-2.0*a.m_e2_ni*a.m_scalar*b.m_no+a.m_e3_e1*a.m_e3_e1*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_ni+2.0*a.m_no_e2*a.m_scalar*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_no+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_no+-2.0*a.m_e2_e3*a.m_no_e2*b.m_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3+2.0*a.m_e3_ni*a.m_no_ni*b.m_no+-2.0*a.m_e3_ni*a.m_scalar*b.m_no+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2+2.0*a.m_no_e3*a.m_no_ni*b.m_ni+2.0*a.m_no_e3*a.m_scalar*b.m_ni-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*a.m_e1_e2*b.m_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e1_ni*b.m_no+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_ni+2.0*a.m_e2_ni*a.m_e2_ni*b.m_no+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_e3_ni*a.m_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_ni+a.m_no_ni*a.m_no_ni*b.m_ni+2.0*a.m_no_ni*a.m_scalar*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni) // ni
		);
}
inline pointPair applyUnitVersor(const evenVersor &a, const bivectorE3GA &b)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			(2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3_e1+2.0*a.m_no_e3*a.m_scalar*b.m_e3_e1), // no_e1
			(2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3), // no_e2
			(2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3), // no_e3
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_e2-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_e1-a.m_no_ni*a.m_no_ni*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_e3-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e3_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_ni*a.m_no_ni*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_e1-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2+a.m_no_ni*a.m_no_ni*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1), // e3_e1
			(-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_scalar*b.m_e3_e1), // e1_ni
			(2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_ni*b.m_e1_e2+2.0*a.m_e1_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_e3), // e2_ni
			(2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3), // e3_ni
			(-2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e2_e3) // no_ni
		);
}
inline circle applyUnitVersor(const evenVersor &a, const line &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			(-2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e2_ni+-4.0*a.m_no_e1*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_no_ni+4.0*a.m_no_e1*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_e2_no_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2_e3*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e2_ni+-4.0*a.m_no_e2*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e2_ni), // no_e1_e2
			(2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e3_ni+4.0*a.m_no_e1*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_no_ni+-4.0*a.m_no_e1_e2_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e2*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e1_no_ni), // no_e1_e3
			(-2.0*a.m_e1_e2*a.m_no_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_no_e1*a.m_no_e1*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_no_ni+-4.0*a.m_no_e1*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_no_ni+4.0*a.m_no_e1*a.m_no_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e3_no_ni+4.0*a.m_no_e1_e2_e3*a.m_no_e2*b.m_e1_e2_ni+4.0*a.m_no_e1_e2_e3*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_no_ni+-2.0*a.m_no_e2*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e2*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_no_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_no_ni), // no_e2_e3
			(-2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e2_no_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_no_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e3*a.m_scalar*b.m_e1_e2_ni), // e1_e2_e3
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_no_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3_no_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e1_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_no_ni-a.m_scalar*a.m_scalar*b.m_e1_no_ni), // no_e1_ni
			(a.m_e1_e2*a.m_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1_no_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_no_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e2_no_ni-a.m_scalar*a.m_scalar*b.m_e2_no_ni), // no_e2_ni
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_scalar*b.m_e2_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e2_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_e3_e1*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_ni), // e1_e2_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2_no_ni+a.m_no_ni*a.m_no_ni*b.m_e3_no_ni-a.m_scalar*a.m_scalar*b.m_e3_no_ni), // no_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_scalar*b.m_e3_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_ni+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_e1_no_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_e2_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e2_ni*a.m_scalar*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_no_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e1_e2_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e2_e3_ni) // e2_e3_ni
		);
}
inline sphere applyUnitVersor(const evenVersor &a, const sphere &b)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_e1_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_e1_ni*a.m_no_ni*b.m_no_e2_e3_ni+-2.0*a.m_e1_ni*a.m_scalar*b.m_no_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_e2_ni*a.m_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_ni*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_scalar*b.m_no_e1_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_e3_ni*a.m_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_no_e1_e2_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_no_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e2_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e2_e3_ni+2.0*a.m_e3_e1*a.m_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_no_e1_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni*b.m_no_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e2_e3_ni), // no_e2_e3_ni
			(-a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e2_e3_ni+2.0*a.m_e2_e3*a.m_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_no_e3*b.m_no_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_no_e2_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni-a.m_no_ni*a.m_no_ni*b.m_no_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_no_e3*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_e3*a.m_e2_ni*b.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e3*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_no_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_no_e1_e3_ni+-2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e1_e2_ni+2.0*a.m_e3_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_no_e1_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e3*a.m_scalar*b.m_e1_e2_e3_ni-a.m_no_ni*a.m_no_ni*b.m_no_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e2_ni), // no_e1_e2_ni
			(a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2*b.m_no_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_e3+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_e3*a.m_no_e3*b.m_no_e1_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_e1*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_no_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e3*a.m_scalar*b.m_no_e1_e2_ni+a.m_no_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_no_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_no_e1_e2_e3) // no_e1_e2_e3
		);
}
inline dualSphere applyUnitVersor(const evenVersor &a, const ni_t &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(2.0*a.m_no_e1*a.m_no_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3+2.0*a.m_no_e2*a.m_no_e2+2.0*a.m_no_e3*a.m_no_e3), // no
			(2.0*a.m_e1_e2*a.m_no_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e3+2.0*a.m_no_e1*a.m_no_ni+2.0*a.m_no_e1*a.m_scalar+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3), // e1
			(-2.0*a.m_e1_e2*a.m_no_e1+2.0*a.m_e2_e3*a.m_no_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni+2.0*a.m_no_e2*a.m_no_ni+2.0*a.m_no_e2*a.m_scalar+2.0*a.m_no_e2_e3_ni*a.m_no_e3), // e2
			(2.0*a.m_e1_e2*a.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e2+2.0*a.m_e3_e1*a.m_no_e1+-2.0*a.m_no_e1*a.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni+2.0*a.m_no_e3*a.m_no_ni+2.0*a.m_no_e3*a.m_scalar), // e3
			(a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_ni+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2_e3_ni+a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_ni*a.m_no_ni+2.0*a.m_no_ni*a.m_scalar+a.m_scalar*a.m_scalar) // ni
		);
}
inline evenVersor applyUnitVersor(const evenVersor &a, const rotorE3GA &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_e1_e2*a.m_e1_e2*b.m_scalar+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_scalar+2.0*a.m_e1_ni*a.m_no_e1*b.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_scalar+2.0*a.m_e2_ni*a.m_no_e2*b.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_scalar+2.0*a.m_e3_ni*a.m_no_e3*b.m_scalar-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_scalar-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_scalar-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_scalar-a.m_no_ni*a.m_no_ni*b.m_scalar+a.m_scalar*a.m_scalar*b.m_scalar), // scalar
			(2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3_e1+2.0*a.m_no_e3*a.m_scalar*b.m_e3_e1), // no_e1
			(2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3), // no_e2
			(2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3), // no_e3
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_e2-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_e1-a.m_no_ni*a.m_no_ni*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_e3-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e3_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_ni*a.m_no_ni*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_e1-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2+a.m_no_ni*a.m_no_ni*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1), // e3_e1
			(-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_scalar*b.m_e3_e1), // e1_ni
			(2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_ni*b.m_e1_e2+2.0*a.m_e1_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_e3), // e2_ni
			(2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3), // e3_ni
			(-2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e2_e3), // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline pseudoscalar applyUnitVersor(const evenVersor &a, const I5i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			(-a.m_e1_e2*a.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1-a.m_e2_e3*a.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2-a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_ni*a.m_no_ni-a.m_scalar*a.m_scalar) // no_e1_e2_e3_ni
		);
}
inline dualSphere applyUnitVersor(const oddVersor &a, const vectorE3GA &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2), // no
			(a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2-a.m_e2*a.m_e2*b.m_e1+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1-a.m_e3*a.m_e3*b.m_e1+2.0*a.m_ni*a.m_no*b.m_e1+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1), // e1
			(-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2-a.m_e3*a.m_e3*b.m_e2+2.0*a.m_ni*a.m_no*b.m_e2+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2), // e2
			(-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3+a.m_e3*a.m_e3*b.m_e3+2.0*a.m_ni*a.m_no*b.m_e3+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3), // e3
			(2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_e3*a.m_ni*b.m_e3+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3) // ni
		);
}
inline dualSphere applyUnitVersor(const oddVersor &a, const normalizedPoint &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(-a.m_e1*a.m_e1+2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+-2.0*a.m_e1*a.m_no_e1_ni-a.m_e1_e2_e3*a.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1-a.m_e2*a.m_e2+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e2*a.m_no_e2_ni-a.m_e3*a.m_e3+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e3_ni+-2.0*a.m_no*a.m_no*b.m_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1-a.m_no_e1_ni*a.m_no_e1_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni), // no
			(a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+-2.0*a.m_e1*a.m_ni+-2.0*a.m_e1*a.m_no*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e2+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni+-2.0*a.m_e1_e3_ni*a.m_e3+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni-a.m_e2*a.m_e2*b.m_e1+-2.0*a.m_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e1+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e1_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1), // e1
			(-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_ni+2.0*a.m_e1*a.m_e2*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+-2.0*a.m_e2*a.m_ni+-2.0*a.m_e2*a.m_no*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e3+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni-a.m_e3*a.m_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e2+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e2_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2), // e2
			(-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_no_e1_e3*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_ni-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e2_e3_ni+2.0*a.m_e2*a.m_e3*b.m_e2+2.0*a.m_e2*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_ni+a.m_e3*a.m_e3*b.m_e3+-2.0*a.m_e3*a.m_ni+-2.0*a.m_e3*a.m_no*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e3+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3), // e3
			(-a.m_e1*a.m_e1*b.m_ni+2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1*a.m_no_e1_ni*b.m_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e1_e2_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1-a.m_e2*a.m_e2*b.m_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+2.0*a.m_e2*a.m_no_e2_ni*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2-a.m_e3*a.m_e3*b.m_ni+2.0*a.m_e3*a.m_ni*b.m_e3+2.0*a.m_e3*a.m_no_e3_ni*b.m_ni+-2.0*a.m_ni*a.m_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_ni) // ni
		);
}
inline dualSphere applyUnitVersor(const oddVersor &a, const dualSphere &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(-a.m_e1*a.m_e1*b.m_no+2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+-2.0*a.m_e1*a.m_no_e1_ni*b.m_no-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1-a.m_e2*a.m_e2*b.m_no+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e2*a.m_no_e2_ni*b.m_no-a.m_e3*a.m_e3*b.m_no+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e3_ni*b.m_no+-2.0*a.m_no*a.m_no*b.m_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1-a.m_no_e1_ni*a.m_no_e1_ni*b.m_no+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2-a.m_no_e2_ni*a.m_no_e2_ni*b.m_no-a.m_no_e3_ni*a.m_no_e3_ni*b.m_no), // no
			(a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+-2.0*a.m_e1*a.m_ni*b.m_no+-2.0*a.m_e1*a.m_no*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_no+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_no+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_no-a.m_e2*a.m_e2*b.m_e1+-2.0*a.m_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e1+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e1_ni*b.m_no+2.0*a.m_no*a.m_no_e1_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1), // e1
			(-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_ni*b.m_no+2.0*a.m_e1*a.m_e2*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_no+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+-2.0*a.m_e2*a.m_ni*b.m_no+-2.0*a.m_e2*a.m_no*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_no+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_no-a.m_e3*a.m_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e2+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e2_ni*b.m_no+2.0*a.m_no*a.m_no_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2), // e2
			(-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_no+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_no_e1_e3*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_no-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e2_e3_ni*b.m_no+2.0*a.m_e2*a.m_e3*b.m_e2+2.0*a.m_e2*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_no+a.m_e3*a.m_e3*b.m_e3+-2.0*a.m_e3*a.m_ni*b.m_no+-2.0*a.m_e3*a.m_no*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e3+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_no+2.0*a.m_no*a.m_no_e3_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3), // e3
			(-a.m_e1*a.m_e1*b.m_ni+2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1*a.m_no_e1_ni*b.m_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e1_e3_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1-a.m_e2*a.m_e2*b.m_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+2.0*a.m_e2*a.m_no_e2_ni*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2-a.m_e3*a.m_e3*b.m_ni+2.0*a.m_e3*a.m_ni*b.m_e3+2.0*a.m_e3*a.m_no_e3_ni*b.m_ni+-2.0*a.m_ni*a.m_ni*b.m_no+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_ni) // ni
		);
}
inline pointPair applyUnitVersor(const oddVersor &a, const bivectorE3GA &b)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			(-2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_e2*a.m_no*b.m_e1_e2+-2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_no*b.m_e3_e1+2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_no*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_e3+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2), // no_e1
			(-2.0*a.m_e1*a.m_no*b.m_e1_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_no*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e2*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e3*a.m_no*b.m_e2_e3+2.0*a.m_e3*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_e3+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_e3), // no_e2
			(2.0*a.m_e1*a.m_no*b.m_e3_e1+-2.0*a.m_e1*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_no*b.m_e2_e3+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e2+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_no*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2_e3), // no_e3
			(-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1_e2-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2+a.m_e3*a.m_e3*b.m_e1_e2+-2.0*a.m_ni*a.m_no*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3_e1-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2), // e1_e2
			(a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e3_e1-a.m_e2*a.m_e2*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2_e3-a.m_e3*a.m_e3*b.m_e2_e3+-2.0*a.m_ni*a.m_no*b.m_e2_e3+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1_e2-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e3_e1-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_e2+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_e3), // e2_e3
			-(a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3_e1+a.m_e3*a.m_e3*b.m_e3_e1+2.0*a.m_ni*a.m_no*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_e3*b.m_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3_e1+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3_e1), // e3_e1
			(2.0*a.m_e1*a.m_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1*a.m_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e2_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_e2*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e2_e3+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2*a.m_ni*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_e3*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e3*a.m_ni*b.m_e3_e1+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3_e1), // e1_ni
			(-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1*a.m_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_e3*a.m_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_ni*a.m_no_e3_ni*b.m_e2_e3), // e2_ni
			(2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_ni*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_e3*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_e2*a.m_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2_e3), // e3_ni
			(2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_no_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_e2*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2_e3) // no_ni
		);
}
inline circle applyUnitVersor(const oddVersor &a, const line &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			(-2.0*a.m_e1*a.m_no*b.m_e2_no_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e2*a.m_no*b.m_e1_no_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_no*a.m_no*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+4.0*a.m_no*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e2_no_ni+-4.0*a.m_no*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e2_ni+-4.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_no_ni), // no_e1_e2
			(-2.0*a.m_e1*a.m_no*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_no_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_no_ni+2.0*a.m_e3*a.m_no*b.m_e1_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no*b.m_e1_e3_ni+-4.0*a.m_no*a.m_no_e1_e2*b.m_e2_e3_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e3_no_ni+4.0*a.m_no*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_no_ni), // no_e1_e3
			(2.0*a.m_e1*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e3*a.m_no*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no*b.m_e2_e3_ni+4.0*a.m_no*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e3_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_no_ni+-4.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e3_no_ni), // no_e2_e3
			(-2.0*a.m_e1*a.m_no*b.m_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_e2*a.m_no*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2*a.m_no_e1_ni*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_e1_no_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e3_ni), // e1_e2_e3
			(-a.m_e1*a.m_e1*b.m_e1_no_ni+-2.0*a.m_e1*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+a.m_e2*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e2*a.m_no*b.m_e1_e2_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1_no_ni+a.m_e3*a.m_e3*b.m_e1_no_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_ni*a.m_no*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_no_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni), // no_e1_ni
			(a.m_e1*a.m_e1*b.m_e2_no_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e2*b.m_e1_no_ni+2.0*a.m_e1*a.m_no*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_e3_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1_no_ni-a.m_e2*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e2*a.m_e3*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+a.m_e3*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no*b.m_e2_e3_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e3_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3_no_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni), // no_e2_ni
			(a.m_e1*a.m_e1*b.m_e1_e2_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_e1*a.m_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e2_e3_ni+2.0*a.m_e1*a.m_ni*b.m_e2_no_ni+-2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_e3*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni+a.m_e2*a.m_e2*b.m_e1_e2_ni+2.0*a.m_e2*a.m_e3*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_ni*b.m_e1_no_ni+-2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e1_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni-a.m_e3*a.m_e3*b.m_e1_e2_ni+2.0*a.m_e3*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e2_ni+-2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e2_ni*b.m_e1_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2_ni), // e1_e2_ni
			(a.m_e1*a.m_e1*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e1_no_ni+2.0*a.m_e1*a.m_no*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e2_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+a.m_e2*a.m_e2*b.m_e3_no_ni+-2.0*a.m_e2*a.m_e3*b.m_e2_no_ni+2.0*a.m_e2*a.m_no*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni-a.m_e3*a.m_e3*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2_no_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni), // no_e3_ni
			(a.m_e1*a.m_e1*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_e1*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1*a.m_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni-a.m_e2*a.m_e2*b.m_e1_e3_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e2*a.m_e3*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+a.m_e3*a.m_e3*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_ni*b.m_e1_no_ni+-2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_ni*a.m_no_e3_ni*b.m_e1_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1*a.m_e1*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_e1*a.m_e2*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+a.m_e2*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2*a.m_ni*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni+a.m_e3*a.m_e3*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_ni*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e3_ni*b.m_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_ni*a.m_no_e3_ni*b.m_e2_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_e3_ni) // e2_e3_ni
		);
}
inline sphere applyUnitVersor(const oddVersor &a, const plane &b)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(-a.m_e1*a.m_e1*b.m_e1_e2_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e1_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1*a.m_ni*b.m_no_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni-a.m_e2*a.m_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2*a.m_ni*b.m_no_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni-a.m_e3*a.m_e3*b.m_e1_e2_e3_ni+2.0*a.m_e3*a.m_ni*b.m_no_e1_e2_ni+2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_no_e2_e3_ni+2.0*a.m_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(a.m_e1*a.m_e1*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_e2*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_no*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni-a.m_e2*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni-a.m_e3*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni), // no_e2_e3_ni
			(-a.m_e1*a.m_e1*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+a.m_e2*a.m_e2*b.m_no_e1_e3_ni+-2.0*a.m_e2*a.m_e3*b.m_no_e1_e2_ni+2.0*a.m_e2*a.m_no*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_no_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni-a.m_e3*a.m_e3*b.m_no_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+-2.0*a.m_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni), // no_e1_e3_ni
			(-a.m_e1*a.m_e1*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_no_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no*b.m_no_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni-a.m_e2*a.m_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2*a.m_e3*b.m_no_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no*b.m_no_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+a.m_e3*a.m_e3*b.m_no_e1_e2_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni), // no_e1_e2_ni
			(2.0*a.m_e1*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2*a.m_no*b.m_no_e1_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e3*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_no*a.m_no*b.m_e1_e2_e3_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_no_e2_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_no_e1_e3_ni) // no_e1_e2_e3
		);
}
inline vectorE3GA applyVersor(const rotorE3GA &a, const vectorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_) // e3
		);
}
inline dualSphere applyVersor(const rotorE3GA &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_), // no
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2*b.m_ni+a.m_e2_e3*a.m_e2_e3*b.m_ni+a.m_e3_e1*a.m_e3_e1*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni))/(_n2_) // ni
		);
}
inline dualSphere applyVersor(const rotorE3GA &a, const dualSphere &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((a.m_e1_e2*a.m_e1_e2*b.m_no+a.m_e2_e3*a.m_e2_e3*b.m_no+a.m_e3_e1*a.m_e3_e1*b.m_no+a.m_scalar*a.m_scalar*b.m_no))/(_n2_), // no
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2*b.m_ni+a.m_e2_e3*a.m_e2_e3*b.m_ni+a.m_e3_e1*a.m_e3_e1*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni))/(_n2_) // ni
		);
}
inline bivectorE3GA applyVersor(const rotorE3GA &a, const bivectorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline line applyVersor(const rotorE3GA &a, const line &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_ni))/(_n2_), // e1_e2_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e3_ni))/(_n2_), // e1_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_e2_e3_ni))/(_n2_), // e2_e3_ni
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e2_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e3_no_ni-a.m_scalar*a.m_scalar*b.m_e1_no_ni))/(_n2_), // e1_no_ni
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_no_ni-a.m_scalar*a.m_scalar*b.m_e2_no_ni))/(_n2_), // e2_no_ni
			(-(-a.m_e1_e2*a.m_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_no_ni-a.m_scalar*a.m_scalar*b.m_e3_no_ni))/(_n2_) // e3_no_ni
		);
}
inline plane applyVersor(const rotorE3GA &a, const plane &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_e3_ni))/(_n2_), // e1_e2_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_no_e1_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_no_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_no_e2_e3_ni))/(_n2_), // no_e2_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e2_ni+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e3_ni))/(_n2_), // no_e1_e3_ni
			((a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_no_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e2_ni))/(_n2_) // no_e1_e2_ni
		);
}
inline flatPoint applyVersor(const rotorE3GA &a, const noni_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			(0.0)/(_n2_), // e1_ni
			(0.0)/(_n2_), // e2_ni
			(0.0)/(_n2_), // e3_ni
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // no_ni
		);
}
inline dualSphere applyVersor(const rotorE3GA &a, const no_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_), // no
			(0.0)/(_n2_), // e1
			(0.0)/(_n2_), // e2
			(0.0)/(_n2_), // e3
			(0.0)/(_n2_) // ni
		);
}
inline dualPlane applyVersor(const rotorE3GA &a, const ni_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return dualPlane(dualPlane::coord_e1_e2_e3_ni,
			(0.0)/(_n2_), // e1
			(0.0)/(_n2_), // e2
			(0.0)/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // ni
		);
}
inline rotorE3GA applyVersor(const rotorE3GA &a, const rotorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			((a.m_e1_e2*a.m_e1_e2*b.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_scalar+a.m_scalar*a.m_scalar*b.m_scalar))/(_n2_), // scalar
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline pseudoscalar applyVersor(const rotorE3GA &a, const I5_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // no_e1_e2_e3_ni
		);
}
inline dualSphere applyVersor(const evenVersor &a, const vectorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3))/(_n2_), // no
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3))/(_n2_) // ni
		);
}
inline dualSphere applyVersor(const evenVersor &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_e1*b.m_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e2*a.m_no_e2*b.m_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+2.0*a.m_no_e3*a.m_no_e3*b.m_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3+a.m_no_ni*a.m_no_ni+-2.0*a.m_no_ni*a.m_scalar+a.m_scalar*a.m_scalar))/(_n2_), // no
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+2.0*a.m_e1_ni*a.m_no_ni+-2.0*a.m_e1_ni*a.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+2.0*a.m_e3_e1*a.m_e3_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e1_e3_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_ni*b.m_ni+2.0*a.m_no_e1*a.m_scalar*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e1_ni+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+-2.0*a.m_e2_e3*a.m_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_ni+-2.0*a.m_e2_ni*a.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_ni+2.0*a.m_no_e2*a.m_scalar*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+-2.0*a.m_e1_ni*a.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+2.0*a.m_e2_e3*a.m_e2_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3+2.0*a.m_e3_ni*a.m_no_ni+-2.0*a.m_e3_ni*a.m_scalar+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2+2.0*a.m_no_e3*a.m_no_ni*b.m_ni+2.0*a.m_no_e3*a.m_scalar*b.m_ni-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2*b.m_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e1_ni+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_ni+2.0*a.m_e2_ni*a.m_e2_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_e3_ni*a.m_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_ni+a.m_no_ni*a.m_no_ni*b.m_ni+2.0*a.m_no_ni*a.m_scalar*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni))/(_n2_) // ni
		);
}
inline dualSphere applyVersor(const evenVersor &a, const dualSphere &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((a.m_e1_e2*a.m_e1_e2*b.m_no+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_no+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_no+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_e1*b.m_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1+2.0*a.m_no_e1*a.m_scalar*b.m_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e2*a.m_no_e2*b.m_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2+2.0*a.m_no_e2*a.m_scalar*b.m_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2+2.0*a.m_no_e3*a.m_no_e3*b.m_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3+2.0*a.m_no_e3*a.m_scalar*b.m_e3+a.m_no_ni*a.m_no_ni*b.m_no+-2.0*a.m_no_ni*a.m_scalar*b.m_no+a.m_scalar*a.m_scalar*b.m_no))/(_n2_), // no
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_no+2.0*a.m_e1_e2*a.m_no_e2*b.m_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3+2.0*a.m_e1_ni*a.m_no_ni*b.m_no+-2.0*a.m_e1_ni*a.m_scalar*b.m_no+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1+2.0*a.m_e3_e1*a.m_e3_ni*b.m_no+-2.0*a.m_e3_e1*a.m_no_e3*b.m_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_no_e1*a.m_no_ni*b.m_ni+2.0*a.m_no_e1*a.m_scalar*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1-a.m_no_ni*a.m_no_ni*b.m_e1+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e1_ni*b.m_no+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_no+2.0*a.m_e2_e3*a.m_no_e3*b.m_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3+2.0*a.m_e2_ni*a.m_no_ni*b.m_no+-2.0*a.m_e2_ni*a.m_scalar*b.m_no+a.m_e3_e1*a.m_e3_e1*b.m_e2+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_ni+2.0*a.m_no_e2*a.m_scalar*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3-a.m_no_ni*a.m_no_ni*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_no+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_no+-2.0*a.m_e2_e3*a.m_no_e2*b.m_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3+2.0*a.m_e3_ni*a.m_no_ni*b.m_no+-2.0*a.m_e3_ni*a.m_scalar*b.m_no+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2+2.0*a.m_no_e3*a.m_no_ni*b.m_ni+2.0*a.m_no_e3*a.m_scalar*b.m_ni-a.m_no_ni*a.m_no_ni*b.m_e3+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2*b.m_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1+2.0*a.m_e1_ni*a.m_e1_ni*b.m_no+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e1+a.m_e2_e3*a.m_e2_e3*b.m_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_ni+2.0*a.m_e2_ni*a.m_e2_ni*b.m_no+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e2+a.m_e3_e1*a.m_e3_e1*b.m_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_ni+2.0*a.m_e3_ni*a.m_e3_ni*b.m_no+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_ni+a.m_no_ni*a.m_no_ni*b.m_ni+2.0*a.m_no_ni*a.m_scalar*b.m_ni+a.m_scalar*a.m_scalar*b.m_ni))/(_n2_) // ni
		);
}
inline pointPair applyVersor(const evenVersor &a, const bivectorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			((2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3_e1+2.0*a.m_no_e3*a.m_scalar*b.m_e3_e1))/(_n2_), // no_e1
			((2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3))/(_n2_), // no_e2
			((2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3))/(_n2_), // no_e3
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_e2-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_e1-a.m_no_ni*a.m_no_ni*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_e3-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e3_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_ni*a.m_no_ni*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_e1-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2+a.m_no_ni*a.m_no_ni*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_), // e3_e1
			((-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_scalar*b.m_e3_e1))/(_n2_), // e1_ni
			((2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_ni*b.m_e1_e2+2.0*a.m_e1_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_ni
			((2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3))/(_n2_), // e3_ni
			((-2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e2_e3))/(_n2_) // no_ni
		);
}
inline circle applyVersor(const evenVersor &a, const line &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			((-2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e2_ni+-4.0*a.m_no_e1*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_no_ni+4.0*a.m_no_e1*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_e2_no_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2_e3*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e2_ni+-4.0*a.m_no_e2*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e2_ni))/(_n2_), // no_e1_e2
			((2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e3_ni+4.0*a.m_no_e1*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_no_ni+-4.0*a.m_no_e1_e2_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e2*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e1_no_ni))/(_n2_), // no_e1_e3
			((-2.0*a.m_e1_e2*a.m_no_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_no_e1*a.m_no_e1*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_no_ni+-4.0*a.m_no_e1*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_no_ni+4.0*a.m_no_e1*a.m_no_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e3_no_ni+4.0*a.m_no_e1_e2_e3*a.m_no_e2*b.m_e1_e2_ni+4.0*a.m_no_e1_e2_e3*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_no_ni+-2.0*a.m_no_e2*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_no_e2*a.m_scalar*b.m_e3_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_no_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_no_ni))/(_n2_), // no_e2_e3
			((-2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e2_no_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_no_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e3*a.m_scalar*b.m_e1_e2_ni))/(_n2_), // e1_e2_e3
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_no_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e3_no_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e1_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_no_ni-a.m_scalar*a.m_scalar*b.m_e1_no_ni))/(_n2_), // no_e1_ni
			((a.m_e1_e2*a.m_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_no_ni+2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_no_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1_no_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2_ni+2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_no_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e2_no_ni-a.m_scalar*a.m_scalar*b.m_e2_no_ni))/(_n2_), // no_e2_ni
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_scalar*b.m_e2_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_e2_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_e3_e1*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_ni))/(_n2_), // e1_e2_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3_ni+-2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_no_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e3_no_ni+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_no_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_no_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e2_no_ni+a.m_no_ni*a.m_no_ni*b.m_e3_no_ni-a.m_scalar*a.m_scalar*b.m_e3_no_ni))/(_n2_), // no_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_scalar*b.m_e3_no_ni-a.m_e2_e3*a.m_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e1_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3_ni+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e3_ni+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_e1_no_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e1_e2_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e3_ni))/(_n2_), // e1_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_e3_no_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_no_ni+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_no_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2_ni*a.m_no_ni*b.m_e3_no_ni+2.0*a.m_e2_ni*a.m_scalar*b.m_e3_no_ni-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_ni*b.m_e1_e2_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_no_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_no_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e1_e2_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e2_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e2_e3_ni))/(_n2_) // e2_e3_ni
		);
}
inline sphere applyVersor(const evenVersor &a, const sphere &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_e1_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_e1_ni*a.m_no_ni*b.m_no_e2_e3_ni+-2.0*a.m_e1_ni*a.m_scalar*b.m_no_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3*a.m_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_e2_ni*a.m_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_ni*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_scalar*b.m_no_e1_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3_ni+-2.0*a.m_e3_e1*a.m_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_e3_ni*a.m_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_scalar*b.m_no_e1_e2_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_ni*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_ni*a.m_scalar*b.m_e1_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_e1_e2_e3_ni))/(_n2_), // e1_e2_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2*a.m_scalar*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_no_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e1_e3_ni+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e2_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e2_e3_ni+2.0*a.m_e3_e1*a.m_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e3_e1*a.m_scalar*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_no_e1_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni*b.m_no_e2_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e2_e3_ni))/(_n2_), // no_e2_e3_ni
			((-a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2*a.m_e1_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2*a.m_scalar*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_no_e2_e3_ni+2.0*a.m_e2_e3*a.m_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e2_ni+2.0*a.m_e2_ni*a.m_no_e1*b.m_no_e2_e3_ni+-2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_no_e3*b.m_no_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e3_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_no_e2_e3_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_no_e1_e2_ni-a.m_no_ni*a.m_no_ni*b.m_no_e1_e3_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e3_ni))/(_n2_), // no_e1_e3_ni
			((a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_ni*a.m_e3_e1*b.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_no_e1_e2_ni+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_no_e3*b.m_no_e2_e3_ni-a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e2_e3*a.m_e2_ni*b.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3*a.m_scalar*b.m_no_e1_e3_ni+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e2_ni*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_ni*a.m_no_e3*b.m_no_e1_e3_ni-a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_ni+2.0*a.m_e3_e1*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_e3_e1*a.m_scalar*b.m_no_e2_e3_ni+-2.0*a.m_e3_ni*a.m_no_e1*b.m_no_e2_e3_ni+2.0*a.m_e3_ni*a.m_no_e2*b.m_no_e1_e3_ni+-2.0*a.m_e3_ni*a.m_no_e3*b.m_no_e1_e2_ni+2.0*a.m_e3_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_no_e1_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e3*a.m_no_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e3*a.m_scalar*b.m_e1_e2_e3_ni-a.m_no_ni*a.m_no_ni*b.m_no_e1_e2_ni+a.m_scalar*a.m_scalar*b.m_no_e1_e2_ni))/(_n2_), // no_e1_e2_ni
			((a.m_e1_e2*a.m_e1_e2*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_no_e1*b.m_no_e1_e3_ni+2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2*b.m_no_e2_e3_ni+a.m_e2_e3*a.m_e2_e3*b.m_no_e1_e2_e3+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e2_e3*a.m_no_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e2_e3*a.m_no_e3*b.m_no_e1_e3_ni+a.m_e3_e1*a.m_e3_e1*b.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1*b.m_no_e1_e2_ni+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e3_e1*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_e3_e1*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1*b.m_e1_e2_e3_ni+2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1*a.m_no_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1*a.m_scalar*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_no_e2_e3_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_no_e2_e3_ni+2.0*a.m_no_e2*a.m_no_e2*b.m_e1_e2_e3_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2*a.m_no_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e2*a.m_scalar*b.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e3*a.m_no_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e3*a.m_no_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e3*a.m_scalar*b.m_no_e1_e2_ni+a.m_no_ni*a.m_no_ni*b.m_no_e1_e2_e3+-2.0*a.m_no_ni*a.m_scalar*b.m_no_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_no_e1_e2_e3))/(_n2_) // no_e1_e2_e3
		);
}
inline dualSphere applyVersor(const evenVersor &a, const ni_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((2.0*a.m_no_e1*a.m_no_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_e3+2.0*a.m_no_e2*a.m_no_e2+2.0*a.m_no_e3*a.m_no_e3))/(_n2_), // no
			((2.0*a.m_e1_e2*a.m_no_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3+-2.0*a.m_e3_e1*a.m_no_e3+2.0*a.m_no_e1*a.m_no_ni+2.0*a.m_no_e1*a.m_scalar+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_ni*a.m_no_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3))/(_n2_), // e1
			((-2.0*a.m_e1_e2*a.m_no_e1+2.0*a.m_e2_e3*a.m_no_e3+2.0*a.m_e3_e1*a.m_no_e1_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni+2.0*a.m_no_e2*a.m_no_ni+2.0*a.m_no_e2*a.m_scalar+2.0*a.m_no_e2_e3_ni*a.m_no_e3))/(_n2_), // e2
			((2.0*a.m_e1_e2*a.m_no_e1_e2_e3+-2.0*a.m_e2_e3*a.m_no_e2+2.0*a.m_e3_e1*a.m_no_e1+-2.0*a.m_no_e1*a.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni+-2.0*a.m_no_e2*a.m_no_e2_e3_ni+2.0*a.m_no_e3*a.m_no_ni+2.0*a.m_no_e3*a.m_scalar))/(_n2_), // e3
			((a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2*a.m_no_e1_e2_ni+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2_e3_ni+a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_e1*a.m_no_e1_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_ni*a.m_no_ni+2.0*a.m_no_ni*a.m_scalar+a.m_scalar*a.m_scalar))/(_n2_) // ni
		);
}
inline evenVersor applyVersor(const evenVersor &a, const rotorE3GA &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			((a.m_e1_e2*a.m_e1_e2*b.m_scalar+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_scalar+2.0*a.m_e1_ni*a.m_no_e1*b.m_scalar+a.m_e2_e3*a.m_e2_e3*b.m_scalar+2.0*a.m_e2_ni*a.m_no_e2*b.m_scalar+a.m_e3_e1*a.m_e3_e1*b.m_scalar+2.0*a.m_e3_ni*a.m_no_e3*b.m_scalar-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_scalar-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_scalar-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_scalar-a.m_no_ni*a.m_no_ni*b.m_scalar+a.m_scalar*a.m_scalar*b.m_scalar))/(_n2_), // scalar
			((2.0*a.m_e1_e2*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e1*b.m_e2_e3+2.0*a.m_e2_e3*a.m_no_e2*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e2_e3+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e2*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e3*a.m_no_ni*b.m_e3_e1+2.0*a.m_no_e3*a.m_scalar*b.m_e3_e1))/(_n2_), // no_e1
			((2.0*a.m_e1_e2*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_no_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e2*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_e1*a.m_no_e3*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e2*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_no_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_no_e3*a.m_scalar*b.m_e2_e3))/(_n2_), // no_e2
			((2.0*a.m_e1_e2*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_e2*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_no_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e1*a.m_no_ni*b.m_e3_e1+-2.0*a.m_no_e1*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3*a.m_no_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e3*b.m_e1_e2+-2.0*a.m_no_e1_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_e3*b.m_e3_e1+-2.0*a.m_no_e2*a.m_no_ni*b.m_e2_e3+2.0*a.m_no_e2*a.m_scalar*b.m_e2_e3+-2.0*a.m_no_e2_e3_ni*a.m_no_e3*b.m_e2_e3))/(_n2_), // no_e3
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e2_e3-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e3*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3*b.m_e1_e2-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e3_e1-a.m_no_ni*a.m_no_ni*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e3*b.m_e1_e2+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e2_e3-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3*b.m_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e3_e1+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_ni*b.m_e1_e2-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_ni*a.m_no_ni*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e2*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_e3*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_e3*b.m_e3_e1-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_ni*a.m_no_ni*b.m_e2_e3+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_no_e2_e3_ni*a.m_no_ni*b.m_e1_e2+a.m_no_ni*a.m_no_ni*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_), // e3_e1
			((-2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e1_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_ni*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_scalar*b.m_e3_e1))/(_n2_), // e1_ni
			((2.0*a.m_e1_e2*a.m_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e1_e2+-2.0*a.m_e1_e2*a.m_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e3_e1+2.0*a.m_e1_ni*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_ni*a.m_no_ni*b.m_e1_e2+2.0*a.m_e1_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_e2_e3*a.m_e2_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_e3_e1*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e2_e3_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e3_ni*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_ni
			((2.0*a.m_e1_e2*a.m_e1_ni*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_e3_e1*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3_ni*a.m_no_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_scalar*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_ni*a.m_no_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_ni*b.m_e3_e1+-2.0*a.m_e1_ni*a.m_scalar*b.m_e3_e1+2.0*a.m_e2_e3*a.m_e3_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_ni*b.m_e2_e3+2.0*a.m_e2_ni*a.m_scalar*b.m_e2_e3+2.0*a.m_e3_e1*a.m_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e1_e3_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e2_e3_ni*b.m_e2_e3))/(_n2_), // e3_ni
			((-2.0*a.m_e1_e2*a.m_no_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2*a.m_no_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1_e2*a.m_no_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1*b.m_e2_e3+-2.0*a.m_e1_e2_e3_ni*a.m_no_e2*b.m_e3_e1+-2.0*a.m_e1_e2_e3_ni*a.m_no_e3*b.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_ni*a.m_no_e2*b.m_e1_e2+-2.0*a.m_e1_ni*a.m_no_e3*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e2_ni*b.m_e3_e1+2.0*a.m_e2_e3*a.m_no_e1_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3*a.m_no_ni*b.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e1*b.m_e1_e2+2.0*a.m_e2_ni*a.m_no_e1_e2_e3*b.m_e3_e1+2.0*a.m_e2_ni*a.m_no_e3*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_no_e1_e2_ni*b.m_e2_e3+2.0*a.m_e3_e1*a.m_no_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3_e1*a.m_no_ni*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1*b.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e3_ni*a.m_no_e2*b.m_e2_e3+-2.0*a.m_no_e1_e2_ni*a.m_scalar*b.m_e1_e2+2.0*a.m_no_e1_e3_ni*a.m_scalar*b.m_e3_e1+-2.0*a.m_no_e2_e3_ni*a.m_scalar*b.m_e2_e3))/(_n2_), // no_ni
			(0.0)/(_n2_), // e1_e2_e3_ni
			(0.0)/(_n2_), // no_e2_e3_ni
			(0.0)/(_n2_), // no_e1_e3_ni
			(0.0)/(_n2_), // no_e1_e2_ni
			(0.0)/(_n2_) // no_e1_e2_e3
		);
}
inline pseudoscalar applyVersor(const evenVersor &a, const I5i_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			((-a.m_e1_e2*a.m_e1_e2+-2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+-2.0*a.m_e1_ni*a.m_no_e1-a.m_e2_e3*a.m_e2_e3+-2.0*a.m_e2_ni*a.m_no_e2-a.m_e3_e1*a.m_e3_e1+-2.0*a.m_e3_ni*a.m_no_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_ni*a.m_no_ni-a.m_scalar*a.m_scalar))/(_n2_) // no_e1_e2_e3_ni
		);
}
inline dualSphere applyVersor(const oddVersor &a, const vectorE3GA &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e2*a.m_e2+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e3*a.m_e3+a.m_ni*a.m_ni+a.m_no*a.m_no+a.m_no_e1_e2*a.m_no_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+a.m_no_e1_e3*a.m_no_e1_e3+a.m_no_e1_ni*a.m_no_e1_ni+a.m_no_e2_e3*a.m_no_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3))/(_n2_), // no
			((a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+a.m_e1_e2_ni*a.m_e1_e2_ni*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_ni*b.m_e2+a.m_e1_e3_ni*a.m_e1_e3_ni*b.m_e1+2.0*a.m_e1_e3_ni*a.m_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_ni*b.m_e3-a.m_e2*a.m_e2*b.m_e1-a.m_e2_e3_ni*a.m_e2_e3_ni*b.m_e1-a.m_e3*a.m_e3*b.m_e1-a.m_ni*a.m_ni*b.m_e1-a.m_no*a.m_no*b.m_e1+-2.0*a.m_no*a.m_no_e1_e2*b.m_e2+-2.0*a.m_no*a.m_no_e1_e3*b.m_e3+a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1+-2.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e3+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2+a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1+2.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e2+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1))/(_n2_), // e1
			((-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e2*b.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+a.m_e1_e2_ni*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1_e2_ni*a.m_ni*b.m_e1-a.m_e1_e3_ni*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e3_ni*a.m_e2_e3_ni*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+a.m_e2_e3_ni*a.m_e2_e3_ni*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_ni*b.m_e3-a.m_e3*a.m_e3*b.m_e2-a.m_ni*a.m_ni*b.m_e2-a.m_no*a.m_no*b.m_e2+2.0*a.m_no*a.m_no_e1_e2*b.m_e1+-2.0*a.m_no*a.m_no_e2_e3*b.m_e3+a.m_no_e1_e2*a.m_no_e1_e2*b.m_e2+2.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e3+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1-a.m_no_e1_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e1-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e2_e3*a.m_no_e2_e3*b.m_e2+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2))/(_n2_), // e2
			((-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1-a.m_e1_e2_ni*a.m_e1_e2_ni*b.m_e3+2.0*a.m_e1_e2_ni*a.m_e1_e3_ni*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_e2_e3_ni*b.m_e1+a.m_e1_e3_ni*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_ni*b.m_e1-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e3*b.m_e2+a.m_e2_e3_ni*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_ni*b.m_e2+a.m_e3*a.m_e3*b.m_e3-a.m_ni*a.m_ni*b.m_e3-a.m_no*a.m_no*b.m_e3+2.0*a.m_no*a.m_no_e1_e3*b.m_e1+2.0*a.m_no*a.m_no_e2_e3*b.m_e2-a.m_no_e1_e2*a.m_no_e1_e2*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e1+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e1_e3*a.m_no_e1_e3*b.m_e3-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e2_e3*a.m_no_e2_e3*b.m_e3-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3))/(_n2_), // e3
			((2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+2.0*a.m_e3*a.m_ni*b.m_e3+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2))/(_n2_) // ni
		);
}
inline dualSphere applyVersor(const oddVersor &a, const normalizedPoint &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((-a.m_e1*a.m_e1+2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+-2.0*a.m_e1*a.m_no_e1_ni-a.m_e1_e2_e3*a.m_e1_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1-a.m_e2*a.m_e2+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e2*a.m_no_e2_ni-a.m_e3*a.m_e3+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e3_ni+-2.0*a.m_no*a.m_no*b.m_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1-a.m_no_e1_ni*a.m_no_e1_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni))/(_n2_), // no
			((a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+-2.0*a.m_e1*a.m_ni+-2.0*a.m_e1*a.m_no*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e2+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni+-2.0*a.m_e1_e3_ni*a.m_e3+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni-a.m_e2*a.m_e2*b.m_e1+-2.0*a.m_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e1+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e1_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1))/(_n2_), // e1
			((-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_ni+2.0*a.m_e1*a.m_e2*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+-2.0*a.m_e2*a.m_ni+-2.0*a.m_e2*a.m_no*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e3+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni-a.m_e3*a.m_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e2+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e2_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2))/(_n2_), // e2
			((-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_no_e1_e3*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_ni-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e2_e3_ni+2.0*a.m_e2*a.m_e3*b.m_e2+2.0*a.m_e2*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_ni+a.m_e3*a.m_e3*b.m_e3+-2.0*a.m_e3*a.m_ni+-2.0*a.m_e3*a.m_no*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e3+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3))/(_n2_), // e3
			((-a.m_e1*a.m_e1*b.m_ni+2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1*a.m_no_e1_ni*b.m_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e1_e2_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1-a.m_e2*a.m_e2*b.m_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+2.0*a.m_e2*a.m_no_e2_ni*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2-a.m_e3*a.m_e3*b.m_ni+2.0*a.m_e3*a.m_ni*b.m_e3+2.0*a.m_e3*a.m_no_e3_ni*b.m_ni+-2.0*a.m_ni*a.m_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_ni))/(_n2_) // ni
		);
}
inline dualSphere applyVersor(const oddVersor &a, const dualSphere &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			((-a.m_e1*a.m_e1*b.m_no+2.0*a.m_e1*a.m_no*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3+-2.0*a.m_e1*a.m_no_e1_ni*b.m_no-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1-a.m_e2*a.m_e2*b.m_no+2.0*a.m_e2*a.m_no*b.m_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1+2.0*a.m_e2*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e2*a.m_no_e2_ni*b.m_no-a.m_e3*a.m_e3*b.m_no+2.0*a.m_e3*a.m_no*b.m_e3+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e3_ni*b.m_no+-2.0*a.m_no*a.m_no*b.m_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1+2.0*a.m_no*a.m_no_e2_ni*b.m_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1-a.m_no_e1_ni*a.m_no_e1_ni*b.m_no+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2-a.m_no_e2_ni*a.m_no_e2_ni*b.m_no-a.m_no_e3_ni*a.m_no_e3_ni*b.m_no))/(_n2_), // no
			((a.m_e1*a.m_e1*b.m_e1+2.0*a.m_e1*a.m_e2*b.m_e2+2.0*a.m_e1*a.m_e3*b.m_e3+-2.0*a.m_e1*a.m_ni*b.m_no+-2.0*a.m_e1*a.m_no*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_no+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_no+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_no-a.m_e2*a.m_e2*b.m_e1+-2.0*a.m_e2*a.m_no_e1_e2*b.m_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1-a.m_e3*a.m_e3*b.m_e1+-2.0*a.m_e3*a.m_no_e1_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e1+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e1_ni*b.m_no+2.0*a.m_no*a.m_no_e1_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1))/(_n2_), // e1
			((-a.m_e1*a.m_e1*b.m_e2+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3+2.0*a.m_e1*a.m_e1_e2_ni*b.m_no+2.0*a.m_e1*a.m_e2*b.m_e1+2.0*a.m_e1*a.m_no_e1_e2*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_no+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1+a.m_e2*a.m_e2*b.m_e2+2.0*a.m_e2*a.m_e3*b.m_e3+-2.0*a.m_e2*a.m_ni*b.m_no+-2.0*a.m_e2*a.m_no*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_no+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_no-a.m_e3*a.m_e3*b.m_e2+-2.0*a.m_e3*a.m_no_e2_e3*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e2+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3+-2.0*a.m_ni*a.m_no_e2_ni*b.m_no+2.0*a.m_no*a.m_no_e2_ni*b.m_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2))/(_n2_), // e2
			((-a.m_e1*a.m_e1*b.m_e3+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_no+2.0*a.m_e1*a.m_e3*b.m_e1+2.0*a.m_e1*a.m_no_e1_e3*b.m_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_no+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_no-a.m_e2*a.m_e2*b.m_e3+2.0*a.m_e2*a.m_e2_e3_ni*b.m_no+2.0*a.m_e2*a.m_e3*b.m_e2+2.0*a.m_e2*a.m_no_e2_e3*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_no+a.m_e3*a.m_e3*b.m_e3+-2.0*a.m_e3*a.m_ni*b.m_no+-2.0*a.m_e3*a.m_no*b.m_ni+2.0*a.m_ni*a.m_no*b.m_e3+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_no+2.0*a.m_no*a.m_no_e3_ni*b.m_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3))/(_n2_), // e3
			((-a.m_e1*a.m_e1*b.m_ni+2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3+2.0*a.m_e1*a.m_ni*b.m_e1+2.0*a.m_e1*a.m_no_e1_ni*b.m_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_ni+-2.0*a.m_e1_e2_ni*a.m_e1_e2_ni*b.m_no+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1+-2.0*a.m_e1_e3_ni*a.m_e1_e3_ni*b.m_no+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1-a.m_e2*a.m_e2*b.m_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3+2.0*a.m_e2*a.m_ni*b.m_e2+2.0*a.m_e2*a.m_no_e2_ni*b.m_ni+-2.0*a.m_e2_e3_ni*a.m_e2_e3_ni*b.m_no+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2-a.m_e3*a.m_e3*b.m_ni+2.0*a.m_e3*a.m_ni*b.m_e3+2.0*a.m_e3*a.m_no_e3_ni*b.m_ni+-2.0*a.m_ni*a.m_ni*b.m_no+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_ni))/(_n2_) // ni
		);
}
inline pointPair applyVersor(const oddVersor &a, const bivectorE3GA &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			((-2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_e2*a.m_no*b.m_e1_e2+-2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_no*b.m_e3_e1+2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_no*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_e3+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2))/(_n2_), // no_e1
			((-2.0*a.m_e1*a.m_no*b.m_e1_e2+2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_e3*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_no*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e2*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e3*a.m_no*b.m_e2_e3+2.0*a.m_e3*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_e3+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_e3))/(_n2_), // no_e2
			((2.0*a.m_e1*a.m_no*b.m_e3_e1+-2.0*a.m_e1*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e2*a.m_no*b.m_e2_e3+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e2+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_no*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_no*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2_e3))/(_n2_), // no_e3
			((-a.m_e1*a.m_e1*b.m_e1_e2+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e2_e3+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1_e2-a.m_e2*a.m_e2*b.m_e1_e2+2.0*a.m_e2*a.m_e3*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2+a.m_e3*a.m_e3*b.m_e1_e2+-2.0*a.m_ni*a.m_no*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3_e1-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3_e1+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3_e1-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2))/(_n2_), // e1_e2
			((a.m_e1*a.m_e1*b.m_e2_e3+2.0*a.m_e1*a.m_e2*b.m_e3_e1+2.0*a.m_e1*a.m_e3*b.m_e1_e2+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e3_e1-a.m_e2*a.m_e2*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2_e3-a.m_e3*a.m_e3*b.m_e2_e3+-2.0*a.m_ni*a.m_no*b.m_e2_e3+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1_e2-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e3_e1-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_e2+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1*a.m_e1*b.m_e3_e1+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2+-2.0*a.m_e1*a.m_e2*b.m_e2_e3-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2_e3-a.m_e2*a.m_e2*b.m_e3_e1+-2.0*a.m_e2*a.m_e3*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3_e1+a.m_e3*a.m_e3*b.m_e3_e1+2.0*a.m_ni*a.m_no*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_e3*b.m_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3_e1+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e2-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3_e1))/(_n2_), // e3_e1
			((2.0*a.m_e1*a.m_e1_e2_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e3_e1+2.0*a.m_e1*a.m_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e2_e3+2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_e2*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e2_e3+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2*a.m_ni*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_e3*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e3*a.m_ni*b.m_e3_e1+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_ni*a.m_no_e3_ni*b.m_e3_e1))/(_n2_), // e1_ni
			((-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e3_e1+2.0*a.m_e1*a.m_ni*b.m_e1_e2+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e2_e3+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_e3*a.m_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_ni*a.m_no_e3_ni*b.m_e2_e3))/(_n2_), // e2_ni
			((2.0*a.m_e1*a.m_e1_e2_ni*b.m_e2_e3+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_ni*b.m_e3_e1+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e2_e3+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e3_e1+2.0*a.m_e1_e2_ni*a.m_e3*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_e2*b.m_e1_e2+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3+-2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e1_e2+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e3_e1+2.0*a.m_e2*a.m_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_e3*b.m_e2_e3+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e2_e3))/(_n2_), // e3_ni
			((2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e2_e3+2.0*a.m_e1*a.m_no_e2_ni*b.m_e1_e2+-2.0*a.m_e1*a.m_no_e3_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e2_e3+-2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e3_e1+-2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e1_e2+2.0*a.m_e1_e2_ni*a.m_no*b.m_e1_e2+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3_e1+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e3_e1+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2_e3+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1_e2+2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e3_e1+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e1_e2+2.0*a.m_e2*a.m_no_e3_ni*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no*b.m_e2_e3+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3_e1+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2+2.0*a.m_e3*a.m_no_e1_ni*b.m_e3_e1+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e2_e3+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1_e2+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3_e1+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2_e3))/(_n2_) // no_ni
		);
}
inline circle applyVersor(const oddVersor &a, const line &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			((-2.0*a.m_e1*a.m_no*b.m_e2_no_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_no_ni+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e2*a.m_no*b.m_e1_no_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_no*a.m_no*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+4.0*a.m_no*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e2_no_ni+-4.0*a.m_no*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e2_ni+-4.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_no_ni))/(_n2_), // no_e1_e2
			((-2.0*a.m_e1*a.m_no*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_no_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_no_ni+2.0*a.m_e3*a.m_no*b.m_e1_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no*b.m_e1_e3_ni+-4.0*a.m_no*a.m_no_e1_e2*b.m_e2_e3_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e3_no_ni+4.0*a.m_no*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_no_ni+-4.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_no_ni))/(_n2_), // no_e1_e3
			((2.0*a.m_e1*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e3*a.m_no*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no*b.m_e2_e3_ni+4.0*a.m_no*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-4.0*a.m_no*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e3_no_ni+-4.0*a.m_no_e1_e2*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_no_ni+-4.0*a.m_no_e1_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e3_no_ni))/(_n2_), // no_e2_e3
			((-2.0*a.m_e1*a.m_no*b.m_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_e2*a.m_no*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2*a.m_no_e1_ni*b.m_e3_no_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_e1_no_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e3_ni))/(_n2_), // e1_e2_e3
			((-a.m_e1*a.m_e1*b.m_e1_no_ni+-2.0*a.m_e1*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+a.m_e2*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e2*a.m_no*b.m_e1_e2_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e1_no_ni+a.m_e3*a.m_e3*b.m_e1_no_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_no_e1_e2*b.m_e2_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_ni*a.m_no*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e1_e3*b.m_e3_no_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e3_no_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_no_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni))/(_n2_), // no_e1_ni
			((a.m_e1*a.m_e1*b.m_e2_no_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e2*b.m_e1_no_ni+2.0*a.m_e1*a.m_no*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e1_e3*b.m_e2_e3_ni+2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_e1_no_ni-a.m_e2*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e2*a.m_e3*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e2_no_ni+a.m_e3*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e3*a.m_no*b.m_e2_e3_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2_ni+2.0*a.m_ni*a.m_no*b.m_e2_no_ni+-2.0*a.m_ni*a.m_no_e1_e2*b.m_e1_no_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_e3_no_ni+-2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e3_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e3_no_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni))/(_n2_), // no_e2_ni
			((a.m_e1*a.m_e1*b.m_e1_e2_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_e1_no_ni+2.0*a.m_e1*a.m_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e2_e3_ni+2.0*a.m_e1*a.m_ni*b.m_e2_no_ni+-2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_e3*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e2_no_ni+a.m_e2*a.m_e2*b.m_e1_e2_ni+2.0*a.m_e2*a.m_e3*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_ni*b.m_e1_no_ni+-2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e1_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e1_no_ni-a.m_e3*a.m_e3*b.m_e1_e2_ni+2.0*a.m_e3*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e2_ni+-2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_ni*a.m_no_e2_ni*b.m_e1_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2_ni))/(_n2_), // e1_e2_ni
			((a.m_e1*a.m_e1*b.m_e3_no_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e2_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e1_no_ni+2.0*a.m_e1*a.m_no*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e1_e2*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_no_e2_e3*b.m_e1_e2_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_no*b.m_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_e3_no_ni+a.m_e2*a.m_e2*b.m_e3_no_ni+-2.0*a.m_e2*a.m_e3*b.m_e2_no_ni+2.0*a.m_e2*a.m_no*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e3_ni+2.0*a.m_e2*a.m_no_e1_e3*b.m_e1_e2_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_e1_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_e3_no_ni-a.m_e3*a.m_e3*b.m_e3_no_ni+2.0*a.m_e3*a.m_no_e1_e2*b.m_e1_e2_ni+2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_e3_no_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_e1_no_ni+-2.0*a.m_ni*a.m_no_e2_e3*b.m_e2_no_ni+2.0*a.m_no*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+-2.0*a.m_no_e1_e3*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_no_e1_ni*a.m_no_e2_e3*b.m_e1_e2_ni+2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e2_no_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni))/(_n2_), // no_e3_ni
			((a.m_e1*a.m_e1*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_e1_e3_ni*b.m_e1_no_ni+2.0*a.m_e1*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1*a.m_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_e2*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_e3*b.m_e2_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e2_no_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni-a.m_e2*a.m_e2*b.m_e1_e3_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_e1_no_ni+2.0*a.m_e2*a.m_e3*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_no_e3_ni*b.m_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+a.m_e3*a.m_e3*b.m_e1_e3_ni+-2.0*a.m_e3*a.m_ni*b.m_e1_no_ni+-2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_e3_no_ni+2.0*a.m_ni*a.m_no_e3_ni*b.m_e1_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e3_ni))/(_n2_), // e1_e3_ni
			((-a.m_e1*a.m_e1*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_e3_no_ni+2.0*a.m_e1*a.m_e1_e3_ni*b.m_e2_no_ni+2.0*a.m_e1*a.m_e2*b.m_e1_e3_ni+-2.0*a.m_e1*a.m_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1*a.m_e3*b.m_e1_e2_ni+2.0*a.m_e1*a.m_no_e1_ni*b.m_e2_e3_ni+-2.0*a.m_e1*a.m_no_e2_ni*b.m_e1_e3_ni+2.0*a.m_e1*a.m_no_e3_ni*b.m_e1_e2_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_ni*b.m_e1_no_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_ni*b.m_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e3_ni*b.m_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_e3*b.m_e1_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_e3_no_ni+-2.0*a.m_e1_e2_ni*a.m_no_e3_ni*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_e2*b.m_e1_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e3_no_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_e2_no_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_ni*b.m_e1_no_ni+a.m_e2*a.m_e2*b.m_e2_e3_ni+-2.0*a.m_e2*a.m_e2_e3_ni*b.m_e2_no_ni+2.0*a.m_e2*a.m_ni*b.m_e3_no_ni+2.0*a.m_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_ni+-2.0*a.m_e2*a.m_no_e1_ni*b.m_e1_e3_ni+-2.0*a.m_e2*a.m_no_e2_ni*b.m_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_e3*b.m_e3_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_ni*b.m_e1_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_e2_no_ni+2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_e3_no_ni+a.m_e3*a.m_e3*b.m_e2_e3_ni+-2.0*a.m_e3*a.m_ni*b.m_e2_no_ni+2.0*a.m_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e3_ni+2.0*a.m_e3*a.m_no_e1_ni*b.m_e1_e2_ni+-2.0*a.m_e3*a.m_no_e3_ni*b.m_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_e2_e3_ni*b.m_e1_no_ni+-2.0*a.m_ni*a.m_no_e2_ni*b.m_e3_no_ni+2.0*a.m_ni*a.m_no_e3_ni*b.m_e2_no_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_e1_e2_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_e1_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_e1_e3_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_e1_e2_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_e2_e3_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_e2_e3_ni))/(_n2_) // e2_e3_ni
		);
}
inline sphere applyVersor(const oddVersor &a, const plane &b)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			((-a.m_e1*a.m_e1*b.m_e1_e2_e3_ni+-2.0*a.m_e1*a.m_e1_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e1_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1*a.m_ni*b.m_no_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e1_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_e1_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni-a.m_e2*a.m_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2*a.m_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2*a.m_ni*b.m_no_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_e3*b.m_no_e1_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_e2_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni-a.m_e3*a.m_e3*b.m_e1_e2_e3_ni+2.0*a.m_e3*a.m_ni*b.m_no_e1_e2_ni+2.0*a.m_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_ni*b.m_no_e2_e3_ni+2.0*a.m_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_e1_e2_e3_ni))/(_n2_), // e1_e2_e3_ni
			((a.m_e1*a.m_e1*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_e2*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_no*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_e3*a.m_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni-a.m_e2*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni-a.m_e3*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni))/(_n2_), // no_e2_e3_ni
			((-a.m_e1*a.m_e1*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_e1_e2_e3*a.m_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+a.m_e2*a.m_e2*b.m_no_e1_e3_ni+-2.0*a.m_e2*a.m_e3*b.m_no_e1_e2_ni+2.0*a.m_e2*a.m_no*b.m_e1_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no*b.m_no_e1_e2_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni-a.m_e3*a.m_e3*b.m_no_e1_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e1_e3_ni+2.0*a.m_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+-2.0*a.m_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_e1_e2_e3_ni+-2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni))/(_n2_), // no_e1_e3_ni
			((-a.m_e1*a.m_e1*b.m_no_e1_e2_ni+-2.0*a.m_e1*a.m_e1_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_e3*b.m_no_e2_e3_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_e1_e2_e3_ni+a.m_e1_e2_e3*a.m_e1_e2_e3*b.m_no_e1_e2_ni+-2.0*a.m_e1_e2_e3*a.m_e2*b.m_no_e2_e3_ni+-2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no*b.m_no_e2_e3_ni+2.0*a.m_e1_e3_ni*a.m_no_e1_e2*b.m_no_e1_e3_ni+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3*b.m_no_e1_e2_ni-a.m_e2*a.m_e2*b.m_no_e1_e2_ni+-2.0*a.m_e2*a.m_e3*b.m_no_e1_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_e2_e3_ni*a.m_no*b.m_no_e1_e3_ni+2.0*a.m_e2_e3_ni*a.m_no_e1_e2*b.m_no_e2_e3_ni+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3*b.m_no_e1_e2_ni+a.m_e3*a.m_e3*b.m_no_e1_e2_ni+-2.0*a.m_e3*a.m_no*b.m_e1_e2_e3_ni+2.0*a.m_ni*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_ni*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_ni*a.m_no_e2_e3*b.m_no_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_ni*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_e1_e2_e3_ni+a.m_no_e1_ni*a.m_no_e1_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_ni*a.m_no_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_e1_e2_e3_ni+a.m_no_e2_ni*a.m_no_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2_ni*a.m_no_e3_ni*b.m_no_e1_e3_ni-a.m_no_e3_ni*a.m_no_e3_ni*b.m_no_e1_e2_ni))/(_n2_), // no_e1_e2_ni
			((2.0*a.m_e1*a.m_no*b.m_no_e2_e3_ni+-2.0*a.m_e1*a.m_no_e1_e2*b.m_no_e1_e3_ni+2.0*a.m_e1*a.m_no_e1_e3*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e2*b.m_no_e1_e2_ni+2.0*a.m_e1_e2_e3*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_e1_e2_e3*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_e2*a.m_no*b.m_no_e1_e3_ni+-2.0*a.m_e2*a.m_no_e1_e2*b.m_no_e2_e3_ni+2.0*a.m_e2*a.m_no_e2_e3*b.m_no_e1_e2_ni+2.0*a.m_e3*a.m_no*b.m_no_e1_e2_ni+-2.0*a.m_e3*a.m_no_e1_e3*b.m_no_e2_e3_ni+2.0*a.m_e3*a.m_no_e2_e3*b.m_no_e1_e3_ni+-2.0*a.m_no*a.m_no*b.m_e1_e2_e3_ni+2.0*a.m_no*a.m_no_e1_ni*b.m_no_e2_e3_ni+-2.0*a.m_no*a.m_no_e2_ni*b.m_no_e1_e3_ni+2.0*a.m_no*a.m_no_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_e2*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e2*a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e2*a.m_no_e1_ni*b.m_no_e1_e3_ni+-2.0*a.m_no_e1_e2*a.m_no_e2_ni*b.m_no_e2_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e1_e3*b.m_no_e1_e3_ni+2.0*a.m_no_e1_e2_e3_ni*a.m_no_e2_e3*b.m_no_e2_e3_ni+-2.0*a.m_no_e1_e3*a.m_no_e1_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e1_e3*a.m_no_e1_ni*b.m_no_e1_e2_ni+-2.0*a.m_no_e1_e3*a.m_no_e3_ni*b.m_no_e2_e3_ni+-2.0*a.m_no_e2_e3*a.m_no_e2_e3*b.m_e1_e2_e3_ni+2.0*a.m_no_e2_e3*a.m_no_e2_ni*b.m_no_e1_e2_ni+2.0*a.m_no_e2_e3*a.m_no_e3_ni*b.m_no_e1_e3_ni))/(_n2_) // no_e1_e2_e3
		);
}
inline vectorE3GA applyVersorWI(const rotorE3GA &a, const vectorE3GA &b, const rotorE3GA &c)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar) // e3
		);
}
inline dualSphere applyVersorWI(const rotorE3GA &a, const normalizedPoint &b, const rotorE3GA &c)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(-a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar), // no
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(-a.m_e1_e2*b.m_ni*c.m_e1_e2-a.m_e2_e3*b.m_ni*c.m_e2_e3-a.m_e3_e1*b.m_ni*c.m_e3_e1+a.m_scalar*b.m_ni*c.m_scalar) // ni
		);
}
inline dualSphere applyVersorWI(const rotorE3GA &a, const dualSphere &b, const rotorE3GA &c)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			(-a.m_e1_e2*b.m_no*c.m_e1_e2-a.m_e2_e3*b.m_no*c.m_e2_e3-a.m_e3_e1*b.m_no*c.m_e3_e1+a.m_scalar*b.m_no*c.m_scalar), // no
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar), // e3
			(-a.m_e1_e2*b.m_ni*c.m_e1_e2-a.m_e2_e3*b.m_ni*c.m_e2_e3-a.m_e3_e1*b.m_ni*c.m_e3_e1+a.m_scalar*b.m_ni*c.m_scalar) // ni
		);
}
inline bivectorE3GA applyVersorWI(const rotorE3GA &a, const bivectorE3GA &b, const rotorE3GA &c)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline line applyVersorWI(const rotorE3GA &a, const line &b, const rotorE3GA &c)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			(-a.m_e1_e2*b.m_e1_e2_ni*c.m_e1_e2+a.m_e1_e2*b.m_e1_e3_ni*c.m_e3_e1-a.m_e1_e2*b.m_e2_e3_ni*c.m_e2_e3+a.m_e2_e3*b.m_e1_e2_ni*c.m_e2_e3+a.m_e2_e3*b.m_e1_e3_ni*c.m_scalar-a.m_e2_e3*b.m_e2_e3_ni*c.m_e1_e2+a.m_e3_e1*b.m_e1_e2_ni*c.m_e3_e1+a.m_e3_e1*b.m_e1_e3_ni*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3_ni*c.m_scalar+a.m_scalar*b.m_e1_e2_ni*c.m_scalar-a.m_scalar*b.m_e1_e3_ni*c.m_e2_e3-a.m_scalar*b.m_e2_e3_ni*c.m_e3_e1), // e1_e2_ni
			(a.m_e1_e2*b.m_e1_e2_ni*c.m_e3_e1+a.m_e1_e2*b.m_e1_e3_ni*c.m_e1_e2+a.m_e1_e2*b.m_e2_e3_ni*c.m_scalar-a.m_e2_e3*b.m_e1_e2_ni*c.m_scalar+a.m_e2_e3*b.m_e1_e3_ni*c.m_e2_e3+a.m_e2_e3*b.m_e2_e3_ni*c.m_e3_e1+a.m_e3_e1*b.m_e1_e2_ni*c.m_e1_e2-a.m_e3_e1*b.m_e1_e3_ni*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3_ni*c.m_e2_e3+a.m_scalar*b.m_e1_e2_ni*c.m_e2_e3+a.m_scalar*b.m_e1_e3_ni*c.m_scalar-a.m_scalar*b.m_e2_e3_ni*c.m_e1_e2), // e1_e3_ni
			(-a.m_e1_e2*b.m_e1_e2_ni*c.m_e2_e3-a.m_e1_e2*b.m_e1_e3_ni*c.m_scalar+a.m_e1_e2*b.m_e2_e3_ni*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2_ni*c.m_e1_e2+a.m_e2_e3*b.m_e1_e3_ni*c.m_e3_e1-a.m_e2_e3*b.m_e2_e3_ni*c.m_e2_e3-a.m_e3_e1*b.m_e1_e2_ni*c.m_scalar+a.m_e3_e1*b.m_e1_e3_ni*c.m_e2_e3+a.m_e3_e1*b.m_e2_e3_ni*c.m_e3_e1+a.m_scalar*b.m_e1_e2_ni*c.m_e3_e1+a.m_scalar*b.m_e1_e3_ni*c.m_e1_e2+a.m_scalar*b.m_e2_e3_ni*c.m_scalar), // e2_e3_ni
			-(-a.m_e1_e2*b.m_e1_no_ni*c.m_e1_e2-a.m_e1_e2*b.m_e2_no_ni*c.m_scalar+a.m_e1_e2*b.m_e3_no_ni*c.m_e2_e3+a.m_e2_e3*b.m_e1_no_ni*c.m_e2_e3+a.m_e2_e3*b.m_e2_no_ni*c.m_e3_e1+a.m_e2_e3*b.m_e3_no_ni*c.m_e1_e2-a.m_e3_e1*b.m_e1_no_ni*c.m_e3_e1+a.m_e3_e1*b.m_e2_no_ni*c.m_e2_e3+a.m_e3_e1*b.m_e3_no_ni*c.m_scalar-a.m_scalar*b.m_e1_no_ni*c.m_scalar+a.m_scalar*b.m_e2_no_ni*c.m_e1_e2-a.m_scalar*b.m_e3_no_ni*c.m_e3_e1), // e1_no_ni
			-(a.m_e1_e2*b.m_e1_no_ni*c.m_scalar-a.m_e1_e2*b.m_e2_no_ni*c.m_e1_e2+a.m_e1_e2*b.m_e3_no_ni*c.m_e3_e1+a.m_e2_e3*b.m_e1_no_ni*c.m_e3_e1-a.m_e2_e3*b.m_e2_no_ni*c.m_e2_e3-a.m_e2_e3*b.m_e3_no_ni*c.m_scalar+a.m_e3_e1*b.m_e1_no_ni*c.m_e2_e3+a.m_e3_e1*b.m_e2_no_ni*c.m_e3_e1+a.m_e3_e1*b.m_e3_no_ni*c.m_e1_e2-a.m_scalar*b.m_e1_no_ni*c.m_e1_e2-a.m_scalar*b.m_e2_no_ni*c.m_scalar+a.m_scalar*b.m_e3_no_ni*c.m_e2_e3), // e2_no_ni
			-(a.m_e1_e2*b.m_e1_no_ni*c.m_e2_e3+a.m_e1_e2*b.m_e2_no_ni*c.m_e3_e1+a.m_e1_e2*b.m_e3_no_ni*c.m_e1_e2+a.m_e2_e3*b.m_e1_no_ni*c.m_e1_e2+a.m_e2_e3*b.m_e2_no_ni*c.m_scalar-a.m_e2_e3*b.m_e3_no_ni*c.m_e2_e3-a.m_e3_e1*b.m_e1_no_ni*c.m_scalar+a.m_e3_e1*b.m_e2_no_ni*c.m_e1_e2-a.m_e3_e1*b.m_e3_no_ni*c.m_e3_e1+a.m_scalar*b.m_e1_no_ni*c.m_e3_e1-a.m_scalar*b.m_e2_no_ni*c.m_e2_e3-a.m_scalar*b.m_e3_no_ni*c.m_scalar) // e3_no_ni
		);
}
inline plane applyVersorWI(const rotorE3GA &a, const plane &b, const rotorE3GA &c)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			(-a.m_e1_e2*b.m_e1_e2_e3_ni*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2_e3_ni*c.m_e2_e3-a.m_e3_e1*b.m_e1_e2_e3_ni*c.m_e3_e1+a.m_scalar*b.m_e1_e2_e3_ni*c.m_scalar), // e1_e2_e3_ni
			(-a.m_e1_e2*b.m_no_e1_e2_ni*c.m_e2_e3-a.m_e1_e2*b.m_no_e1_e3_ni*c.m_scalar+a.m_e1_e2*b.m_no_e2_e3_ni*c.m_e1_e2-a.m_e2_e3*b.m_no_e1_e2_ni*c.m_e1_e2+a.m_e2_e3*b.m_no_e1_e3_ni*c.m_e3_e1-a.m_e2_e3*b.m_no_e2_e3_ni*c.m_e2_e3-a.m_e3_e1*b.m_no_e1_e2_ni*c.m_scalar+a.m_e3_e1*b.m_no_e1_e3_ni*c.m_e2_e3+a.m_e3_e1*b.m_no_e2_e3_ni*c.m_e3_e1+a.m_scalar*b.m_no_e1_e2_ni*c.m_e3_e1+a.m_scalar*b.m_no_e1_e3_ni*c.m_e1_e2+a.m_scalar*b.m_no_e2_e3_ni*c.m_scalar), // no_e2_e3_ni
			(a.m_e1_e2*b.m_no_e1_e2_ni*c.m_e3_e1+a.m_e1_e2*b.m_no_e1_e3_ni*c.m_e1_e2+a.m_e1_e2*b.m_no_e2_e3_ni*c.m_scalar-a.m_e2_e3*b.m_no_e1_e2_ni*c.m_scalar+a.m_e2_e3*b.m_no_e1_e3_ni*c.m_e2_e3+a.m_e2_e3*b.m_no_e2_e3_ni*c.m_e3_e1+a.m_e3_e1*b.m_no_e1_e2_ni*c.m_e1_e2-a.m_e3_e1*b.m_no_e1_e3_ni*c.m_e3_e1+a.m_e3_e1*b.m_no_e2_e3_ni*c.m_e2_e3+a.m_scalar*b.m_no_e1_e2_ni*c.m_e2_e3+a.m_scalar*b.m_no_e1_e3_ni*c.m_scalar-a.m_scalar*b.m_no_e2_e3_ni*c.m_e1_e2), // no_e1_e3_ni
			(-a.m_e1_e2*b.m_no_e1_e2_ni*c.m_e1_e2+a.m_e1_e2*b.m_no_e1_e3_ni*c.m_e3_e1-a.m_e1_e2*b.m_no_e2_e3_ni*c.m_e2_e3+a.m_e2_e3*b.m_no_e1_e2_ni*c.m_e2_e3+a.m_e2_e3*b.m_no_e1_e3_ni*c.m_scalar-a.m_e2_e3*b.m_no_e2_e3_ni*c.m_e1_e2+a.m_e3_e1*b.m_no_e1_e2_ni*c.m_e3_e1+a.m_e3_e1*b.m_no_e1_e3_ni*c.m_e1_e2+a.m_e3_e1*b.m_no_e2_e3_ni*c.m_scalar+a.m_scalar*b.m_no_e1_e2_ni*c.m_scalar-a.m_scalar*b.m_no_e1_e3_ni*c.m_e2_e3-a.m_scalar*b.m_no_e2_e3_ni*c.m_e3_e1) // no_e1_e2_ni
		);
}
inline vectorE3GA applyVersorWI(const rotorE3GA &a, const e1_t &b, const rotorE3GA &c)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3+a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar), // e1
			(-a.m_e1_e2*c.m_scalar-a.m_e2_e3*c.m_e3_e1-a.m_e3_e1*c.m_e2_e3+a.m_scalar*c.m_e1_e2), // e2
			(-a.m_e1_e2*c.m_e2_e3-a.m_e2_e3*c.m_e1_e2+a.m_e3_e1*c.m_scalar-a.m_scalar*c.m_e3_e1) // e3
		);
}
inline pseudoscalar applyVersorWI(const rotorE3GA &a, const I5_t &b, const rotorE3GA &c)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			(-a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar) // no_e1_e2_e3_ni
		);
}
inline vectorE3GA div(const vectorE3GA &a, const double b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)) // e3
		);
}
inline dualSphere div(const normalizedPoint &a, const double b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			1.0 / (b), // no
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)), // e3
			a.m_ni/((b)) // ni
		);
}
inline bivectorE3GA div(const bivectorE3GA &a, const double b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline line div(const line &a, const double b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_e1_e2_ni/((b)), // e1_e2_ni
			a.m_e1_e3_ni/((b)), // e1_e3_ni
			a.m_e2_e3_ni/((b)), // e2_e3_ni
			a.m_e1_no_ni/((b)), // e1_no_ni
			a.m_e2_no_ni/((b)), // e2_no_ni
			a.m_e3_no_ni/((b)) // e3_no_ni
		);
}
inline plane div(const plane &a, const double b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni/((b)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((b)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((b)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((b)) // no_e1_e2_ni
		);
}
inline sphere div(const sphere &a, const double b)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_e1_e2_e3_ni/((b)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((b)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((b)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((b)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((b)) // no_e1_e2_e3
		);
}
inline pseudoscalar div(const I5_t &a, const double b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			1.0 / (b) // no_e1_e2_e3_ni
		);
}
inline evenVersor div(const evenVersor &a, const double b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar/((b)), // scalar
			a.m_no_e1/((b)), // no_e1
			a.m_no_e2/((b)), // no_e2
			a.m_no_e3/((b)), // no_e3
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)), // e3_e1
			a.m_e1_ni/((b)), // e1_ni
			a.m_e2_ni/((b)), // e2_ni
			a.m_e3_ni/((b)), // e3_ni
			a.m_no_ni/((b)), // no_ni
			a.m_e1_e2_e3_ni/((b)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((b)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((b)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((b)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((b)) // no_e1_e2_e3
		);
}
inline oddVersor div(const oddVersor &a, const double b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no/((b)), // no
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)), // e3
			a.m_ni/((b)), // ni
			a.m_no_e1_e2/((b)), // no_e1_e2
			a.m_no_e1_e3/((b)), // no_e1_e3
			a.m_no_e2_e3/((b)), // no_e2_e3
			a.m_e1_e2_e3/((b)), // e1_e2_e3
			a.m_no_e1_ni/((b)), // no_e1_ni
			a.m_no_e2_ni/((b)), // no_e2_ni
			a.m_e1_e2_ni/((b)), // e1_e2_ni
			a.m_no_e3_ni/((b)), // no_e3_ni
			a.m_e1_e3_ni/((b)), // e1_e3_ni
			a.m_e2_e3_ni/((b)), // e2_e3_ni
			a.m_no_e1_e2_e3_ni/((b)) // no_e1_e2_e3_ni
		);
}
inline circle div(const I3_t &a, const double b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			1.0 / (b), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0 // e2_e3_ni
		);
}
inline flatPoint div(const noni_t &a, const double b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			1.0 / (b) // no_ni
		);
}
inline pseudoscalar dual(const double a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a // no_e1_e2_e3_ni
		);

}
inline pseudoscalar undual(const double a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a // no_e1_e2_e3_ni
		);

}
inline plane dual(const vectorE3GA &a)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			0.0, // e1_e2_e3_ni
			a.m_e1, // no_e2_e3_ni
			-a.m_e2, // no_e1_e3_ni
			a.m_e3 // no_e1_e2_ni
		);

}
inline plane undual(const vectorE3GA &a)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			0.0, // e1_e2_e3_ni
			-a.m_e1, // no_e2_e3_ni
			a.m_e2, // no_e1_e3_ni
			-a.m_e3 // no_e1_e2_ni
		);

}
inline sphere dual(const normalizedPoint &a)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_ni, // e1_e2_e3_ni
			a.m_e1, // no_e2_e3_ni
			-a.m_e2, // no_e1_e3_ni
			a.m_e3, // no_e1_e2_ni
			1.0 // no_e1_e2_e3
		);

}
inline sphere undual(const normalizedPoint &a)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-a.m_ni, // e1_e2_e3_ni
			-a.m_e1, // no_e2_e3_ni
			a.m_e2, // no_e1_e3_ni
			-a.m_e3, // no_e1_e2_ni
			-1.0 // no_e1_e2_e3
		);

}
inline line dual(const bivectorE3GA &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			0.0, // e1_e2_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			-a.m_e2_e3, // e1_no_ni
			-a.m_e3_e1, // e2_no_ni
			-a.m_e1_e2 // e3_no_ni
		);

}
inline line undual(const bivectorE3GA &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			0.0, // e1_e2_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			a.m_e2_e3, // e1_no_ni
			a.m_e3_e1, // e2_no_ni
			a.m_e1_e2 // e3_no_ni
		);

}
inline oddVersor dual(const rotorE3GA &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			a.m_e2_e3, // no_e1_ni
			a.m_e3_e1, // no_e2_ni
			0.0, // e1_e2_ni
			a.m_e1_e2, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			-a.m_scalar // no_e1_e2_e3_ni
		);

}
inline oddVersor undual(const rotorE3GA &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-a.m_e2_e3, // no_e1_ni
			-a.m_e3_e1, // no_e2_ni
			0.0, // e1_e2_ni
			-a.m_e1_e2, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			a.m_scalar // no_e1_e2_e3_ni
		);

}
inline evenVersor dual(const oddVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_no_e1_e2_e3_ni, // scalar
			-a.m_no_e2_e3, // no_e1
			a.m_no_e1_e3, // no_e2
			-a.m_no_e1_e2, // no_e3
			-a.m_no_e3_ni, // e1_e2
			-a.m_no_e1_ni, // e2_e3
			-a.m_no_e2_ni, // e3_e1
			-a.m_e2_e3_ni, // e1_ni
			a.m_e1_e3_ni, // e2_ni
			-a.m_e1_e2_ni, // e3_ni
			-a.m_e1_e2_e3, // no_ni
			a.m_ni, // e1_e2_e3_ni
			a.m_e1, // no_e2_e3_ni
			-a.m_e2, // no_e1_e3_ni
			a.m_e3, // no_e1_e2_ni
			a.m_no // no_e1_e2_e3
		);

}
inline evenVersor undual(const oddVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-a.m_no_e1_e2_e3_ni, // scalar
			a.m_no_e2_e3, // no_e1
			-a.m_no_e1_e3, // no_e2
			a.m_no_e1_e2, // no_e3
			a.m_no_e3_ni, // e1_e2
			a.m_no_e1_ni, // e2_e3
			a.m_no_e2_ni, // e3_e1
			a.m_e2_e3_ni, // e1_ni
			-a.m_e1_e3_ni, // e2_ni
			a.m_e1_e2_ni, // e3_ni
			a.m_e1_e2_e3, // no_ni
			-a.m_ni, // e1_e2_e3_ni
			-a.m_e1, // no_e2_e3_ni
			a.m_e2, // no_e1_e3_ni
			-a.m_e3, // no_e1_e2_ni
			-a.m_no // no_e1_e2_e3
		);

}
inline oddVersor dual(const evenVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			-a.m_no_e1_e2_e3, // no
			-a.m_no_e2_e3_ni, // e1
			a.m_no_e1_e3_ni, // e2
			-a.m_no_e1_e2_ni, // e3
			-a.m_e1_e2_e3_ni, // ni
			a.m_no_e3, // no_e1_e2
			-a.m_no_e2, // no_e1_e3
			a.m_no_e1, // no_e2_e3
			a.m_no_ni, // e1_e2_e3
			a.m_e2_e3, // no_e1_ni
			a.m_e3_e1, // no_e2_ni
			a.m_e3_ni, // e1_e2_ni
			a.m_e1_e2, // no_e3_ni
			-a.m_e2_ni, // e1_e3_ni
			a.m_e1_ni, // e2_e3_ni
			-a.m_scalar // no_e1_e2_e3_ni
		);

}
inline oddVersor undual(const evenVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no_e1_e2_e3, // no
			a.m_no_e2_e3_ni, // e1
			-a.m_no_e1_e3_ni, // e2
			a.m_no_e1_e2_ni, // e3
			a.m_e1_e2_e3_ni, // ni
			-a.m_no_e3, // no_e1_e2
			a.m_no_e2, // no_e1_e3
			-a.m_no_e1, // no_e2_e3
			-a.m_no_ni, // e1_e2_e3
			-a.m_e2_e3, // no_e1_ni
			-a.m_e3_e1, // no_e2_ni
			-a.m_e3_ni, // e1_e2_ni
			-a.m_e1_e2, // no_e3_ni
			a.m_e2_ni, // e1_e3_ni
			-a.m_e1_ni, // e2_e3_ni
			a.m_scalar // no_e1_e2_e3_ni
		);

}
inline circle dual(const pointPair &a)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			a.m_no_e3, // no_e1_e2
			-a.m_no_e2, // no_e1_e3
			a.m_no_e1, // no_e2_e3
			a.m_no_ni, // e1_e2_e3
			a.m_e2_e3, // no_e1_ni
			a.m_e3_e1, // no_e2_ni
			a.m_e3_ni, // e1_e2_ni
			a.m_e1_e2, // no_e3_ni
			-a.m_e2_ni, // e1_e3_ni
			a.m_e1_ni // e2_e3_ni
		);

}
inline circle undual(const pointPair &a)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			-a.m_no_e3, // no_e1_e2
			a.m_no_e2, // no_e1_e3
			-a.m_no_e1, // no_e2_e3
			-a.m_no_ni, // e1_e2_e3
			-a.m_e2_e3, // no_e1_ni
			-a.m_e3_e1, // no_e2_ni
			-a.m_e3_ni, // e1_e2_ni
			-a.m_e1_e2, // no_e3_ni
			a.m_e2_ni, // e1_e3_ni
			-a.m_e1_ni // e2_e3_ni
		);

}
inline dualPlane dual(const plane &a)
{
	return dualPlane(dualPlane::coord_e1_e2_e3_ni,
			-a.m_no_e2_e3_ni, // e1
			a.m_no_e1_e3_ni, // e2
			-a.m_no_e1_e2_ni, // e3
			-a.m_e1_e2_e3_ni // ni
		);

}
inline dualPlane undual(const plane &a)
{
	return dualPlane(dualPlane::coord_e1_e2_e3_ni,
			a.m_no_e2_e3_ni, // e1
			-a.m_no_e1_e3_ni, // e2
			a.m_no_e1_e2_ni, // e3
			a.m_e1_e2_e3_ni // ni
		);

}
inline pointPair dual(const circle &a)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			-a.m_e2_e3_ni, // no_e1
			a.m_e1_e3_ni, // no_e2
			-a.m_e1_e2_ni, // no_e3
			-a.m_no_e3_ni, // e1_e2
			-a.m_no_e1_ni, // e2_e3
			-a.m_no_e2_ni, // e3_e1
			-a.m_no_e2_e3, // e1_ni
			a.m_no_e1_e3, // e2_ni
			-a.m_no_e1_e2, // e3_ni
			a.m_e1_e2_e3 // no_ni
		);

}
inline pointPair undual(const circle &a)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			-a.m_e2_e3_ni, // no_e1
			a.m_e1_e3_ni, // no_e2
			-a.m_e1_e2_ni, // no_e3
			-a.m_no_e3_ni, // e1_e2
			-a.m_no_e1_ni, // e2_e3
			-a.m_no_e2_ni, // e3_e1
			-a.m_no_e2_e3, // e1_ni
			a.m_no_e1_e3, // e2_ni
			-a.m_no_e1_e2, // e3_ni
			a.m_e1_e2_e3 // no_ni
		);

}
inline plane dual(const e1_t &a)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			0.0, // e1_e2_e3_ni
			1.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0 // no_e1_e2_ni
		);

}
inline noni_t undual(const I3_t &a)
{
	return noni_t(		);

}
inline double dual(const I5_t &a)
{
	return 1.0;

}
inline double undual(const I5i_t &a)
{
	return 1.0;

}
inline bool equals(const vectorE3GA &a, const vectorE3GA &b, const double c)
{
	double d;
	d = a.m_e1 - b.m_e1; if ((d < -c) || (d > c)) return false; /* e1 */
	d = a.m_e2 - b.m_e2; if ((d < -c) || (d > c)) return false; /* e2 */
	d = a.m_e3 - b.m_e3; if ((d < -c) || (d > c)) return false; /* e3 */
	return true;
}
inline bool equals(const bivectorE3GA &a, const bivectorE3GA &b, const double c)
{
	double d;
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotorE3GA &a, const rotorE3GA &b, const double c)
{
	double d;
	d = a.m_scalar - b.m_scalar; if ((d < -c) || (d > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const bivectorE3GA &a, const rotorE3GA &b, const double c)
{
	double d;
	if ((b.m_scalar < -c) || (b.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotorE3GA &a, const bivectorE3GA &b, const double c)
{
	double d;
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotorE3GA &a, const line &b, const double c)
{
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	if ((a.m_e1_e2 < -c) || (a.m_e1_e2 > c)) return false; /* e1^e2 */
	if ((-a.m_e3_e1 < -c) || (-a.m_e3_e1 > c)) return false; /* e1^e3 */
	if ((a.m_e2_e3 < -c) || (a.m_e2_e3 > c)) return false; /* e2^e3 */
	if ((-b.m_e1_no_ni < -c) || (-b.m_e1_no_ni > c)) return false; /* no^e1^ni */
	if ((-b.m_e2_no_ni < -c) || (-b.m_e2_no_ni > c)) return false; /* no^e2^ni */
	if ((b.m_e1_e2_ni < -c) || (b.m_e1_e2_ni > c)) return false; /* e1^e2^ni */
	if ((-b.m_e3_no_ni < -c) || (-b.m_e3_no_ni > c)) return false; /* no^e3^ni */
	if ((b.m_e1_e3_ni < -c) || (b.m_e1_e3_ni > c)) return false; /* e1^e3^ni */
	if ((b.m_e2_e3_ni < -c) || (b.m_e2_e3_ni > c)) return false; /* e2^e3^ni */
	return true;
}
inline bool equals(const evenVersor &a, const plane &b, const double c)
{
	double d;
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	if ((a.m_no_e1 < -c) || (a.m_no_e1 > c)) return false; /* no^e1 */
	if ((a.m_no_e2 < -c) || (a.m_no_e2 > c)) return false; /* no^e2 */
	if ((a.m_e1_e2 < -c) || (a.m_e1_e2 > c)) return false; /* e1^e2 */
	if ((a.m_no_e3 < -c) || (a.m_no_e3 > c)) return false; /* no^e3 */
	if ((-a.m_e3_e1 < -c) || (-a.m_e3_e1 > c)) return false; /* e1^e3 */
	if ((a.m_e2_e3 < -c) || (a.m_e2_e3 > c)) return false; /* e2^e3 */
	if ((a.m_no_e1_e2_e3 < -c) || (a.m_no_e1_e2_e3 > c)) return false; /* no^e1^e2^e3 */
	if ((a.m_no_ni < -c) || (a.m_no_ni > c)) return false; /* no^ni */
	if ((a.m_e1_ni < -c) || (a.m_e1_ni > c)) return false; /* e1^ni */
	if ((a.m_e2_ni < -c) || (a.m_e2_ni > c)) return false; /* e2^ni */
	d = a.m_no_e1_e2_ni - b.m_no_e1_e2_ni; if ((d < -c) || (d > c)) return false; /* no^e1^e2^ni */
	if ((a.m_e3_ni < -c) || (a.m_e3_ni > c)) return false; /* e3^ni */
	d = a.m_no_e1_e3_ni - b.m_no_e1_e3_ni; if ((d < -c) || (d > c)) return false; /* no^e1^e3^ni */
	d = a.m_no_e2_e3_ni - b.m_no_e2_e3_ni; if ((d < -c) || (d > c)) return false; /* no^e2^e3^ni */
	d = a.m_e1_e2_e3_ni - b.m_e1_e2_e3_ni; if ((d < -c) || (d > c)) return false; /* e1^e2^e3^ni */
	return true;
}
inline bool equals(const circle &a, const line &b, const double c)
{
	double d;
	if ((a.m_no_e1_e2 < -c) || (a.m_no_e1_e2 > c)) return false; /* no^e1^e2 */
	if ((a.m_no_e1_e3 < -c) || (a.m_no_e1_e3 > c)) return false; /* no^e1^e3 */
	if ((a.m_no_e2_e3 < -c) || (a.m_no_e2_e3 > c)) return false; /* no^e2^e3 */
	if ((a.m_e1_e2_e3 < -c) || (a.m_e1_e2_e3 > c)) return false; /* e1^e2^e3 */
	d = a.m_no_e1_ni - -b.m_e1_no_ni; if ((d < -c) || (d > c)) return false; /* no^e1^ni */
	d = a.m_no_e2_ni - -b.m_e2_no_ni; if ((d < -c) || (d > c)) return false; /* no^e2^ni */
	d = a.m_e1_e2_ni - b.m_e1_e2_ni; if ((d < -c) || (d > c)) return false; /* e1^e2^ni */
	d = a.m_no_e3_ni - -b.m_e3_no_ni; if ((d < -c) || (d > c)) return false; /* no^e3^ni */
	d = a.m_e1_e3_ni - b.m_e1_e3_ni; if ((d < -c) || (d > c)) return false; /* e1^e3^ni */
	d = a.m_e2_e3_ni - b.m_e2_e3_ni; if ((d < -c) || (d > c)) return false; /* e2^e3^ni */
	return true;
}
inline bool equals(const plane &a, const plane &b, const double c)
{
	double d;
	d = a.m_no_e1_e2_ni - b.m_no_e1_e2_ni; if ((d < -c) || (d > c)) return false; /* no^e1^e2^ni */
	d = a.m_no_e1_e3_ni - b.m_no_e1_e3_ni; if ((d < -c) || (d > c)) return false; /* no^e1^e3^ni */
	d = a.m_no_e2_e3_ni - b.m_no_e2_e3_ni; if ((d < -c) || (d > c)) return false; /* no^e2^e3^ni */
	d = a.m_e1_e2_e3_ni - b.m_e1_e2_e3_ni; if ((d < -c) || (d > c)) return false; /* e1^e2^e3^ni */
	return true;
}
inline bool equals(const normalizedPoint &a, const normalizedPoint &b, const double c)
{
	double d;
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* no */
	d = a.m_e1 - b.m_e1; if ((d < -c) || (d > c)) return false; /* e1 */
	d = a.m_e2 - b.m_e2; if ((d < -c) || (d > c)) return false; /* e2 */
	d = a.m_e3 - b.m_e3; if ((d < -c) || (d > c)) return false; /* e3 */
	d = a.m_ni - b.m_ni; if ((d < -c) || (d > c)) return false; /* ni */
	return true;
}
inline bool equals(const e1_t &a, const e1_t &b, const double c)
{
	double d;
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* e1 */
	return true;
}
inline bool equals(const I5_t &a, const I5i_t &b, const double c)
{
	double d;
	d = 1.0 - -1.0; if ((d < -c) || (d > c)) return false; /* no^e1^e2^e3^ni */
	return true;
}
inline bool equals(const noni_t &a, const pointPair &b, const double c)
{
	double d;
	if ((b.m_no_e1 < -c) || (b.m_no_e1 > c)) return false; /* no^e1 */
	if ((b.m_no_e2 < -c) || (b.m_no_e2 > c)) return false; /* no^e2 */
	if ((b.m_e1_e2 < -c) || (b.m_e1_e2 > c)) return false; /* e1^e2 */
	if ((b.m_no_e3 < -c) || (b.m_no_e3 > c)) return false; /* no^e3 */
	if ((-b.m_e3_e1 < -c) || (-b.m_e3_e1 > c)) return false; /* e1^e3 */
	if ((b.m_e2_e3 < -c) || (b.m_e2_e3 > c)) return false; /* e2^e3 */
	d = 1.0 - b.m_no_ni; if ((d < -c) || (d > c)) return false; /* no^ni */
	if ((b.m_e1_ni < -c) || (b.m_e1_ni > c)) return false; /* e1^ni */
	if ((b.m_e2_ni < -c) || (b.m_e2_ni > c)) return false; /* e2^ni */
	if ((b.m_e3_ni < -c) || (b.m_e3_ni > c)) return false; /* e3^ni */
	return true;
}
inline double extractGrade0(const rotorE3GA &a)
{
	return a.m_scalar;
}
inline bivectorE3GA extractGrade2(const rotorE3GA &a)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline dualSphere extractGrade1(const oddVersor &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			a.m_no, // no
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_ni // ni
		);
}
inline circle extractGrade3(const oddVersor &a)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			a.m_no_e1_e2, // no_e1_e2
			a.m_no_e1_e3, // no_e1_e3
			a.m_no_e2_e3, // no_e2_e3
			a.m_e1_e2_e3, // e1_e2_e3
			a.m_no_e1_ni, // no_e1_ni
			a.m_no_e2_ni, // no_e2_ni
			a.m_e1_e2_ni, // e1_e2_ni
			a.m_no_e3_ni, // no_e3_ni
			a.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni // e2_e3_ni
		);
}
inline double extractGrade4(const oddVersor &a)
{
	return 0.0;
}
inline double extractGrade0(const evenVersor &a)
{
	return a.m_scalar;
}
inline double extractGrade1(const evenVersor &a)
{
	return 0.0;
}
inline sphere extractGrade4(const evenVersor &a)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);
}
inline double extractGrade0(const normalizedPoint &a)
{
	return 0.0;
}
inline normalizedPoint extractGrade1(const normalizedPoint &a)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_ni // ni
		);
}
inline double extractGrade2(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade3(const dualSphere &a)
{
	return 0.0;
}
inline double extractGrade4(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade5(const normalizedPoint &a)
{
	return 0.0;
}
inline double extractGrade0(const e1_t &a)
{
	return 0.0;
}
inline e2_t extractGrade1(const e2_t &a)
{
	return e2_t(		);
}
inline double extractGrade2(const e3_t &a)
{
	return 0.0;
}
inline double extractGrade3(const no_t &a)
{
	return 0.0;
}
inline double extractGrade4(const e1_t &a)
{
	return 0.0;
}
inline double extractGrade0(const I5_t &a)
{
	return 0.0;
}
inline double extractGrade1(const I5i_t &a)
{
	return 0.0;
}
inline double extractGrade2(const I5_t &a)
{
	return 0.0;
}
inline double extractGrade3(const I5i_t &a)
{
	return 0.0;
}
inline double extractGrade4(const I5_t &a)
{
	return 0.0;
}
inline rotorE3GA gp(const vectorE3GA &a, const vectorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor gp(const rotorE3GA &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1+a.m_scalar*b.m_e3), // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline evenVersor gp(const circle &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_no_e1_e2*b.m_e1_e2_ni+a.m_no_e1_e3*b.m_e1_e3_ni-a.m_no_e1_ni*b.m_e1_no_ni+a.m_no_e2_e3*b.m_e2_e3_ni-a.m_no_e2_ni*b.m_e2_no_ni-a.m_no_e3_ni*b.m_e3_no_ni), // scalar
			(a.m_no_e1_e2*b.m_e2_no_ni+a.m_no_e1_e3*b.m_e3_no_ni), // no_e1
			(-a.m_no_e1_e2*b.m_e1_no_ni+a.m_no_e2_e3*b.m_e3_no_ni), // no_e2
			(-a.m_no_e1_e3*b.m_e1_no_ni-a.m_no_e2_e3*b.m_e2_no_ni), // no_e3
			(a.m_no_e1_e3*b.m_e2_e3_ni-a.m_no_e1_ni*b.m_e2_no_ni-a.m_no_e2_e3*b.m_e1_e3_ni+a.m_no_e2_ni*b.m_e1_no_ni), // e1_e2
			(a.m_no_e1_e2*b.m_e1_e3_ni-a.m_no_e1_e3*b.m_e1_e2_ni-a.m_no_e2_ni*b.m_e3_no_ni+a.m_no_e3_ni*b.m_e2_no_ni), // e2_e3
			-(-a.m_no_e1_e2*b.m_e2_e3_ni-a.m_no_e1_ni*b.m_e3_no_ni+a.m_no_e2_e3*b.m_e1_e2_ni+a.m_no_e3_ni*b.m_e1_no_ni), // e3_e1
			(-a.m_e1_e2_e3*b.m_e2_e3_ni+a.m_e1_e2_ni*b.m_e2_no_ni+a.m_e1_e3_ni*b.m_e3_no_ni+a.m_no_e2_ni*b.m_e1_e2_ni+a.m_no_e3_ni*b.m_e1_e3_ni), // e1_ni
			(a.m_e1_e2_e3*b.m_e1_e3_ni-a.m_e1_e2_ni*b.m_e1_no_ni+a.m_e2_e3_ni*b.m_e3_no_ni-a.m_no_e1_ni*b.m_e1_e2_ni+a.m_no_e3_ni*b.m_e2_e3_ni), // e2_ni
			(-a.m_e1_e2_e3*b.m_e1_e2_ni-a.m_e1_e3_ni*b.m_e1_no_ni-a.m_e2_e3_ni*b.m_e2_no_ni-a.m_no_e1_ni*b.m_e1_e3_ni-a.m_no_e2_ni*b.m_e2_e3_ni), // e3_ni
			(-a.m_no_e1_e2*b.m_e1_e2_ni-a.m_no_e1_e3*b.m_e1_e3_ni-a.m_no_e2_e3*b.m_e2_e3_ni), // no_ni
			(a.m_e1_e2_ni*b.m_e3_no_ni-a.m_e1_e3_ni*b.m_e2_no_ni+a.m_e2_e3_ni*b.m_e1_no_ni-a.m_no_e1_ni*b.m_e2_e3_ni+a.m_no_e2_ni*b.m_e1_e3_ni-a.m_no_e3_ni*b.m_e1_e2_ni), // e1_e2_e3_ni
			(a.m_e1_e2_e3*b.m_e1_no_ni-a.m_no_e1_e2*b.m_e1_e3_ni+a.m_no_e1_e3*b.m_e1_e2_ni), // no_e2_e3_ni
			(-a.m_e1_e2_e3*b.m_e2_no_ni+a.m_no_e1_e2*b.m_e2_e3_ni-a.m_no_e2_e3*b.m_e1_e2_ni), // no_e1_e3_ni
			(a.m_e1_e2_e3*b.m_e3_no_ni-a.m_no_e1_e3*b.m_e2_e3_ni+a.m_no_e2_e3*b.m_e1_e3_ni), // no_e1_e2_ni
			(a.m_no_e1_e2*b.m_e3_no_ni-a.m_no_e1_e3*b.m_e2_no_ni+a.m_no_e2_e3*b.m_e1_no_ni) // no_e1_e2_e3
		);

}
inline oddVersor gp(const rotorE3GA &a, const line &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			(-a.m_e1_e2*b.m_e1_e2_ni-a.m_e2_e3*b.m_e2_e3_ni+a.m_e3_e1*b.m_e1_e3_ni), // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			(-a.m_e1_e2*b.m_e2_no_ni+a.m_e3_e1*b.m_e3_no_ni-a.m_scalar*b.m_e1_no_ni), // no_e1_ni
			(a.m_e1_e2*b.m_e1_no_ni-a.m_e2_e3*b.m_e3_no_ni-a.m_scalar*b.m_e2_no_ni), // no_e2_ni
			(a.m_e2_e3*b.m_e1_e3_ni+a.m_e3_e1*b.m_e2_e3_ni+a.m_scalar*b.m_e1_e2_ni), // e1_e2_ni
			(a.m_e2_e3*b.m_e2_no_ni-a.m_e3_e1*b.m_e1_no_ni-a.m_scalar*b.m_e3_no_ni), // no_e3_ni
			(a.m_e1_e2*b.m_e2_e3_ni-a.m_e2_e3*b.m_e1_e2_ni+a.m_scalar*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1_e2*b.m_e1_e3_ni-a.m_e3_e1*b.m_e1_e2_ni+a.m_scalar*b.m_e2_e3_ni), // e2_e3_ni
			(-a.m_e1_e2*b.m_e3_no_ni-a.m_e2_e3*b.m_e1_no_ni-a.m_e3_e1*b.m_e2_no_ni) // no_e1_e2_e3_ni
		);

}
inline oddVersor gp(const vectorE3GA &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA gp(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1+a.m_e2_e3*b.m_scalar-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline evenVersor gp(const plane &a, const rotorE3GA &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			0.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-a.m_e1_e2_e3_ni*b.m_e2_e3, // e1_ni
			-a.m_e1_e2_e3_ni*b.m_e3_e1, // e2_ni
			-a.m_e1_e2_e3_ni*b.m_e1_e2, // e3_ni
			(-a.m_no_e1_e2_ni*b.m_e1_e2+a.m_no_e1_e3_ni*b.m_e3_e1-a.m_no_e2_e3_ni*b.m_e2_e3), // no_ni
			a.m_e1_e2_e3_ni*b.m_scalar, // e1_e2_e3_ni
			(a.m_no_e1_e2_ni*b.m_e3_e1+a.m_no_e1_e3_ni*b.m_e1_e2+a.m_no_e2_e3_ni*b.m_scalar), // no_e2_e3_ni
			(a.m_no_e1_e2_ni*b.m_e2_e3+a.m_no_e1_e3_ni*b.m_scalar-a.m_no_e2_e3_ni*b.m_e1_e2), // no_e1_e3_ni
			(a.m_no_e1_e2_ni*b.m_scalar-a.m_no_e1_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*b.m_e3_e1), // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline oddVersor gp(const plane &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no_e1_e2_ni*b.m_no_e1_e2+a.m_no_e1_e3_ni*b.m_no_e1_e3+a.m_no_e2_e3_ni*b.m_no_e2_e3), // no
			(a.m_e1_e2_e3_ni*b.m_no_e2_e3-a.m_no_e1_e2_ni*b.m_no_e2_ni-a.m_no_e1_e3_ni*b.m_no_e3_ni+a.m_no_e2_e3_ni*b.m_no_e1_e2_e3_ni), // e1
			(-a.m_e1_e2_e3_ni*b.m_no_e1_e3+a.m_no_e1_e2_ni*b.m_no_e1_ni-a.m_no_e1_e3_ni*b.m_no_e1_e2_e3_ni-a.m_no_e2_e3_ni*b.m_no_e3_ni), // e2
			(a.m_e1_e2_e3_ni*b.m_no_e1_e2+a.m_no_e1_e2_ni*b.m_no_e1_e2_e3_ni+a.m_no_e1_e3_ni*b.m_no_e1_ni+a.m_no_e2_e3_ni*b.m_no_e2_ni), // e3
			(a.m_e1_e2_e3_ni*b.m_e1_e2_e3+a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3_ni-a.m_no_e1_e2_ni*b.m_e1_e2_ni-a.m_no_e1_e3_ni*b.m_e1_e3_ni-a.m_no_e2_e3_ni*b.m_e2_e3_ni), // ni
			(-a.m_no_e1_e2_ni*b.m_no+a.m_no_e1_e3_ni*b.m_no_e2_e3-a.m_no_e2_e3_ni*b.m_no_e1_e3), // no_e1_e2
			(-a.m_no_e1_e2_ni*b.m_no_e2_e3-a.m_no_e1_e3_ni*b.m_no+a.m_no_e2_e3_ni*b.m_no_e1_e2), // no_e1_e3
			(a.m_no_e1_e2_ni*b.m_no_e1_e3-a.m_no_e1_e3_ni*b.m_no_e1_e2-a.m_no_e2_e3_ni*b.m_no), // no_e2_e3
			(-a.m_e1_e2_e3_ni*b.m_no-a.m_no_e1_e2_ni*b.m_no_e3_ni+a.m_no_e1_e3_ni*b.m_no_e2_ni-a.m_no_e2_e3_ni*b.m_no_e1_ni), // e1_e2_e3
			(-a.m_e1_e2_e3_ni*b.m_no_e2_e3-a.m_no_e1_e2_ni*b.m_e2-a.m_no_e1_e3_ni*b.m_e3+a.m_no_e2_e3_ni*b.m_e1_e2_e3), // no_e1_ni
			(a.m_e1_e2_e3_ni*b.m_no_e1_e3+a.m_no_e1_e2_ni*b.m_e1-a.m_no_e1_e3_ni*b.m_e1_e2_e3-a.m_no_e2_e3_ni*b.m_e3), // no_e2_ni
			(-a.m_e1_e2_e3_ni*b.m_e3-a.m_e1_e2_e3_ni*b.m_no_e3_ni+a.m_no_e1_e2_ni*b.m_ni-a.m_no_e1_e3_ni*b.m_e2_e3_ni+a.m_no_e2_e3_ni*b.m_e1_e3_ni), // e1_e2_ni
			(-a.m_e1_e2_e3_ni*b.m_no_e1_e2+a.m_no_e1_e2_ni*b.m_e1_e2_e3+a.m_no_e1_e3_ni*b.m_e1+a.m_no_e2_e3_ni*b.m_e2), // no_e3_ni
			(a.m_e1_e2_e3_ni*b.m_e2+a.m_e1_e2_e3_ni*b.m_no_e2_ni+a.m_no_e1_e2_ni*b.m_e2_e3_ni+a.m_no_e1_e3_ni*b.m_ni-a.m_no_e2_e3_ni*b.m_e1_e2_ni), // e1_e3_ni
			(-a.m_e1_e2_e3_ni*b.m_e1-a.m_e1_e2_e3_ni*b.m_no_e1_ni-a.m_no_e1_e2_ni*b.m_e1_e3_ni+a.m_no_e1_e3_ni*b.m_e1_e2_ni+a.m_no_e2_e3_ni*b.m_ni), // e2_e3_ni
			(a.m_e1_e2_e3_ni*b.m_no-a.m_no_e1_e2_ni*b.m_e3+a.m_no_e1_e3_ni*b.m_e2-a.m_no_e2_e3_ni*b.m_e1) // no_e1_e2_e3_ni
		);

}
inline rotorE3GA gp(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2) // e3_e1
		);

}
inline oddVersor gp(const evenVersor &a, const dualSphere &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no_e1*b.m_e1+a.m_no_e2*b.m_e2+a.m_no_e3*b.m_e3-a.m_no_ni*b.m_no+a.m_scalar*b.m_no), // no
			(a.m_e1_e2*b.m_e2-a.m_e1_ni*b.m_no-a.m_e3_e1*b.m_e3+a.m_no_e1*b.m_ni+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3-a.m_e2_ni*b.m_no+a.m_no_e2*b.m_ni+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1-a.m_e3_ni*b.m_no+a.m_no_e3*b.m_ni+a.m_scalar*b.m_e3), // e3
			(-a.m_e1_ni*b.m_e1-a.m_e2_ni*b.m_e2-a.m_e3_ni*b.m_e3+a.m_no_ni*b.m_ni+a.m_scalar*b.m_ni), // ni
			(a.m_e1_e2*b.m_no+a.m_no_e1*b.m_e2+a.m_no_e1_e2_e3*b.m_e3-a.m_no_e1_e2_ni*b.m_no-a.m_no_e2*b.m_e1), // no_e1_e2
			(-a.m_e3_e1*b.m_no+a.m_no_e1*b.m_e3-a.m_no_e1_e2_e3*b.m_e2-a.m_no_e1_e3_ni*b.m_no-a.m_no_e3*b.m_e1), // no_e1_e3
			(a.m_e2_e3*b.m_no+a.m_no_e1_e2_e3*b.m_e1+a.m_no_e2*b.m_e3-a.m_no_e2_e3_ni*b.m_no-a.m_no_e3*b.m_e2), // no_e2_e3
			(a.m_e1_e2*b.m_e3-a.m_e1_e2_e3_ni*b.m_no+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2+a.m_no_e1_e2_e3*b.m_ni), // e1_e2_e3
			(a.m_e1_ni*b.m_no+a.m_no_e1*b.m_ni-a.m_no_e1_e2_ni*b.m_e2-a.m_no_e1_e3_ni*b.m_e3-a.m_no_ni*b.m_e1), // no_e1_ni
			(a.m_e2_ni*b.m_no+a.m_no_e1_e2_ni*b.m_e1+a.m_no_e2*b.m_ni-a.m_no_e2_e3_ni*b.m_e3-a.m_no_ni*b.m_e2), // no_e2_ni
			(a.m_e1_e2*b.m_ni-a.m_e1_e2_e3_ni*b.m_e3-a.m_e1_ni*b.m_e2+a.m_e2_ni*b.m_e1+a.m_no_e1_e2_ni*b.m_ni), // e1_e2_ni
			(a.m_e3_ni*b.m_no+a.m_no_e1_e3_ni*b.m_e1+a.m_no_e2_e3_ni*b.m_e2+a.m_no_e3*b.m_ni-a.m_no_ni*b.m_e3), // no_e3_ni
			(a.m_e1_e2_e3_ni*b.m_e2-a.m_e1_ni*b.m_e3-a.m_e3_e1*b.m_ni+a.m_e3_ni*b.m_e1+a.m_no_e1_e3_ni*b.m_ni), // e1_e3_ni
			(-a.m_e1_e2_e3_ni*b.m_e1+a.m_e2_e3*b.m_ni-a.m_e2_ni*b.m_e3+a.m_e3_ni*b.m_e2+a.m_no_e2_e3_ni*b.m_ni), // e2_e3_ni
			(a.m_e1_e2_e3_ni*b.m_no+a.m_no_e1_e2_e3*b.m_ni-a.m_no_e1_e2_ni*b.m_e3+a.m_no_e1_e3_ni*b.m_e2-a.m_no_e2_e3_ni*b.m_e1) // no_e1_e2_e3_ni
		);

}
inline evenVersor gp(const normalizedPoint &a, const normalizedPoint &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3-a.m_ni-b.m_ni), // scalar
			(-a.m_e1+b.m_e1), // no_e1
			(-a.m_e2+b.m_e2), // no_e2
			(-a.m_e3+b.m_e3), // no_e3
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1), // e3_e1
			(a.m_e1*b.m_ni-a.m_ni*b.m_e1), // e1_ni
			(a.m_e2*b.m_ni-a.m_ni*b.m_e2), // e2_ni
			(a.m_e3*b.m_ni-a.m_ni*b.m_e3), // e3_ni
			(-a.m_ni+b.m_ni), // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline oddVersor gp(const flatPoint &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			-a.m_no_ni*b.m_no, // no
			(-a.m_e1_ni*b.m_no+a.m_e2_ni*b.m_no_e1_e2+a.m_e3_ni*b.m_no_e1_e3-a.m_no_ni*b.m_no_e1_ni), // e1
			(-a.m_e1_ni*b.m_no_e1_e2-a.m_e2_ni*b.m_no+a.m_e3_ni*b.m_no_e2_e3-a.m_no_ni*b.m_no_e2_ni), // e2
			(-a.m_e1_ni*b.m_no_e1_e3-a.m_e2_ni*b.m_no_e2_e3-a.m_e3_ni*b.m_no-a.m_no_ni*b.m_no_e3_ni), // e3
			(-a.m_e1_ni*b.m_e1-a.m_e1_ni*b.m_no_e1_ni-a.m_e2_ni*b.m_e2-a.m_e2_ni*b.m_no_e2_ni-a.m_e3_ni*b.m_e3-a.m_e3_ni*b.m_no_e3_ni+a.m_no_ni*b.m_ni), // ni
			-a.m_no_ni*b.m_no_e1_e2, // no_e1_e2
			-a.m_no_ni*b.m_no_e1_e3, // no_e1_e3
			-a.m_no_ni*b.m_no_e2_e3, // no_e2_e3
			(-a.m_e1_ni*b.m_no_e2_e3+a.m_e2_ni*b.m_no_e1_e3-a.m_e3_ni*b.m_no_e1_e2-a.m_no_ni*b.m_no_e1_e2_e3_ni), // e1_e2_e3
			(a.m_e1_ni*b.m_no-a.m_e2_ni*b.m_no_e1_e2-a.m_e3_ni*b.m_no_e1_e3-a.m_no_ni*b.m_e1), // no_e1_ni
			(a.m_e1_ni*b.m_no_e1_e2+a.m_e2_ni*b.m_no-a.m_e3_ni*b.m_no_e2_e3-a.m_no_ni*b.m_e2), // no_e2_ni
			(-a.m_e1_ni*b.m_e2-a.m_e1_ni*b.m_no_e2_ni+a.m_e2_ni*b.m_e1+a.m_e2_ni*b.m_no_e1_ni-a.m_e3_ni*b.m_e1_e2_e3-a.m_e3_ni*b.m_no_e1_e2_e3_ni+a.m_no_ni*b.m_e1_e2_ni), // e1_e2_ni
			(a.m_e1_ni*b.m_no_e1_e3+a.m_e2_ni*b.m_no_e2_e3+a.m_e3_ni*b.m_no-a.m_no_ni*b.m_e3), // no_e3_ni
			(-a.m_e1_ni*b.m_e3-a.m_e1_ni*b.m_no_e3_ni+a.m_e2_ni*b.m_e1_e2_e3+a.m_e2_ni*b.m_no_e1_e2_e3_ni+a.m_e3_ni*b.m_e1+a.m_e3_ni*b.m_no_e1_ni+a.m_no_ni*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1_ni*b.m_e1_e2_e3-a.m_e1_ni*b.m_no_e1_e2_e3_ni-a.m_e2_ni*b.m_e3-a.m_e2_ni*b.m_no_e3_ni+a.m_e3_ni*b.m_e2+a.m_e3_ni*b.m_no_e2_ni+a.m_no_ni*b.m_e2_e3_ni), // e2_e3_ni
			(a.m_e1_ni*b.m_no_e2_e3-a.m_e2_ni*b.m_no_e1_e3+a.m_e3_ni*b.m_no_e1_e2-a.m_no_ni*b.m_e1_e2_e3) // no_e1_e2_e3_ni
		);

}
inline bivectorE3GA gp(const e1_t &a, const e2_t &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			1.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline freeVector gp(const e3_t &a, const ni_t &b)
{
	return freeVector(freeVector::coord_e1ni_e2ni_e3ni,
			0.0, // e1_ni
			0.0, // e2_ni
			1.0 // e3_ni
		);

}
inline evenVersor gp(const no_t &a, const ni_t &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-1.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			1.0, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline plane gp(const e3_t &a, const I5i_t &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			1.0 // no_e1_e2_ni
		);

}
inline rotorE3GA gp_em(const vectorE3GA &a, const vectorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor gp_em(const rotorE3GA &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1+a.m_scalar*b.m_e3), // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline evenVersor gp_em(const vectorE3GA &a, const line &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			0.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			(-a.m_e2*b.m_e1_e2_ni-a.m_e3*b.m_e1_e3_ni), // e1_ni
			(a.m_e1*b.m_e1_e2_ni-a.m_e3*b.m_e2_e3_ni), // e2_ni
			(a.m_e1*b.m_e1_e3_ni+a.m_e2*b.m_e2_e3_ni), // e3_ni
			(a.m_e1*b.m_e1_no_ni+a.m_e2*b.m_e2_no_ni+a.m_e3*b.m_e3_no_ni), // no_ni
			(a.m_e1*b.m_e2_e3_ni-a.m_e2*b.m_e1_e3_ni+a.m_e3*b.m_e1_e2_ni), // e1_e2_e3_ni
			(a.m_e2*b.m_e3_no_ni-a.m_e3*b.m_e2_no_ni), // no_e2_e3_ni
			(a.m_e1*b.m_e3_no_ni-a.m_e3*b.m_e1_no_ni), // no_e1_e3_ni
			(a.m_e1*b.m_e2_no_ni-a.m_e2*b.m_e1_no_ni), // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline oddVersor gp_em(const rotorE3GA &a, const circle &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(-a.m_e1_e2*b.m_no_e1_e2-a.m_e2_e3*b.m_no_e2_e3+a.m_e3_e1*b.m_no_e1_e3), // no
			-a.m_e2_e3*b.m_e1_e2_e3, // e1
			-a.m_e3_e1*b.m_e1_e2_e3, // e2
			-a.m_e1_e2*b.m_e1_e2_e3, // e3
			(-a.m_e1_e2*b.m_e1_e2_ni-a.m_e2_e3*b.m_e2_e3_ni+a.m_e3_e1*b.m_e1_e3_ni), // ni
			(a.m_e2_e3*b.m_no_e1_e3+a.m_e3_e1*b.m_no_e2_e3+a.m_scalar*b.m_no_e1_e2), // no_e1_e2
			(a.m_e1_e2*b.m_no_e2_e3-a.m_e2_e3*b.m_no_e1_e2+a.m_scalar*b.m_no_e1_e3), // no_e1_e3
			(-a.m_e1_e2*b.m_no_e1_e3-a.m_e3_e1*b.m_no_e1_e2+a.m_scalar*b.m_no_e2_e3), // no_e2_e3
			a.m_scalar*b.m_e1_e2_e3, // e1_e2_e3
			(a.m_e1_e2*b.m_no_e2_ni-a.m_e3_e1*b.m_no_e3_ni+a.m_scalar*b.m_no_e1_ni), // no_e1_ni
			(-a.m_e1_e2*b.m_no_e1_ni+a.m_e2_e3*b.m_no_e3_ni+a.m_scalar*b.m_no_e2_ni), // no_e2_ni
			(a.m_e2_e3*b.m_e1_e3_ni+a.m_e3_e1*b.m_e2_e3_ni+a.m_scalar*b.m_e1_e2_ni), // e1_e2_ni
			(-a.m_e2_e3*b.m_no_e2_ni+a.m_e3_e1*b.m_no_e1_ni+a.m_scalar*b.m_no_e3_ni), // no_e3_ni
			(a.m_e1_e2*b.m_e2_e3_ni-a.m_e2_e3*b.m_e1_e2_ni+a.m_scalar*b.m_e1_e3_ni), // e1_e3_ni
			(-a.m_e1_e2*b.m_e1_e3_ni-a.m_e3_e1*b.m_e1_e2_ni+a.m_scalar*b.m_e2_e3_ni), // e2_e3_ni
			(a.m_e1_e2*b.m_no_e3_ni+a.m_e2_e3*b.m_no_e1_ni+a.m_e3_e1*b.m_no_e2_ni) // no_e1_e2_e3_ni
		);

}
inline oddVersor gp_em(const vectorE3GA &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA gp_em(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1+a.m_e2_e3*b.m_scalar-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline evenVersor gp_em(const plane &a, const rotorE3GA &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			0.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			-a.m_e1_e2_e3_ni*b.m_e2_e3, // e1_ni
			-a.m_e1_e2_e3_ni*b.m_e3_e1, // e2_ni
			-a.m_e1_e2_e3_ni*b.m_e1_e2, // e3_ni
			(-a.m_no_e1_e2_ni*b.m_e1_e2+a.m_no_e1_e3_ni*b.m_e3_e1-a.m_no_e2_e3_ni*b.m_e2_e3), // no_ni
			a.m_e1_e2_e3_ni*b.m_scalar, // e1_e2_e3_ni
			(a.m_no_e1_e2_ni*b.m_e3_e1+a.m_no_e1_e3_ni*b.m_e1_e2+a.m_no_e2_e3_ni*b.m_scalar), // no_e2_e3_ni
			(a.m_no_e1_e2_ni*b.m_e2_e3+a.m_no_e1_e3_ni*b.m_scalar-a.m_no_e2_e3_ni*b.m_e1_e2), // no_e1_e3_ni
			(a.m_no_e1_e2_ni*b.m_scalar-a.m_no_e1_e3_ni*b.m_e2_e3-a.m_no_e2_e3_ni*b.m_e3_e1), // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline oddVersor gp_em(const sphere &a, const circle &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(-a.m_no_e1_e2_e3*b.m_e1_e2_e3-a.m_no_e1_e2_ni*b.m_e1_e2_ni-a.m_no_e1_e3_ni*b.m_e1_e3_ni-a.m_no_e2_e3_ni*b.m_e2_e3_ni), // no
			(-a.m_e1_e2_e3_ni*b.m_e2_e3_ni+a.m_no_e1_e2_e3*b.m_no_e2_e3+a.m_no_e1_e2_ni*b.m_no_e2_ni+a.m_no_e1_e3_ni*b.m_no_e3_ni), // e1
			(a.m_e1_e2_e3_ni*b.m_e1_e3_ni-a.m_no_e1_e2_e3*b.m_no_e1_e3-a.m_no_e1_e2_ni*b.m_no_e1_ni+a.m_no_e2_e3_ni*b.m_no_e3_ni), // e2
			(-a.m_e1_e2_e3_ni*b.m_e1_e2_ni+a.m_no_e1_e2_e3*b.m_no_e1_e2-a.m_no_e1_e3_ni*b.m_no_e1_ni-a.m_no_e2_e3_ni*b.m_no_e2_ni), // e3
			(a.m_e1_e2_e3_ni*b.m_e1_e2_e3+a.m_no_e1_e2_ni*b.m_no_e1_e2+a.m_no_e1_e3_ni*b.m_no_e1_e3+a.m_no_e2_e3_ni*b.m_no_e2_e3), // ni
			(-a.m_e1_e2_e3_ni*b.m_no_e3_ni-a.m_no_e1_e3_ni*b.m_e2_e3_ni+a.m_no_e2_e3_ni*b.m_e1_e3_ni), // no_e1_e2
			(a.m_e1_e2_e3_ni*b.m_no_e2_ni+a.m_no_e1_e2_ni*b.m_e2_e3_ni-a.m_no_e2_e3_ni*b.m_e1_e2_ni), // no_e1_e3
			(-a.m_e1_e2_e3_ni*b.m_no_e1_ni-a.m_no_e1_e2_ni*b.m_e1_e3_ni+a.m_no_e1_e3_ni*b.m_e1_e2_ni), // no_e2_e3
			(a.m_no_e1_e2_ni*b.m_no_e3_ni-a.m_no_e1_e3_ni*b.m_no_e2_ni+a.m_no_e2_e3_ni*b.m_no_e1_ni), // e1_e2_e3
			(-a.m_e1_e2_e3_ni*b.m_no_e2_e3-a.m_no_e1_e2_e3*b.m_e2_e3_ni+a.m_no_e2_e3_ni*b.m_e1_e2_e3), // no_e1_ni
			(a.m_e1_e2_e3_ni*b.m_no_e1_e3+a.m_no_e1_e2_e3*b.m_e1_e3_ni-a.m_no_e1_e3_ni*b.m_e1_e2_e3), // no_e2_ni
			(-a.m_no_e1_e2_e3*b.m_no_e3_ni+a.m_no_e1_e3_ni*b.m_no_e2_e3-a.m_no_e2_e3_ni*b.m_no_e1_e3), // e1_e2_ni
			(-a.m_e1_e2_e3_ni*b.m_no_e1_e2-a.m_no_e1_e2_e3*b.m_e1_e2_ni+a.m_no_e1_e2_ni*b.m_e1_e2_e3), // no_e3_ni
			(a.m_no_e1_e2_e3*b.m_no_e2_ni-a.m_no_e1_e2_ni*b.m_no_e2_e3+a.m_no_e2_e3_ni*b.m_no_e1_e2), // e1_e3_ni
			(-a.m_no_e1_e2_e3*b.m_no_e1_ni+a.m_no_e1_e2_ni*b.m_no_e1_e3-a.m_no_e1_e3_ni*b.m_no_e1_e2), // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA gp_em(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2) // e3_e1
		);

}
inline int gradeBitmap(const rotorE3GA &a, const double b)
{
	int bitmap = 0;
	if ((a.m_scalar < -b) || (a.m_scalar > b)) bitmap |= 1;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const oddVersor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_no < -b) || (a.m_no > b)) bitmap |= 2;
	if ((a.m_e1 < -b) || (a.m_e1 > b)) bitmap |= 2;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) bitmap |= 2;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) bitmap |= 2;
	if ((a.m_ni < -b) || (a.m_ni > b)) bitmap |= 2;
	if ((a.m_no_e1_e2 < -b) || (a.m_no_e1_e2 > b)) bitmap |= 8;
	if ((a.m_no_e1_e3 < -b) || (a.m_no_e1_e3 > b)) bitmap |= 8;
	if ((a.m_no_e2_e3 < -b) || (a.m_no_e2_e3 > b)) bitmap |= 8;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) bitmap |= 8;
	if ((a.m_no_e1_ni < -b) || (a.m_no_e1_ni > b)) bitmap |= 8;
	if ((a.m_no_e2_ni < -b) || (a.m_no_e2_ni > b)) bitmap |= 8;
	if ((a.m_e1_e2_ni < -b) || (a.m_e1_e2_ni > b)) bitmap |= 8;
	if ((a.m_no_e3_ni < -b) || (a.m_no_e3_ni > b)) bitmap |= 8;
	if ((a.m_e1_e3_ni < -b) || (a.m_e1_e3_ni > b)) bitmap |= 8;
	if ((a.m_e2_e3_ni < -b) || (a.m_e2_e3_ni > b)) bitmap |= 8;
	if ((a.m_no_e1_e2_e3_ni < -b) || (a.m_no_e1_e2_e3_ni > b)) bitmap |= 32;
	return bitmap;
}
inline int gradeBitmap(const evenVersor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_scalar < -b) || (a.m_scalar > b)) bitmap |= 1;
	if ((a.m_no_e1 < -b) || (a.m_no_e1 > b)) bitmap |= 4;
	if ((a.m_no_e2 < -b) || (a.m_no_e2 > b)) bitmap |= 4;
	if ((a.m_no_e3 < -b) || (a.m_no_e3 > b)) bitmap |= 4;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	if ((a.m_e1_ni < -b) || (a.m_e1_ni > b)) bitmap |= 4;
	if ((a.m_e2_ni < -b) || (a.m_e2_ni > b)) bitmap |= 4;
	if ((a.m_e3_ni < -b) || (a.m_e3_ni > b)) bitmap |= 4;
	if ((a.m_no_ni < -b) || (a.m_no_ni > b)) bitmap |= 4;
	if ((a.m_e1_e2_e3_ni < -b) || (a.m_e1_e2_e3_ni > b)) bitmap |= 16;
	if ((a.m_no_e2_e3_ni < -b) || (a.m_no_e2_e3_ni > b)) bitmap |= 16;
	if ((a.m_no_e1_e3_ni < -b) || (a.m_no_e1_e3_ni > b)) bitmap |= 16;
	if ((a.m_no_e1_e2_ni < -b) || (a.m_no_e1_e2_ni > b)) bitmap |= 16;
	if ((a.m_no_e1_e2_e3 < -b) || (a.m_no_e1_e2_e3 > b)) bitmap |= 16;
	return bitmap;
}
inline int gradeBitmap(const vectorE3GA &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1 < -b) || (a.m_e1 > b)) bitmap |= 2;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) bitmap |= 2;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const bivectorE3GA &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const pseudoscalar &a, const double b)
{
	int bitmap = 0;
	if ((a.m_no_e1_e2_e3_ni < -b) || (a.m_no_e1_e2_e3_ni > b)) bitmap |= 32;
	return bitmap;
}
inline int gradeBitmap(const circle &a, const double b)
{
	int bitmap = 0;
	if ((a.m_no_e1_e2 < -b) || (a.m_no_e1_e2 > b)) bitmap |= 8;
	if ((a.m_no_e1_e3 < -b) || (a.m_no_e1_e3 > b)) bitmap |= 8;
	if ((a.m_no_e2_e3 < -b) || (a.m_no_e2_e3 > b)) bitmap |= 8;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) bitmap |= 8;
	if ((a.m_no_e1_ni < -b) || (a.m_no_e1_ni > b)) bitmap |= 8;
	if ((a.m_no_e2_ni < -b) || (a.m_no_e2_ni > b)) bitmap |= 8;
	if ((a.m_e1_e2_ni < -b) || (a.m_e1_e2_ni > b)) bitmap |= 8;
	if ((a.m_no_e3_ni < -b) || (a.m_no_e3_ni > b)) bitmap |= 8;
	if ((a.m_e1_e3_ni < -b) || (a.m_e1_e3_ni > b)) bitmap |= 8;
	if ((a.m_e2_e3_ni < -b) || (a.m_e2_e3_ni > b)) bitmap |= 8;
	return bitmap;
}
inline int gradeBitmap(const pointPair &a, const double b)
{
	int bitmap = 0;
	if ((a.m_no_e1 < -b) || (a.m_no_e1 > b)) bitmap |= 4;
	if ((a.m_no_e2 < -b) || (a.m_no_e2 > b)) bitmap |= 4;
	if ((a.m_no_e3 < -b) || (a.m_no_e3 > b)) bitmap |= 4;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	if ((a.m_e1_ni < -b) || (a.m_e1_ni > b)) bitmap |= 4;
	if ((a.m_e2_ni < -b) || (a.m_e2_ni > b)) bitmap |= 4;
	if ((a.m_e3_ni < -b) || (a.m_e3_ni > b)) bitmap |= 4;
	if ((a.m_no_ni < -b) || (a.m_no_ni > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const e1_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const e2_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const noni_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const I5i_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 32;
	return bitmap;
}
inline vectorE3GA hp(const vectorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline bivectorE3GA hp(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline rotorE3GA hp(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar*b.m_scalar, // scalar
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline oddVersor hp(const oddVersor &a, const oddVersor &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no*b.m_no, // no
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3, // e3
			a.m_ni*b.m_ni, // ni
			a.m_no_e1_e2*b.m_no_e1_e2, // no_e1_e2
			a.m_no_e1_e3*b.m_no_e1_e3, // no_e1_e3
			a.m_no_e2_e3*b.m_no_e2_e3, // no_e2_e3
			a.m_e1_e2_e3*b.m_e1_e2_e3, // e1_e2_e3
			a.m_no_e1_ni*b.m_no_e1_ni, // no_e1_ni
			a.m_no_e2_ni*b.m_no_e2_ni, // no_e2_ni
			a.m_e1_e2_ni*b.m_e1_e2_ni, // e1_e2_ni
			a.m_no_e3_ni*b.m_no_e3_ni, // no_e3_ni
			a.m_e1_e3_ni*b.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni*b.m_e2_e3_ni, // e2_e3_ni
			a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline vectorE3GA hp(const vectorE3GA &a, const oddVersor &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline evenVersor hp(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar*b.m_scalar, // scalar
			a.m_no_e1*b.m_no_e1, // no_e1
			a.m_no_e2*b.m_no_e2, // no_e2
			a.m_no_e3*b.m_no_e3, // no_e3
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1, // e3_e1
			a.m_e1_ni*b.m_e1_ni, // e1_ni
			a.m_e2_ni*b.m_e2_ni, // e2_ni
			a.m_e3_ni*b.m_e3_ni, // e3_ni
			a.m_no_ni*b.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni*b.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni*b.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni*b.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni*b.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3*b.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline bivectorE3GA hp(const bivectorE3GA &a, const rotorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline double hp(const circle &a, const evenVersor &b)
{
	return 0.0;

}
inline pseudoscalar hp(const pseudoscalar &a, const oddVersor &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a.m_no_e1_e2_e3_ni*b.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline bivectorE3GA hp(const rotorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline bivectorE3GA hp(const evenVersor &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline plane hp(const sphere &a, const plane &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni*b.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni*b.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni*b.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni*b.m_no_e1_e2_ni // no_e1_e2_ni
		);

}
inline vectorE3GA hp(const normalizedPoint &a, const e1_t &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline vectorE3GA hp(const vectorE3GA &a, const e1_t &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline pseudoscalar hp(const I5_t &a, const pseudoscalar &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			b.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline pseudoscalar hp(const pseudoscalar &a, const I5i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline vectorE3GA ihp(const vectorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline bivectorE3GA ihp(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline rotorE3GA ihp(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((b.m_scalar)), // scalar
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline circle ihp(const circle &a, const oddVersor &b)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			a.m_no_e1_e2/((b.m_no_e1_e2)), // no_e1_e2
			a.m_no_e1_e3/((b.m_no_e1_e3)), // no_e1_e3
			a.m_no_e2_e3/((b.m_no_e2_e3)), // no_e2_e3
			a.m_e1_e2_e3/((b.m_e1_e2_e3)), // e1_e2_e3
			a.m_no_e1_ni/((b.m_no_e1_ni)), // no_e1_ni
			a.m_no_e2_ni/((b.m_no_e2_ni)), // no_e2_ni
			a.m_e1_e2_ni/((b.m_e1_e2_ni)), // e1_e2_ni
			a.m_no_e3_ni/((b.m_no_e3_ni)), // no_e3_ni
			a.m_e1_e3_ni/((b.m_e1_e3_ni)), // e1_e3_ni
			a.m_e2_e3_ni/((b.m_e2_e3_ni)) // e2_e3_ni
		);

}
inline vectorE3GA ihp(const vectorE3GA &a, const oddVersor &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline evenVersor ihp(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar/((b.m_scalar)), // scalar
			a.m_no_e1/((b.m_no_e1)), // no_e1
			a.m_no_e2/((b.m_no_e2)), // no_e2
			a.m_no_e3/((b.m_no_e3)), // no_e3
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)), // e3_e1
			a.m_e1_ni/((b.m_e1_ni)), // e1_ni
			a.m_e2_ni/((b.m_e2_ni)), // e2_ni
			a.m_e3_ni/((b.m_e3_ni)), // e3_ni
			a.m_no_ni/((b.m_no_ni)), // no_ni
			a.m_e1_e2_e3_ni/((b.m_e1_e2_e3_ni)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((b.m_no_e2_e3_ni)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((b.m_no_e1_e3_ni)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((b.m_no_e1_e2_ni)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((b.m_no_e1_e2_e3)) // no_e1_e2_e3
		);

}
inline bivectorE3GA ihp(const bivectorE3GA &a, const rotorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline plane ihp(const plane &a, const evenVersor &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni/((b.m_e1_e2_e3_ni)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((b.m_no_e2_e3_ni)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((b.m_no_e1_e3_ni)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((b.m_no_e1_e2_ni)) // no_e1_e2_ni
		);

}
inline pseudoscalar ihp(const pseudoscalar &a, const oddVersor &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a.m_no_e1_e2_e3_ni/((b.m_no_e1_e2_e3_ni)) // no_e1_e2_e3_ni
		);

}
inline bivectorE3GA ihp(const rotorE3GA &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline bivectorE3GA ihp(const evenVersor &a, const bivectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline dualSphere ihp(const dualSphere &a, const normalizedPoint &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			a.m_no, // no
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)), // e3
			a.m_ni/((b.m_ni)) // ni
		);

}
inline normalizedPoint ihp(const normalizedPoint &a, const normalizedPoint &b)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)), // e3
			a.m_ni/((b.m_ni)) // ni
		);

}
inline vectorE3GA ihp(const vectorE3GA &a, const e1_t &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline pseudoscalar ihp(const I5_t &a, const pseudoscalar &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			1.0 / (b.m_no_e1_e2_e3_ni) // no_e1_e2_e3_ni
		);

}
inline pseudoscalar ihp(const pseudoscalar &a, const I5i_t &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline rotorE3GA increment(const bivectorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotorE3GA increment(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline evenVersor increment(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(1.0+a.m_scalar), // scalar
			a.m_no_e1, // no_e1
			a.m_no_e2, // no_e2
			a.m_no_e3, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni, // e3_ni
			a.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);
}
inline evenVersor increment(const pointPair &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			1.0, // scalar
			a.m_no_e1, // no_e1
			a.m_no_e2, // no_e2
			a.m_no_e3, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni, // e3_ni
			a.m_no_ni, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline evenVersor increment(const noni_t &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			1.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			1.0, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline rotorE3GA decrement(const bivectorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			-1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotorE3GA decrement(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline evenVersor decrement(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(-1.0+a.m_scalar), // scalar
			a.m_no_e1, // no_e1
			a.m_no_e2, // no_e2
			a.m_no_e3, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni, // e3_ni
			a.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);
}
inline evenVersor decrement(const noni_t &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-1.0, // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			1.0, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline translator decrement(const freeVector &a)
{
	return translator(translator::coord_scalar_e1ni_e2ni_e3ni,
			-1.0, // scalar
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni // e3_ni
		);
}
inline double sp(const vectorE3GA &a, const vectorE3GA &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline line lc(const vectorE3GA &a, const plane &b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_e3*b.m_e1_e2_e3_ni, // e1_e2_ni
			-a.m_e2*b.m_e1_e2_e3_ni, // e1_e3_ni
			a.m_e1*b.m_e1_e2_e3_ni, // e2_e3_ni
			-(a.m_e2*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e1_e3_ni), // e1_no_ni
			-(-a.m_e1*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e2_e3_ni), // e2_no_ni
			-(-a.m_e1*b.m_no_e1_e3_ni-a.m_e2*b.m_no_e2_e3_ni) // e3_no_ni
		);

}
inline double rc(const vectorE3GA &a, const line &b)
{
	return 0.0;

}
inline double hip(const vectorE3GA &a, const vectorE3GA &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline plane mhip(const pseudoscalar &a, const vectorE3GA &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			0.0, // e1_e2_e3_ni
			-a.m_no_e1_e2_e3_ni*b.m_e1, // no_e2_e3_ni
			a.m_no_e1_e2_e3_ni*b.m_e2, // no_e1_e3_ni
			-a.m_no_e1_e2_e3_ni*b.m_e3 // no_e1_e2_ni
		);

}
inline double sp(const bivectorE3GA &a, const oddVersor &b)
{
	return 0.0;

}
inline double lc(const bivectorE3GA &a, const vectorE3GA &b)
{
	return 0.0;

}
inline oddVersor rc(const evenVersor &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no_e1*b.m_e1+a.m_no_e2*b.m_e2+a.m_no_e3*b.m_e3), // no
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1), // e3
			(-a.m_e1_ni*b.m_e1-a.m_e2_ni*b.m_e2-a.m_e3_ni*b.m_e3), // ni
			a.m_no_e1_e2_e3*b.m_e3, // no_e1_e2
			-a.m_no_e1_e2_e3*b.m_e2, // no_e1_e3
			a.m_no_e1_e2_e3*b.m_e1, // no_e2_e3
			0.0, // e1_e2_e3
			(-a.m_no_e1_e2_ni*b.m_e2-a.m_no_e1_e3_ni*b.m_e3), // no_e1_ni
			(a.m_no_e1_e2_ni*b.m_e1-a.m_no_e2_e3_ni*b.m_e3), // no_e2_ni
			-a.m_e1_e2_e3_ni*b.m_e3, // e1_e2_ni
			(a.m_no_e1_e3_ni*b.m_e1+a.m_no_e2_e3_ni*b.m_e2), // no_e3_ni
			a.m_e1_e2_e3_ni*b.m_e2, // e1_e3_ni
			-a.m_e1_e2_e3_ni*b.m_e1, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline evenVersor hip(const oddVersor &a, const vectorE3GA &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_no_e1_e2*b.m_e2+a.m_no_e1_e3*b.m_e3), // no_e1
			(-a.m_no_e1_e2*b.m_e1+a.m_no_e2_e3*b.m_e3), // no_e2
			(-a.m_no_e1_e3*b.m_e1-a.m_no_e2_e3*b.m_e2), // no_e3
			a.m_e1_e2_e3*b.m_e3, // e1_e2
			a.m_e1_e2_e3*b.m_e1, // e2_e3
			a.m_e1_e2_e3*b.m_e2, // e3_e1
			(-a.m_e1_e2_ni*b.m_e2-a.m_e1_e3_ni*b.m_e3), // e1_ni
			(a.m_e1_e2_ni*b.m_e1-a.m_e2_e3_ni*b.m_e3), // e2_ni
			(a.m_e1_e3_ni*b.m_e1+a.m_e2_e3_ni*b.m_e2), // e3_ni
			(-a.m_no_e1_ni*b.m_e1-a.m_no_e2_ni*b.m_e2-a.m_no_e3_ni*b.m_e3), // no_ni
			0.0, // e1_e2_e3_ni
			-a.m_no_e1_e2_e3_ni*b.m_e1, // no_e2_e3_ni
			a.m_no_e1_e2_e3_ni*b.m_e2, // no_e1_e3_ni
			-a.m_no_e1_e2_e3_ni*b.m_e3, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);

}
inline vectorE3GA mhip(const bivectorE3GA &a, const vectorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1) // e3
		);

}
inline double sp(const vectorE3GA &a, const pseudoscalar &b)
{
	return 0.0;

}
inline oddVersor lc(const vectorE3GA &a, const evenVersor &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(-a.m_e1*b.m_no_e1-a.m_e2*b.m_no_e2-a.m_e3*b.m_no_e3), // no
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3), // e3
			(a.m_e1*b.m_e1_ni+a.m_e2*b.m_e2_ni+a.m_e3*b.m_e3_ni), // ni
			-a.m_e3*b.m_no_e1_e2_e3, // no_e1_e2
			a.m_e2*b.m_no_e1_e2_e3, // no_e1_e3
			-a.m_e1*b.m_no_e1_e2_e3, // no_e2_e3
			0.0, // e1_e2_e3
			(a.m_e2*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e1_e3_ni), // no_e1_ni
			(-a.m_e1*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e2_e3_ni), // no_e2_ni
			a.m_e3*b.m_e1_e2_e3_ni, // e1_e2_ni
			(-a.m_e1*b.m_no_e1_e3_ni-a.m_e2*b.m_no_e2_e3_ni), // no_e3_ni
			-a.m_e2*b.m_e1_e2_e3_ni, // e1_e3_ni
			a.m_e1*b.m_e1_e2_e3_ni, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline double rc(const vectorE3GA &a, const bivectorE3GA &b)
{
	return 0.0;

}
inline line hip(const vectorE3GA &a, const plane &b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_e3*b.m_e1_e2_e3_ni, // e1_e2_ni
			-a.m_e2*b.m_e1_e2_e3_ni, // e1_e3_ni
			a.m_e1*b.m_e1_e2_e3_ni, // e2_e3_ni
			-(a.m_e2*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e1_e3_ni), // e1_no_ni
			-(-a.m_e1*b.m_no_e1_e2_ni+a.m_e3*b.m_no_e2_e3_ni), // e2_no_ni
			-(-a.m_e1*b.m_no_e1_e3_ni-a.m_e2*b.m_no_e2_e3_ni) // e3_no_ni
		);

}
inline flatPoint mhip(const vectorE3GA &a, const line &b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			(-a.m_e2*b.m_e1_e2_ni-a.m_e3*b.m_e1_e3_ni), // e1_ni
			(a.m_e1*b.m_e1_e2_ni-a.m_e3*b.m_e2_e3_ni), // e2_ni
			(a.m_e1*b.m_e1_e3_ni+a.m_e2*b.m_e2_e3_ni), // e3_ni
			(a.m_e1*b.m_e1_no_ni+a.m_e2*b.m_e2_no_ni+a.m_e3*b.m_e3_no_ni) // no_ni
		);

}
inline double sp(const evenVersor &a, const rotorE3GA &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar);

}
inline rotorE3GA lc(const evenVersor &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1 // e3_e1
		);

}
inline oddVersor rc(const oddVersor &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no*b.m_scalar-a.m_no_e1_e2*b.m_e1_e2+a.m_no_e1_e3*b.m_e3_e1-a.m_no_e2_e3*b.m_e2_e3), // no
			(a.m_e1*b.m_scalar-a.m_e1_e2_e3*b.m_e2_e3), // e1
			(-a.m_e1_e2_e3*b.m_e3_e1+a.m_e2*b.m_scalar), // e2
			(-a.m_e1_e2_e3*b.m_e1_e2+a.m_e3*b.m_scalar), // e3
			(-a.m_e1_e2_ni*b.m_e1_e2+a.m_e1_e3_ni*b.m_e3_e1-a.m_e2_e3_ni*b.m_e2_e3+a.m_ni*b.m_scalar), // ni
			a.m_no_e1_e2*b.m_scalar, // no_e1_e2
			a.m_no_e1_e3*b.m_scalar, // no_e1_e3
			a.m_no_e2_e3*b.m_scalar, // no_e2_e3
			a.m_e1_e2_e3*b.m_scalar, // e1_e2_e3
			(-a.m_no_e1_e2_e3_ni*b.m_e2_e3+a.m_no_e1_ni*b.m_scalar), // no_e1_ni
			(-a.m_no_e1_e2_e3_ni*b.m_e3_e1+a.m_no_e2_ni*b.m_scalar), // no_e2_ni
			a.m_e1_e2_ni*b.m_scalar, // e1_e2_ni
			(-a.m_no_e1_e2_e3_ni*b.m_e1_e2+a.m_no_e3_ni*b.m_scalar), // no_e3_ni
			a.m_e1_e3_ni*b.m_scalar, // e1_e3_ni
			a.m_e2_e3_ni*b.m_scalar, // e2_e3_ni
			a.m_no_e1_e2_e3_ni*b.m_scalar // no_e1_e2_e3_ni
		);

}
inline oddVersor hip(const oddVersor &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(-a.m_no_e1_e2*b.m_e1_e2+a.m_no_e1_e3*b.m_e3_e1-a.m_no_e2_e3*b.m_e2_e3), // no
			(-a.m_e1_e2_e3*b.m_e2_e3-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e1_e2_e3*b.m_e3_e1-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1-a.m_e1_e2_e3*b.m_e1_e2+a.m_e2*b.m_e2_e3), // e3
			(-a.m_e1_e2_ni*b.m_e1_e2+a.m_e1_e3_ni*b.m_e3_e1-a.m_e2_e3_ni*b.m_e2_e3), // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-a.m_no_e1_e2_e3_ni*b.m_e2_e3, // no_e1_ni
			-a.m_no_e1_e2_e3_ni*b.m_e3_e1, // no_e2_ni
			0.0, // e1_e2_ni
			-a.m_no_e1_e2_e3_ni*b.m_e1_e2, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline oddVersor mhip(const oddVersor &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			(a.m_no*b.m_scalar-a.m_no_e1_e2*b.m_e1_e2+a.m_no_e1_e3*b.m_e3_e1-a.m_no_e2_e3*b.m_e2_e3), // no
			(a.m_e1*b.m_scalar-a.m_e1_e2_e3*b.m_e2_e3-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e1_e2_e3*b.m_e3_e1+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1-a.m_e1_e2_e3*b.m_e1_e2+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			(-a.m_e1_e2_ni*b.m_e1_e2+a.m_e1_e3_ni*b.m_e3_e1-a.m_e2_e3_ni*b.m_e2_e3+a.m_ni*b.m_scalar), // ni
			a.m_no_e1_e2*b.m_scalar, // no_e1_e2
			a.m_no_e1_e3*b.m_scalar, // no_e1_e3
			a.m_no_e2_e3*b.m_scalar, // no_e2_e3
			a.m_e1_e2_e3*b.m_scalar, // e1_e2_e3
			(-a.m_no_e1_e2_e3_ni*b.m_e2_e3+a.m_no_e1_ni*b.m_scalar), // no_e1_ni
			(-a.m_no_e1_e2_e3_ni*b.m_e3_e1+a.m_no_e2_ni*b.m_scalar), // no_e2_ni
			a.m_e1_e2_ni*b.m_scalar, // e1_e2_ni
			(-a.m_no_e1_e2_e3_ni*b.m_e1_e2+a.m_no_e3_ni*b.m_scalar), // no_e3_ni
			a.m_e1_e3_ni*b.m_scalar, // e1_e3_ni
			a.m_e2_e3_ni*b.m_scalar, // e2_e3_ni
			a.m_no_e1_e2_e3_ni*b.m_scalar // no_e1_e2_e3_ni
		);

}
inline double sp(const e1_t &a, const rotorE3GA &b)
{
	return 0.0;

}
inline vectorE3GA lc(const e2_t &a, const rotorE3GA &b)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-b.m_e1_e2, // e1
			0.0, // e2
			b.m_e2_e3 // e3
		);

}
inline oddVersor rc(const I5_t &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-b.m_e2_e3, // no_e1_ni
			-b.m_e3_e1, // no_e2_ni
			0.0, // e1_e2_ni
			-b.m_e1_e2, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			b.m_scalar // no_e1_e2_e3_ni
		);

}
inline line hip(const I5i_t &a, const rotorE3GA &b)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			0.0, // e1_e2_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			-b.m_e2_e3, // e1_no_ni
			-b.m_e3_e1, // e2_no_ni
			-b.m_e1_e2 // e3_no_ni
		);

}
inline dualSphere mhip(const no_t &a, const rotorE3GA &b)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			b.m_scalar, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0 // ni
		);

}
inline double sp(const e1_t &a, const e1_t &b)
{
	return 1.0;

}
inline double lc(const e2_t &a, const e3_t &b)
{
	return 0.0;

}
inline double rc(const I5_t &a, const I5i_t &b)
{
	return 1.0;

}
inline plane hip(const I5i_t &a, const ni_t &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			1.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0 // no_e1_e2_ni
		);

}
inline double mhip(const no_t &a, const e1_t &b)
{
	return 0.0;

}
inline double sp(const rotorE3GA &a, const plane &b)
{
	return 0.0;

}
inline oddVersor lc(const rotorE3GA &a, const line &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			(-a.m_e1_e2*b.m_e1_e2_ni-a.m_e2_e3*b.m_e2_e3_ni+a.m_e3_e1*b.m_e1_e3_ni), // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-a.m_scalar*b.m_e1_no_ni, // no_e1_ni
			-a.m_scalar*b.m_e2_no_ni, // no_e2_ni
			a.m_scalar*b.m_e1_e2_ni, // e1_e2_ni
			-a.m_scalar*b.m_e3_no_ni, // no_e3_ni
			a.m_scalar*b.m_e1_e3_ni, // e1_e3_ni
			a.m_scalar*b.m_e2_e3_ni, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA rc(const rotorE3GA &a, const evenVersor &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			a.m_e1_e2*b.m_scalar, // e1_e2
			a.m_e2_e3*b.m_scalar, // e2_e3
			a.m_e3_e1*b.m_scalar // e3_e1
		);

}
inline double hip(const rotorE3GA &a, const bivectorE3GA &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1);

}
inline oddVersor mhip(const rotorE3GA &a, const pseudoscalar &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			0.0, // e1_e2_e3
			-a.m_e2_e3*b.m_no_e1_e2_e3_ni, // no_e1_ni
			-a.m_e3_e1*b.m_no_e1_e2_e3_ni, // no_e2_ni
			0.0, // e1_e2_ni
			-a.m_e1_e2*b.m_no_e1_e2_e3_ni, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			a.m_scalar*b.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline double hip(const ni_t &a, const normalizedPoint &b)
{
	return -1.0;

}
inline double mhip(const ni_t &a, const normalizedPoint &b)
{
	return -1.0;

}
inline double lc(const ni_t &a, const normalizedPoint &b)
{
	return -1.0;

}
inline double rc(const ni_t &a, const normalizedPoint &b)
{
	return -1.0;

}
inline double norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline double norm(const vectorE3GA &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3))));

}
inline double norm_returns_scalar(const vectorE3GA &a) {
	return norm(a);
}
inline double norm(const bivectorE3GA &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1))));

}
inline double norm_returns_scalar(const bivectorE3GA &a) {
	return norm(a);
}
inline double norm(const line &a)
{
	return ::fabs(::sqrt(::fabs((-a.m_e1_no_ni*a.m_e1_no_ni-a.m_e2_no_ni*a.m_e2_no_ni-a.m_e3_no_ni*a.m_e3_no_ni))));

}
inline double norm_returns_scalar(const line &a) {
	return norm(a);
}
inline double norm(const plane &a)
{
	return ::fabs(::sqrt(::fabs((-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni))));

}
inline double norm_returns_scalar(const plane &a) {
	return norm(a);
}
inline double norm(const rotorE3GA &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))));

}
inline double norm_returns_scalar(const rotorE3GA &a) {
	return norm(a);
}
inline double norm(const oddVersor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni))));

}
inline double norm_returns_scalar(const oddVersor &a) {
	return norm(a);
}
inline double norm(const evenVersor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar))));

}
inline double norm_returns_scalar(const evenVersor &a) {
	return norm(a);
}
inline double norm(const normalizedPoint &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni))));

}
inline double norm_returns_scalar(const normalizedPoint &a) {
	return norm(a);
}
inline double norm(const dualSphere &a)
{
	return ::fabs(::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no))));

}
inline double norm_returns_scalar(const dualSphere &a) {
	return norm(a);
}
inline double norm(const pseudoscalar &a)
{
	return ::fabs(::sqrt(::fabs(-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni)));

}
inline double norm_returns_scalar(const pseudoscalar &a) {
	return norm(a);
}
inline double norm(const e1_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const e1_t &a) {
	return norm(a);
}
inline double norm(const noni_t &a)
{
	return ::fabs(-1.0);

}
inline double norm_returns_scalar(const noni_t &a) {
	return norm(a);
}
inline double norm(const I5i_t &a)
{
	return ::fabs(-1.0);

}
inline double norm_returns_scalar(const I5i_t &a) {
	return norm(a);
}
inline double norm2_returns_scalar(const mv &a) {
	return norm2(a);
}
inline double norm2(const vectorE3GA &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_returns_scalar(const vectorE3GA &a) {
	return norm2(a);
}
inline double norm2(const bivectorE3GA &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_returns_scalar(const bivectorE3GA &a) {
	return norm2(a);
}
inline double norm2(const normalizedPoint &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni);

}
inline double norm2_returns_scalar(const normalizedPoint &a) {
	return norm2(a);
}
inline double norm2(const dualSphere &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no);

}
inline double norm2_returns_scalar(const dualSphere &a) {
	return norm2(a);
}
inline double norm2(const circle &a)
{
	return (a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

}
inline double norm2_returns_scalar(const circle &a) {
	return norm2(a);
}
inline double norm2(const sphere &a)
{
	return (2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni);

}
inline double norm2_returns_scalar(const sphere &a) {
	return norm2(a);
}
inline double norm2(const rotorE3GA &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_returns_scalar(const rotorE3GA &a) {
	return norm2(a);
}
inline double norm2(const oddVersor &a)
{
	return (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni);

}
inline double norm2_returns_scalar(const oddVersor &a) {
	return norm2(a);
}
inline double norm2(const evenVersor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

}
inline double norm2_returns_scalar(const evenVersor &a) {
	return norm2(a);
}
inline double norm2(const pseudoscalar &a)
{
	return -a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni;

}
inline double norm2_returns_scalar(const pseudoscalar &a) {
	return norm2(a);
}
inline double norm2(const e3_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const e3_t &a) {
	return norm2(a);
}
inline double norm2(const no_t &a)
{
	return 0.0;

}
inline double norm2_returns_scalar(const no_t &a) {
	return norm2(a);
}
inline double norm2(const I5_t &a)
{
	return -1.0;

}
inline double norm2_returns_scalar(const I5_t &a) {
	return norm2(a);
}
inline double norm_em_returns_scalar(const mv &a) {
	return norm_em(a);
}
inline double norm_em(const vectorE3GA &a)
{
	return ::fabs(::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

}
inline double norm_em_returns_scalar(const vectorE3GA &a) {
	return norm_em(a);
}
inline double norm_em(const bivectorE3GA &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

}
inline double norm_em_returns_scalar(const bivectorE3GA &a) {
	return norm_em(a);
}
inline double norm_em(const freeVector &a)
{
	return ::fabs(::sqrt((a.m_e1_ni*a.m_e1_ni+a.m_e2_ni*a.m_e2_ni+a.m_e3_ni*a.m_e3_ni)));

}
inline double norm_em_returns_scalar(const freeVector &a) {
	return norm_em(a);
}
inline double norm_em(const freeBivector &a)
{
	return ::fabs(::sqrt((a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e3_e1_ni*a.m_e3_e1_ni)));

}
inline double norm_em_returns_scalar(const freeBivector &a) {
	return norm_em(a);
}
inline double norm_em(const rotorE3GA &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

}
inline double norm_em_returns_scalar(const rotorE3GA &a) {
	return norm_em(a);
}
inline double norm_em(const oddVersor &a)
{
	return ::fabs(::sqrt((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e2*a.m_e2+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e3*a.m_e3+a.m_ni*a.m_ni+a.m_no*a.m_no+a.m_no_e1_e2*a.m_no_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+a.m_no_e1_e3*a.m_no_e1_e3+a.m_no_e1_ni*a.m_no_e1_ni+a.m_no_e2_e3*a.m_no_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni)));

}
inline double norm_em_returns_scalar(const oddVersor &a) {
	return norm_em(a);
}
inline double norm_em(const evenVersor &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+a.m_e1_ni*a.m_e1_ni+a.m_e2_e3*a.m_e2_e3+a.m_e2_ni*a.m_e2_ni+a.m_e3_e1*a.m_e3_e1+a.m_e3_ni*a.m_e3_ni+a.m_no_e1*a.m_no_e1+a.m_no_e1_e2_e3*a.m_no_e1_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2*a.m_no_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_e3*a.m_no_e3+a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar)));

}
inline double norm_em_returns_scalar(const evenVersor &a) {
	return norm_em(a);
}
inline double norm_em(const pseudoscalar &a)
{
	return ::fabs(::sqrt(a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni));

}
inline double norm_em_returns_scalar(const pseudoscalar &a) {
	return norm_em(a);
}
inline double norm2_em_returns_scalar(const mv &a) {
	return norm2_em(a);
}
inline double norm2_em(const vectorE3GA &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_em_returns_scalar(const vectorE3GA &a) {
	return norm2_em(a);
}
inline double norm2_em(const bivectorE3GA &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_em_returns_scalar(const bivectorE3GA &a) {
	return norm2_em(a);
}
inline double norm2_em(const line &a)
{
	return (a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e1_no_ni*a.m_e1_no_ni+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e2_no_ni*a.m_e2_no_ni+a.m_e3_no_ni*a.m_e3_no_ni);

}
inline double norm2_em_returns_scalar(const line &a) {
	return norm2_em(a);
}
inline double norm2_em(const plane &a)
{
	return (a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni);

}
inline double norm2_em_returns_scalar(const plane &a) {
	return norm2_em(a);
}
inline double norm2_em(const rotorE3GA &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_em_returns_scalar(const rotorE3GA &a) {
	return norm2_em(a);
}
inline double norm2_em(const oddVersor &a)
{
	return (a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e2*a.m_e2+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e3*a.m_e3+a.m_ni*a.m_ni+a.m_no*a.m_no+a.m_no_e1_e2*a.m_no_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+a.m_no_e1_e3*a.m_no_e1_e3+a.m_no_e1_ni*a.m_no_e1_ni+a.m_no_e2_e3*a.m_no_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni);

}
inline double norm2_em_returns_scalar(const oddVersor &a) {
	return norm2_em(a);
}
inline double norm2_em(const evenVersor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+a.m_e1_ni*a.m_e1_ni+a.m_e2_e3*a.m_e2_e3+a.m_e2_ni*a.m_e2_ni+a.m_e3_e1*a.m_e3_e1+a.m_e3_ni*a.m_e3_ni+a.m_no_e1*a.m_no_e1+a.m_no_e1_e2_e3*a.m_no_e1_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2*a.m_no_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_e3*a.m_no_e3+a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar);

}
inline double norm2_em_returns_scalar(const evenVersor &a) {
	return norm2_em(a);
}
inline double norm2_em(const pseudoscalar &a)
{
	return a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni;

}
inline double norm2_em_returns_scalar(const pseudoscalar &a) {
	return norm2_em(a);
}
inline double norm2_em(const no_t &a)
{
	return 1.0;

}
inline double norm2_em_returns_scalar(const no_t &a) {
	return norm2_em(a);
}
inline double norm2_em(const I5_t &a)
{
	return 1.0;

}
inline double norm2_em_returns_scalar(const I5_t &a) {
	return norm2_em(a);
}
inline double norm2_em(const e1_t &a)
{
	return 1.0;

}
inline double norm2_em_returns_scalar(const e1_t &a) {
	return norm2_em(a);
}
inline bivectorE3GA op(const vectorE3GA &a, const vectorE3GA &b)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor op(const rotorE3GA &a, const vectorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			a.m_scalar*b.m_e1, // e1
			a.m_scalar*b.m_e2, // e2
			a.m_scalar*b.m_e3, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline plane op(const vectorE3GA &a, const line &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			(a.m_e1*b.m_e2_e3_ni-a.m_e2*b.m_e1_e3_ni+a.m_e3*b.m_e1_e2_ni), // e1_e2_e3_ni
			(a.m_e2*b.m_e3_no_ni-a.m_e3*b.m_e2_no_ni), // no_e2_e3_ni
			(a.m_e1*b.m_e3_no_ni-a.m_e3*b.m_e1_no_ni), // no_e1_e3_ni
			(a.m_e1*b.m_e2_no_ni-a.m_e2*b.m_e1_no_ni) // no_e1_e2_ni
		);

}
inline oddVersor op(const rotorE3GA &a, const circle &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0, // ni
			a.m_scalar*b.m_no_e1_e2, // no_e1_e2
			a.m_scalar*b.m_no_e1_e3, // no_e1_e3
			a.m_scalar*b.m_no_e2_e3, // no_e2_e3
			a.m_scalar*b.m_e1_e2_e3, // e1_e2_e3
			a.m_scalar*b.m_no_e1_ni, // no_e1_ni
			a.m_scalar*b.m_no_e2_ni, // no_e2_ni
			a.m_scalar*b.m_e1_e2_ni, // e1_e2_ni
			a.m_scalar*b.m_no_e3_ni, // no_e3_ni
			a.m_scalar*b.m_e1_e3_ni, // e1_e3_ni
			a.m_scalar*b.m_e2_e3_ni, // e2_e3_ni
			(a.m_e1_e2*b.m_no_e3_ni+a.m_e2_e3*b.m_no_e1_ni+a.m_e3_e1*b.m_no_e2_ni) // no_e1_e2_e3_ni
		);

}
inline oddVersor op(const vectorE3GA &a, const rotorE3GA &b)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			0.0, // no
			a.m_e1*b.m_scalar, // e1
			a.m_e2*b.m_scalar, // e2
			a.m_e3*b.m_scalar, // e3
			0.0, // ni
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2), // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0, // e2_e3_ni
			0.0 // no_e1_e2_e3_ni
		);

}
inline rotorE3GA op(const rotorE3GA &a, const rotorE3GA &b)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar*b.m_scalar, // scalar
			(a.m_e1_e2*b.m_scalar+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e2_e3*b.m_scalar+a.m_scalar*b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline plane op(const plane &a, const rotorE3GA &b)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni*b.m_scalar, // e1_e2_e3_ni
			a.m_no_e2_e3_ni*b.m_scalar, // no_e2_e3_ni
			a.m_no_e1_e3_ni*b.m_scalar, // no_e1_e3_ni
			a.m_no_e1_e2_ni*b.m_scalar // no_e1_e2_ni
		);

}
inline pseudoscalar op(const circle &a, const pointPair &b)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			(-a.m_e1_e2_e3*b.m_no_ni+a.m_e1_e2_ni*b.m_no_e3-a.m_e1_e3_ni*b.m_no_e2+a.m_e2_e3_ni*b.m_no_e1+a.m_no_e1_e2*b.m_e3_ni-a.m_no_e1_e3*b.m_e2_ni+a.m_no_e1_ni*b.m_e2_e3+a.m_no_e2_e3*b.m_e1_ni+a.m_no_e2_ni*b.m_e3_e1+a.m_no_e3_ni*b.m_e1_e2) // no_e1_e2_e3_ni
		);

}
inline double op(const bivectorE3GA &a, const bivectorE3GA &b)
{
	return 0.0;

}
inline double op(const pseudoscalar &a, const oddVersor &b)
{
	return 0.0;

}
inline noni_t op(const no_t &a, const ni_t &b)
{
	return noni_t(		);

}
inline flatPoint op(const ni_t &a, const no_t &b)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			-1.0 // no_ni
		);

}
inline normalizedTranslator exp(const freeVector &a)
{
	return normalizedTranslator(normalizedTranslator::coord_e1ni_e2ni_e3ni,
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni // e3_ni
		);
}
inline evenVersor exp(const noni_t &a)
{
	double _alpha = ::sqrt(::fabs(0.99999999999999956));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sinh(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			::cosh(_alpha), // scalar
			0.0, // no_e1
			0.0, // no_e2
			0.0, // no_e3
			0.0, // e1_e2
			0.0, // e2_e3
			0.0, // e3_e1
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			_mul, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline double cosh(const flatPoint &a)
{
	double _alpha = ::sqrt(::fabs(0.99999999999999956*a.m_no_ni*a.m_no_ni));

	return ::cosh(_alpha);
}
inline bivectorE3GA sinh(const bivectorE3GA &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline freeVector sinh(const freeVector &a)
{
	return freeVector(freeVector::coord_e1ni_e2ni_e3ni,
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni // e3_ni
		);
}
inline double cos(const bivectorE3GA &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	return ::cosh(_alpha);
}
inline double cos(const freeVector &a)
{
	return 1.0;
}
inline double cos(const noni_t &a)
{
	double _alpha = ::sqrt(::fabs(0.99999999999999956));

	return ::cos(_alpha);
}
inline bivectorE3GA sin(const bivectorE3GA &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sinh(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline freeVector sin(const freeVector &a)
{
	return freeVector(freeVector::coord_e1ni_e2ni_e3ni,
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni // e3_ni
		);
}
inline flatPoint sin(const noni_t &a)
{
	double _alpha = ::sqrt(::fabs(0.99999999999999956));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			_mul // no_ni
		);
}
inline vectorE3GA negate(const vectorE3GA &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline freeVector negate(const freeVector &a)
{
	return freeVector(freeVector::coord_e1ni_e2ni_e3ni,
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni // e3_ni
		);

}
inline dualSphere negate(const normalizedPoint &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-1.0, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni // ni
		);

}
inline dualSphere negate(const dualSphere &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-a.m_no, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni // ni
		);

}
inline line negate(const line &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			-a.m_e1_no_ni, // e1_no_ni
			-a.m_e2_no_ni, // e2_no_ni
			-a.m_e3_no_ni // e3_no_ni
		);

}
inline sphere negate(const sphere &a)
{
	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			-a.m_no_e2_e3_ni, // no_e2_e3_ni
			-a.m_no_e1_e3_ni, // no_e1_e3_ni
			-a.m_no_e1_e2_ni, // no_e1_e2_ni
			-a.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline rotorE3GA negate(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			-a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor negate(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			-a.m_no, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni, // ni
			-a.m_no_e1_e2, // no_e1_e2
			-a.m_no_e1_e3, // no_e1_e3
			-a.m_no_e2_e3, // no_e2_e3
			-a.m_e1_e2_e3, // e1_e2_e3
			-a.m_no_e1_ni, // no_e1_ni
			-a.m_no_e2_ni, // no_e2_ni
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_no_e3_ni, // no_e3_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline evenVersor negate(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			-a.m_scalar, // scalar
			-a.m_no_e1, // no_e1
			-a.m_no_e2, // no_e2
			-a.m_no_e3, // no_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni, // e3_ni
			-a.m_no_ni, // no_ni
			-a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			-a.m_no_e2_e3_ni, // no_e2_e3_ni
			-a.m_no_e1_e3_ni, // no_e1_e3_ni
			-a.m_no_e1_e2_ni, // no_e1_e2_ni
			-a.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline pseudoscalar negate(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline vectorE3GA negate(const e1_t &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-1.0, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline vectorE3GA negate(const e2_t &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			0.0, // e1
			-1.0, // e2
			0.0 // e3
		);

}
inline flatPoint negate(const noni_t &a)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			-1.0 // no_ni
		);

}
inline double negate(const double a)
{
	return -a;

}
inline vectorE3GA reverse(const vectorE3GA &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);

}
inline bivectorE3GA reverse(const bivectorE3GA &a)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline normalizedPoint reverse(const normalizedPoint &a)
{
	return normalizedPoint(normalizedPoint::coord_e1_e2_e3_ni,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_ni // ni
		);

}
inline dualSphere reverse(const dualSphere &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			a.m_no, // no
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_ni // ni
		);

}
inline line reverse(const line &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			-a.m_e1_no_ni, // e1_no_ni
			-a.m_e2_no_ni, // e2_no_ni
			-a.m_e3_no_ni // e3_no_ni
		);

}
inline circle reverse(const circle &a)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			-a.m_no_e1_e2, // no_e1_e2
			-a.m_no_e1_e3, // no_e1_e3
			-a.m_no_e2_e3, // no_e2_e3
			-a.m_e1_e2_e3, // e1_e2_e3
			-a.m_no_e1_ni, // no_e1_ni
			-a.m_no_e2_ni, // no_e2_ni
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_no_e3_ni, // no_e3_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni // e2_e3_ni
		);

}
inline rotorE3GA reverse(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor reverse(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no, // no
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			a.m_ni, // ni
			-a.m_no_e1_e2, // no_e1_e2
			-a.m_no_e1_e3, // no_e1_e3
			-a.m_no_e2_e3, // no_e2_e3
			-a.m_e1_e2_e3, // e1_e2_e3
			-a.m_no_e1_ni, // no_e1_ni
			-a.m_no_e2_ni, // no_e2_ni
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_no_e3_ni, // no_e3_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline evenVersor reverse(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar, // scalar
			-a.m_no_e1, // no_e1
			-a.m_no_e2, // no_e2
			-a.m_no_e3, // no_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni, // e3_ni
			-a.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline pseudoscalar reverse(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline double reverse(const double a)
{
	return a;

}
inline e1_t reverse(const e1_t &a)
{
	return e1_t(		);

}
inline e3_t reverse(const e3_t &a)
{
	return e3_t(		);

}
inline pseudoscalar reverse(const I5i_t &a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-1.0 // no_e1_e2_e3_ni
		);

}
inline vectorE3GA cliffordConjugate(const vectorE3GA &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline pointPair cliffordConjugate(const pointPair &a)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			-a.m_no_e1, // no_e1
			-a.m_no_e2, // no_e2
			-a.m_no_e3, // no_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni, // e3_ni
			-a.m_no_ni // no_ni
		);

}
inline dualSphere cliffordConjugate(const normalizedPoint &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-1.0, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni // ni
		);

}
inline freeVector cliffordConjugate(const freeVector &a)
{
	return freeVector(freeVector::coord_e1ni_e2ni_e3ni,
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni // e3_ni
		);

}
inline line cliffordConjugate(const line &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_e1_e2_ni, // e1_e2_ni
			a.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni, // e2_e3_ni
			a.m_e1_no_ni, // e1_no_ni
			a.m_e2_no_ni, // e2_no_ni
			a.m_e3_no_ni // e3_no_ni
		);

}
inline plane cliffordConjugate(const plane &a)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni // no_e1_e2_ni
		);

}
inline rotorE3GA cliffordConjugate(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline oddVersor cliffordConjugate(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			-a.m_no, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni, // ni
			a.m_no_e1_e2, // no_e1_e2
			a.m_no_e1_e3, // no_e1_e3
			a.m_no_e2_e3, // no_e2_e3
			a.m_e1_e2_e3, // e1_e2_e3
			a.m_no_e1_ni, // no_e1_ni
			a.m_no_e2_ni, // no_e2_ni
			a.m_e1_e2_ni, // e1_e2_ni
			a.m_no_e3_ni, // no_e3_ni
			a.m_e1_e3_ni, // e1_e3_ni
			a.m_e2_e3_ni, // e2_e3_ni
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline evenVersor cliffordConjugate(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar, // scalar
			-a.m_no_e1, // no_e1
			-a.m_no_e2, // no_e2
			-a.m_no_e3, // no_e3
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1, // e3_e1
			-a.m_e1_ni, // e1_ni
			-a.m_e2_ni, // e2_ni
			-a.m_e3_ni, // e3_ni
			-a.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline pseudoscalar cliffordConjugate(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline double cliffordConjugate(const double a)
{
	return a;

}
inline vectorE3GA cliffordConjugate(const e1_t &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-1.0, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline flatPoint cliffordConjugate(const noni_t &a)
{
	return flatPoint(flatPoint::coord_e1ni_e2ni_e3ni_noni,
			0.0, // e1_ni
			0.0, // e2_ni
			0.0, // e3_ni
			-1.0 // no_ni
		);

}
inline I3_t cliffordConjugate(const I3_t &a)
{
	return I3_t(		);

}
inline vectorE3GA gradeInvolution(const vectorE3GA &a)
{
	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline bivectorE3GA gradeInvolution(const bivectorE3GA &a)
{
	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline dualSphere gradeInvolution(const normalizedPoint &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-1.0, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni // ni
		);

}
inline dualSphere gradeInvolution(const dualSphere &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-a.m_no, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni // ni
		);

}
inline line gradeInvolution(const line &a)
{
	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			-a.m_e1_no_ni, // e1_no_ni
			-a.m_e2_no_ni, // e2_no_ni
			-a.m_e3_no_ni // e3_no_ni
		);

}
inline plane gradeInvolution(const plane &a)
{
	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni // no_e1_e2_ni
		);

}
inline rotorE3GA gradeInvolution(const rotorE3GA &a)
{
	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline oddVersor gradeInvolution(const oddVersor &a)
{
	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			-a.m_no, // no
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3, // e3
			-a.m_ni, // ni
			-a.m_no_e1_e2, // no_e1_e2
			-a.m_no_e1_e3, // no_e1_e3
			-a.m_no_e2_e3, // no_e2_e3
			-a.m_e1_e2_e3, // e1_e2_e3
			-a.m_no_e1_ni, // no_e1_ni
			-a.m_no_e2_ni, // no_e2_ni
			-a.m_e1_e2_ni, // e1_e2_ni
			-a.m_no_e3_ni, // no_e3_ni
			-a.m_e1_e3_ni, // e1_e3_ni
			-a.m_e2_e3_ni, // e2_e3_ni
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline evenVersor gradeInvolution(const evenVersor &a)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar, // scalar
			a.m_no_e1, // no_e1
			a.m_no_e2, // no_e2
			a.m_no_e3, // no_e3
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1, // e3_e1
			a.m_e1_ni, // e1_ni
			a.m_e2_ni, // e2_ni
			a.m_e3_ni, // e3_ni
			a.m_no_ni, // no_ni
			a.m_e1_e2_e3_ni, // e1_e2_e3_ni
			a.m_no_e2_e3_ni, // no_e2_e3_ni
			a.m_no_e1_e3_ni, // no_e1_e3_ni
			a.m_no_e1_e2_ni, // no_e1_e2_ni
			a.m_no_e1_e2_e3 // no_e1_e2_e3
		);

}
inline pseudoscalar gradeInvolution(const pseudoscalar &a)
{
	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			-a.m_no_e1_e2_e3_ni // no_e1_e2_e3_ni
		);

}
inline double gradeInvolution(const double a)
{
	return a;

}
inline dualSphere gradeInvolution(const no_t &a)
{
	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			-1.0, // no
			0.0, // e1
			0.0, // e2
			0.0, // e3
			0.0 // ni
		);

}
inline dualPlane gradeInvolution(const ni_t &a)
{
	return dualPlane(dualPlane::coord_e1_e2_e3_ni,
			0.0, // e1
			0.0, // e2
			0.0, // e3
			-1.0 // ni
		);

}
inline circle gradeInvolution(const I3_t &a)
{
	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			0.0, // no_e1_e2
			0.0, // no_e1_e3
			0.0, // no_e2_e3
			-1.0, // e1_e2_e3
			0.0, // no_e1_ni
			0.0, // no_e2_ni
			0.0, // e1_e2_ni
			0.0, // no_e3_ni
			0.0, // e1_e3_ni
			0.0 // e2_e3_ni
		);

}
inline vectorE3GA unit(const vectorE3GA &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)) // e3
		);
}
inline bivectorE3GA unit(const bivectorE3GA &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline line unit(const line &a)
{
	double _n_ = ::sqrt(::fabs((-a.m_e1_no_ni*a.m_e1_no_ni-a.m_e2_no_ni*a.m_e2_no_ni-a.m_e3_no_ni*a.m_e3_no_ni)));

	return line(line::coord_e1e2ni_e1e3ni_e2e3ni_e1noni_e2noni_e3noni,
			a.m_e1_e2_ni/((_n_)), // e1_e2_ni
			a.m_e1_e3_ni/((_n_)), // e1_e3_ni
			a.m_e2_e3_ni/((_n_)), // e2_e3_ni
			a.m_e1_no_ni/((_n_)), // e1_no_ni
			a.m_e2_no_ni/((_n_)), // e2_no_ni
			a.m_e3_no_ni/((_n_)) // e3_no_ni
		);
}
inline sphere unit(const sphere &a)
{
	double _n_ = ::sqrt(::fabs((2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni)));

	return sphere(sphere::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_e1_e2_e3_ni/((_n_)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((_n_)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((_n_)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((_n_)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((_n_)) // no_e1_e2_e3
		);
}
inline rotorE3GA unit(const rotorE3GA &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n_)), // scalar
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline oddVersor unit(const oddVersor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+-2.0*a.m_e1_e2_ni*a.m_no_e1_e2+-2.0*a.m_e1_e3_ni*a.m_no_e1_e3+a.m_e2*a.m_e2+-2.0*a.m_e2_e3_ni*a.m_no_e2_e3+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni-a.m_no_e1_ni*a.m_no_e1_ni-a.m_no_e2_ni*a.m_no_e2_ni-a.m_no_e3_ni*a.m_no_e3_ni)));

	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no/((_n_)), // no
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_ni/((_n_)), // ni
			a.m_no_e1_e2/((_n_)), // no_e1_e2
			a.m_no_e1_e3/((_n_)), // no_e1_e3
			a.m_no_e2_e3/((_n_)), // no_e2_e3
			a.m_e1_e2_e3/((_n_)), // e1_e2_e3
			a.m_no_e1_ni/((_n_)), // no_e1_ni
			a.m_no_e2_ni/((_n_)), // no_e2_ni
			a.m_e1_e2_ni/((_n_)), // e1_e2_ni
			a.m_no_e3_ni/((_n_)), // no_e3_ni
			a.m_e1_e3_ni/((_n_)), // e1_e3_ni
			a.m_e2_e3_ni/((_n_)), // e2_e3_ni
			a.m_no_e1_e2_e3_ni/((_n_)) // no_e1_e2_e3_ni
		);
}
inline evenVersor unit(const evenVersor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_e2_e3_ni*a.m_no_e1_e2_e3+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_e1_e2_ni*a.m_no_e1_e2_ni-a.m_no_e1_e3_ni*a.m_no_e1_e3_ni-a.m_no_e2_e3_ni*a.m_no_e2_e3_ni-a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar)));

	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar/((_n_)), // scalar
			a.m_no_e1/((_n_)), // no_e1
			a.m_no_e2/((_n_)), // no_e2
			a.m_no_e3/((_n_)), // no_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)), // e3_e1
			a.m_e1_ni/((_n_)), // e1_ni
			a.m_e2_ni/((_n_)), // e2_ni
			a.m_e3_ni/((_n_)), // e3_ni
			a.m_no_ni/((_n_)), // no_ni
			a.m_e1_e2_e3_ni/((_n_)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((_n_)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((_n_)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((_n_)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((_n_)) // no_e1_e2_e3
		);
}
inline dualSphere unit(const normalizedPoint &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni)));

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			1.0 / (_n_), // no
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_ni/((_n_)) // ni
		);
}
inline dualSphere unit(const dualSphere &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3+-2.0*a.m_ni*a.m_no)));

	return dualSphere(dualSphere::coord_no_e1_e2_e3_ni,
			a.m_no/((_n_)), // no
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_ni/((_n_)) // ni
		);
}
inline pseudoscalar unit(const pseudoscalar &a)
{
	double _n_ = ::sqrt(::fabs(-a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni));

	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a.m_no_e1_e2_e3_ni/((_n_)) // no_e1_e2_e3_ni
		);
}
inline pointPair unit(const pointPair &a)
{
	double _n_ = ::sqrt(::fabs((a.m_e1_e2*a.m_e1_e2+2.0*a.m_e1_ni*a.m_no_e1+a.m_e2_e3*a.m_e2_e3+2.0*a.m_e2_ni*a.m_no_e2+a.m_e3_e1*a.m_e3_e1+2.0*a.m_e3_ni*a.m_no_e3-a.m_no_ni*a.m_no_ni)));

	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			a.m_no_e1/((_n_)), // no_e1
			a.m_no_e2/((_n_)), // no_e2
			a.m_no_e3/((_n_)), // no_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)), // e3_e1
			a.m_e1_ni/((_n_)), // e1_ni
			a.m_e2_ni/((_n_)), // e2_ni
			a.m_e3_ni/((_n_)), // e3_ni
			a.m_no_ni/((_n_)) // no_ni
		);
}
inline e2_t unit(const e2_t &a)
{
	return e2_t(		);
}
inline I5_t unit(const I5_t &a)
{
	return I5_t(		);
}
inline vectorE3GA unit_em(const vectorE3GA &a)
{
	double _n_ = ::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return vectorE3GA(vectorE3GA::coord_e1_e2_e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)) // e3
		);
}
inline bivectorE3GA unit_em(const bivectorE3GA &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1));

	return bivectorE3GA(bivectorE3GA::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline circle unit_em(const circle &a)
{
	double _n_ = ::sqrt((a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_no_e1_e2*a.m_no_e1_e2+a.m_no_e1_e3*a.m_no_e1_e3+a.m_no_e1_ni*a.m_no_e1_ni+a.m_no_e2_e3*a.m_no_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni));

	return circle(circle::coord_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni,
			a.m_no_e1_e2/((_n_)), // no_e1_e2
			a.m_no_e1_e3/((_n_)), // no_e1_e3
			a.m_no_e2_e3/((_n_)), // no_e2_e3
			a.m_e1_e2_e3/((_n_)), // e1_e2_e3
			a.m_no_e1_ni/((_n_)), // no_e1_ni
			a.m_no_e2_ni/((_n_)), // no_e2_ni
			a.m_e1_e2_ni/((_n_)), // e1_e2_ni
			a.m_no_e3_ni/((_n_)), // no_e3_ni
			a.m_e1_e3_ni/((_n_)), // e1_e3_ni
			a.m_e2_e3_ni/((_n_)) // e2_e3_ni
		);
}
inline plane unit_em(const plane &a)
{
	double _n_ = ::sqrt((a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni));

	return plane(plane::coord_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni,
			a.m_e1_e2_e3_ni/((_n_)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((_n_)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((_n_)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((_n_)) // no_e1_e2_ni
		);
}
inline rotorE3GA unit_em(const rotorE3GA &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar));

	return rotorE3GA(rotorE3GA::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n_)), // scalar
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline oddVersor unit_em(const oddVersor &a)
{
	double _n_ = ::sqrt((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e1_e2_ni*a.m_e1_e2_ni+a.m_e1_e3_ni*a.m_e1_e3_ni+a.m_e2*a.m_e2+a.m_e2_e3_ni*a.m_e2_e3_ni+a.m_e3*a.m_e3+a.m_ni*a.m_ni+a.m_no*a.m_no+a.m_no_e1_e2*a.m_no_e1_e2+a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni+a.m_no_e1_e3*a.m_no_e1_e3+a.m_no_e1_ni*a.m_no_e1_ni+a.m_no_e2_e3*a.m_no_e2_e3+a.m_no_e2_ni*a.m_no_e2_ni+a.m_no_e3_ni*a.m_no_e3_ni));

	return oddVersor(oddVersor::coord_no_e1_e2_e3_ni_noe1e2_noe1e3_noe2e3_e1e2e3_noe1ni_noe2ni_e1e2ni_noe3ni_e1e3ni_e2e3ni_noe1e2e3ni,
			a.m_no/((_n_)), // no
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_ni/((_n_)), // ni
			a.m_no_e1_e2/((_n_)), // no_e1_e2
			a.m_no_e1_e3/((_n_)), // no_e1_e3
			a.m_no_e2_e3/((_n_)), // no_e2_e3
			a.m_e1_e2_e3/((_n_)), // e1_e2_e3
			a.m_no_e1_ni/((_n_)), // no_e1_ni
			a.m_no_e2_ni/((_n_)), // no_e2_ni
			a.m_e1_e2_ni/((_n_)), // e1_e2_ni
			a.m_no_e3_ni/((_n_)), // no_e3_ni
			a.m_e1_e3_ni/((_n_)), // e1_e3_ni
			a.m_e2_e3_ni/((_n_)), // e2_e3_ni
			a.m_no_e1_e2_e3_ni/((_n_)) // no_e1_e2_e3_ni
		);
}
inline evenVersor unit_em(const evenVersor &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e1_e2_e3_ni*a.m_e1_e2_e3_ni+a.m_e1_ni*a.m_e1_ni+a.m_e2_e3*a.m_e2_e3+a.m_e2_ni*a.m_e2_ni+a.m_e3_e1*a.m_e3_e1+a.m_e3_ni*a.m_e3_ni+a.m_no_e1*a.m_no_e1+a.m_no_e1_e2_e3*a.m_no_e1_e2_e3+a.m_no_e1_e2_ni*a.m_no_e1_e2_ni+a.m_no_e1_e3_ni*a.m_no_e1_e3_ni+a.m_no_e2*a.m_no_e2+a.m_no_e2_e3_ni*a.m_no_e2_e3_ni+a.m_no_e3*a.m_no_e3+a.m_no_ni*a.m_no_ni+a.m_scalar*a.m_scalar));

	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar/((_n_)), // scalar
			a.m_no_e1/((_n_)), // no_e1
			a.m_no_e2/((_n_)), // no_e2
			a.m_no_e3/((_n_)), // no_e3
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)), // e3_e1
			a.m_e1_ni/((_n_)), // e1_ni
			a.m_e2_ni/((_n_)), // e2_ni
			a.m_e3_ni/((_n_)), // e3_ni
			a.m_no_ni/((_n_)), // no_ni
			a.m_e1_e2_e3_ni/((_n_)), // e1_e2_e3_ni
			a.m_no_e2_e3_ni/((_n_)), // no_e2_e3_ni
			a.m_no_e1_e3_ni/((_n_)), // no_e1_e3_ni
			a.m_no_e1_e2_ni/((_n_)), // no_e1_e2_ni
			a.m_no_e1_e2_e3/((_n_)) // no_e1_e2_e3
		);
}
inline pseudoscalar unit_em(const pseudoscalar &a)
{
	double _n_ = ::sqrt(a.m_no_e1_e2_e3_ni*a.m_no_e1_e2_e3_ni);

	return pseudoscalar(pseudoscalar::coord_noe1e2e3ni,
			a.m_no_e1_e2_e3_ni/((_n_)) // no_e1_e2_e3_ni
		);
}
inline evenVersor add(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_scalar+b.m_scalar), // scalar
			(a.m_no_e1+b.m_no_e1), // no_e1
			(a.m_no_e2+b.m_no_e2), // no_e2
			(a.m_no_e3+b.m_no_e3), // no_e3
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1), // e3_e1
			(a.m_e1_ni+b.m_e1_ni), // e1_ni
			(a.m_e2_ni+b.m_e2_ni), // e2_ni
			(a.m_e3_ni+b.m_e3_ni), // e3_ni
			(a.m_no_ni+b.m_no_ni), // no_ni
			(a.m_e1_e2_e3_ni+b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(a.m_no_e2_e3_ni+b.m_no_e2_e3_ni), // no_e2_e3_ni
			(a.m_no_e1_e3_ni+b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_no_e1_e2_ni+b.m_no_e1_e2_ni), // no_e1_e2_ni
			(a.m_no_e1_e2_e3+b.m_no_e1_e2_e3) // no_e1_e2_e3
		);

}
inline evenVersor gp(const pointPair &a, const pointPair &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e1_ni*b.m_no_e1-a.m_e2_e3*b.m_e2_e3-a.m_e2_ni*b.m_no_e2-a.m_e3_e1*b.m_e3_e1-a.m_e3_ni*b.m_no_e3-a.m_no_e1*b.m_e1_ni-a.m_no_e2*b.m_e2_ni-a.m_no_e3*b.m_e3_ni+a.m_no_ni*b.m_no_ni), // scalar
			(a.m_e1_e2*b.m_no_e2-a.m_e3_e1*b.m_no_e3+a.m_no_e1*b.m_no_ni-a.m_no_e2*b.m_e1_e2+a.m_no_e3*b.m_e3_e1-a.m_no_ni*b.m_no_e1), // no_e1
			(-a.m_e1_e2*b.m_no_e1+a.m_e2_e3*b.m_no_e3+a.m_no_e1*b.m_e1_e2+a.m_no_e2*b.m_no_ni-a.m_no_e3*b.m_e2_e3-a.m_no_ni*b.m_no_e2), // no_e2
			(-a.m_e2_e3*b.m_no_e2+a.m_e3_e1*b.m_no_e1-a.m_no_e1*b.m_e3_e1+a.m_no_e2*b.m_e2_e3+a.m_no_e3*b.m_no_ni-a.m_no_ni*b.m_no_e3), // no_e3
			(-a.m_e1_ni*b.m_no_e2-a.m_e2_e3*b.m_e3_e1+a.m_e2_ni*b.m_no_e1+a.m_e3_e1*b.m_e2_e3-a.m_no_e1*b.m_e2_ni+a.m_no_e2*b.m_e1_ni), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e2_ni*b.m_no_e3-a.m_e3_e1*b.m_e1_e2+a.m_e3_ni*b.m_no_e2-a.m_no_e2*b.m_e3_ni+a.m_no_e3*b.m_e2_ni), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e1_ni*b.m_no_e3-a.m_e2_e3*b.m_e1_e2+a.m_e3_ni*b.m_no_e1-a.m_no_e1*b.m_e3_ni+a.m_no_e3*b.m_e1_ni), // e3_e1
			(a.m_e1_e2*b.m_e2_ni-a.m_e1_ni*b.m_no_ni-a.m_e2_ni*b.m_e1_e2-a.m_e3_e1*b.m_e3_ni+a.m_e3_ni*b.m_e3_e1+a.m_no_ni*b.m_e1_ni), // e1_ni
			(-a.m_e1_e2*b.m_e1_ni+a.m_e1_ni*b.m_e1_e2+a.m_e2_e3*b.m_e3_ni-a.m_e2_ni*b.m_no_ni-a.m_e3_ni*b.m_e2_e3+a.m_no_ni*b.m_e2_ni), // e2_ni
			(-a.m_e1_ni*b.m_e3_e1-a.m_e2_e3*b.m_e2_ni+a.m_e2_ni*b.m_e2_e3+a.m_e3_e1*b.m_e1_ni-a.m_e3_ni*b.m_no_ni+a.m_no_ni*b.m_e3_ni), // e3_ni
			(-a.m_e1_ni*b.m_no_e1-a.m_e2_ni*b.m_no_e2-a.m_e3_ni*b.m_no_e3+a.m_no_e1*b.m_e1_ni+a.m_no_e2*b.m_e2_ni+a.m_no_e3*b.m_e3_ni), // no_ni
			(a.m_e1_e2*b.m_e3_ni+a.m_e1_ni*b.m_e2_e3+a.m_e2_e3*b.m_e1_ni+a.m_e2_ni*b.m_e3_e1+a.m_e3_e1*b.m_e2_ni+a.m_e3_ni*b.m_e1_e2), // e1_e2_e3_ni
			(a.m_e2_e3*b.m_no_ni-a.m_e2_ni*b.m_no_e3+a.m_e3_ni*b.m_no_e2+a.m_no_e2*b.m_e3_ni-a.m_no_e3*b.m_e2_ni+a.m_no_ni*b.m_e2_e3), // no_e2_e3_ni
			(-a.m_e1_ni*b.m_no_e3-a.m_e3_e1*b.m_no_ni+a.m_e3_ni*b.m_no_e1+a.m_no_e1*b.m_e3_ni-a.m_no_e3*b.m_e1_ni-a.m_no_ni*b.m_e3_e1), // no_e1_e3_ni
			(a.m_e1_e2*b.m_no_ni-a.m_e1_ni*b.m_no_e2+a.m_e2_ni*b.m_no_e1+a.m_no_e1*b.m_e2_ni-a.m_no_e2*b.m_e1_ni+a.m_no_ni*b.m_e1_e2), // no_e1_e2_ni
			(a.m_e1_e2*b.m_no_e3+a.m_e2_e3*b.m_no_e1+a.m_e3_e1*b.m_no_e2+a.m_no_e1*b.m_e2_e3+a.m_no_e2*b.m_e3_e1+a.m_no_e3*b.m_e1_e2) // no_e1_e2_e3
		);

}
inline evenVersor subtract(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(a.m_scalar-b.m_scalar), // scalar
			(a.m_no_e1-b.m_no_e1), // no_e1
			(a.m_no_e2-b.m_no_e2), // no_e2
			(a.m_no_e3-b.m_no_e3), // no_e3
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1), // e3_e1
			(a.m_e1_ni-b.m_e1_ni), // e1_ni
			(a.m_e2_ni-b.m_e2_ni), // e2_ni
			(a.m_e3_ni-b.m_e3_ni), // e3_ni
			(a.m_no_ni-b.m_no_ni), // no_ni
			(a.m_e1_e2_e3_ni-b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(a.m_no_e2_e3_ni-b.m_no_e2_e3_ni), // no_e2_e3_ni
			(a.m_no_e1_e3_ni-b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_no_e1_e2_ni-b.m_no_e1_e2_ni), // no_e1_e2_ni
			(a.m_no_e1_e2_e3-b.m_no_e1_e2_e3) // no_e1_e2_e3
		);

}
inline evenVersor gp(const evenVersor &a, const pointPair &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e1_ni*b.m_no_e1-a.m_e2_e3*b.m_e2_e3-a.m_e2_ni*b.m_no_e2-a.m_e3_e1*b.m_e3_e1-a.m_e3_ni*b.m_no_e3-a.m_no_e1*b.m_e1_ni-a.m_no_e2*b.m_e2_ni-a.m_no_e3*b.m_e3_ni+a.m_no_ni*b.m_no_ni), // scalar
			(a.m_e1_e2*b.m_no_e2-a.m_e3_e1*b.m_no_e3+a.m_no_e1*b.m_no_ni-a.m_no_e1_e2_e3*b.m_e2_e3-a.m_no_e1_e2_ni*b.m_no_e2-a.m_no_e1_e3_ni*b.m_no_e3-a.m_no_e2*b.m_e1_e2+a.m_no_e3*b.m_e3_e1-a.m_no_ni*b.m_no_e1+a.m_scalar*b.m_no_e1), // no_e1
			(-a.m_e1_e2*b.m_no_e1+a.m_e2_e3*b.m_no_e3+a.m_no_e1*b.m_e1_e2-a.m_no_e1_e2_e3*b.m_e3_e1+a.m_no_e1_e2_ni*b.m_no_e1+a.m_no_e2*b.m_no_ni-a.m_no_e2_e3_ni*b.m_no_e3-a.m_no_e3*b.m_e2_e3-a.m_no_ni*b.m_no_e2+a.m_scalar*b.m_no_e2), // no_e2
			(-a.m_e2_e3*b.m_no_e2+a.m_e3_e1*b.m_no_e1-a.m_no_e1*b.m_e3_e1-a.m_no_e1_e2_e3*b.m_e1_e2+a.m_no_e1_e3_ni*b.m_no_e1+a.m_no_e2*b.m_e2_e3+a.m_no_e2_e3_ni*b.m_no_e2+a.m_no_e3*b.m_no_ni-a.m_no_ni*b.m_no_e3+a.m_scalar*b.m_no_e3), // no_e3
			(-a.m_e1_e2_e3_ni*b.m_no_e3-a.m_e1_ni*b.m_no_e2-a.m_e2_e3*b.m_e3_e1+a.m_e2_ni*b.m_no_e1+a.m_e3_e1*b.m_e2_e3-a.m_no_e1*b.m_e2_ni-a.m_no_e1_e2_e3*b.m_e3_ni+a.m_no_e1_e2_ni*b.m_no_ni+a.m_no_e2*b.m_e1_ni+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e1_e2_e3_ni*b.m_no_e1-a.m_e2_ni*b.m_no_e3-a.m_e3_e1*b.m_e1_e2+a.m_e3_ni*b.m_no_e2-a.m_no_e1_e2_e3*b.m_e1_ni-a.m_no_e2*b.m_e3_ni+a.m_no_e2_e3_ni*b.m_no_ni+a.m_no_e3*b.m_e2_ni+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3+a.m_e1_e2_e3_ni*b.m_no_e2-a.m_e1_ni*b.m_no_e3-a.m_e2_e3*b.m_e1_e2+a.m_e3_ni*b.m_no_e1-a.m_no_e1*b.m_e3_ni+a.m_no_e1_e2_e3*b.m_e2_ni+a.m_no_e1_e3_ni*b.m_no_ni+a.m_no_e3*b.m_e1_ni-a.m_scalar*b.m_e3_e1), // e3_e1
			(a.m_e1_e2*b.m_e2_ni-a.m_e1_e2_e3_ni*b.m_e2_e3-a.m_e1_ni*b.m_no_ni-a.m_e2_ni*b.m_e1_e2-a.m_e3_e1*b.m_e3_ni+a.m_e3_ni*b.m_e3_e1+a.m_no_e1_e2_ni*b.m_e2_ni+a.m_no_e1_e3_ni*b.m_e3_ni+a.m_no_ni*b.m_e1_ni+a.m_scalar*b.m_e1_ni), // e1_ni
			(-a.m_e1_e2*b.m_e1_ni-a.m_e1_e2_e3_ni*b.m_e3_e1+a.m_e1_ni*b.m_e1_e2+a.m_e2_e3*b.m_e3_ni-a.m_e2_ni*b.m_no_ni-a.m_e3_ni*b.m_e2_e3-a.m_no_e1_e2_ni*b.m_e1_ni+a.m_no_e2_e3_ni*b.m_e3_ni+a.m_no_ni*b.m_e2_ni+a.m_scalar*b.m_e2_ni), // e2_ni
			(-a.m_e1_e2_e3_ni*b.m_e1_e2-a.m_e1_ni*b.m_e3_e1-a.m_e2_e3*b.m_e2_ni+a.m_e2_ni*b.m_e2_e3+a.m_e3_e1*b.m_e1_ni-a.m_e3_ni*b.m_no_ni-a.m_no_e1_e3_ni*b.m_e1_ni-a.m_no_e2_e3_ni*b.m_e2_ni+a.m_no_ni*b.m_e3_ni+a.m_scalar*b.m_e3_ni), // e3_ni
			(-a.m_e1_ni*b.m_no_e1-a.m_e2_ni*b.m_no_e2-a.m_e3_ni*b.m_no_e3+a.m_no_e1*b.m_e1_ni-a.m_no_e1_e2_ni*b.m_e1_e2+a.m_no_e1_e3_ni*b.m_e3_e1+a.m_no_e2*b.m_e2_ni-a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e3*b.m_e3_ni+a.m_scalar*b.m_no_ni), // no_ni
			(a.m_e1_e2*b.m_e3_ni-a.m_e1_e2_e3_ni*b.m_no_ni+a.m_e1_ni*b.m_e2_e3+a.m_e2_e3*b.m_e1_ni+a.m_e2_ni*b.m_e3_e1+a.m_e3_e1*b.m_e2_ni+a.m_e3_ni*b.m_e1_e2+a.m_no_e1_e2_ni*b.m_e3_ni-a.m_no_e1_e3_ni*b.m_e2_ni+a.m_no_e2_e3_ni*b.m_e1_ni), // e1_e2_e3_ni
			(-a.m_e1_e2_e3_ni*b.m_no_e1+a.m_e2_e3*b.m_no_ni-a.m_e2_ni*b.m_no_e3+a.m_e3_ni*b.m_no_e2+a.m_no_e1_e2_e3*b.m_e1_ni+a.m_no_e1_e2_ni*b.m_e3_e1+a.m_no_e1_e3_ni*b.m_e1_e2+a.m_no_e2*b.m_e3_ni-a.m_no_e3*b.m_e2_ni+a.m_no_ni*b.m_e2_e3), // no_e2_e3_ni
			(a.m_e1_e2_e3_ni*b.m_no_e2-a.m_e1_ni*b.m_no_e3-a.m_e3_e1*b.m_no_ni+a.m_e3_ni*b.m_no_e1+a.m_no_e1*b.m_e3_ni-a.m_no_e1_e2_e3*b.m_e2_ni+a.m_no_e1_e2_ni*b.m_e2_e3-a.m_no_e2_e3_ni*b.m_e1_e2-a.m_no_e3*b.m_e1_ni-a.m_no_ni*b.m_e3_e1), // no_e1_e3_ni
			(a.m_e1_e2*b.m_no_ni-a.m_e1_e2_e3_ni*b.m_no_e3-a.m_e1_ni*b.m_no_e2+a.m_e2_ni*b.m_no_e1+a.m_no_e1*b.m_e2_ni+a.m_no_e1_e2_e3*b.m_e3_ni-a.m_no_e1_e3_ni*b.m_e2_e3-a.m_no_e2*b.m_e1_ni-a.m_no_e2_e3_ni*b.m_e3_e1+a.m_no_ni*b.m_e1_e2), // no_e1_e2_ni
			(a.m_e1_e2*b.m_no_e3+a.m_e2_e3*b.m_no_e1+a.m_e3_e1*b.m_no_e2+a.m_no_e1*b.m_e2_e3+a.m_no_e1_e2_e3*b.m_no_ni-a.m_no_e1_e2_ni*b.m_no_e3+a.m_no_e1_e3_ni*b.m_no_e2+a.m_no_e2*b.m_e3_e1-a.m_no_e2_e3_ni*b.m_no_e1+a.m_no_e3*b.m_e1_e2) // no_e1_e2_e3
		);

}
inline evenVersor gp(const evenVersor &a, const evenVersor &b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			(-a.m_e1_e2*b.m_e1_e2+a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3-a.m_e1_ni*b.m_no_e1-a.m_e2_e3*b.m_e2_e3-a.m_e2_ni*b.m_no_e2-a.m_e3_e1*b.m_e3_e1-a.m_e3_ni*b.m_no_e3-a.m_no_e1*b.m_e1_ni+a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni-a.m_no_e1_e2_ni*b.m_no_e1_e2_ni-a.m_no_e1_e3_ni*b.m_no_e1_e3_ni-a.m_no_e2*b.m_e2_ni-a.m_no_e2_e3_ni*b.m_no_e2_e3_ni-a.m_no_e3*b.m_e3_ni+a.m_no_ni*b.m_no_ni+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_no_e2-a.m_e2_e3*b.m_no_e1_e2_e3-a.m_e3_e1*b.m_no_e3+a.m_no_e1*b.m_no_ni+a.m_no_e1*b.m_scalar-a.m_no_e1_e2_e3*b.m_e2_e3-a.m_no_e1_e2_e3*b.m_no_e2_e3_ni-a.m_no_e1_e2_ni*b.m_no_e2-a.m_no_e1_e3_ni*b.m_no_e3-a.m_no_e2*b.m_e1_e2-a.m_no_e2*b.m_no_e1_e2_ni+a.m_no_e2_e3_ni*b.m_no_e1_e2_e3+a.m_no_e3*b.m_e3_e1-a.m_no_e3*b.m_no_e1_e3_ni-a.m_no_ni*b.m_no_e1+a.m_scalar*b.m_no_e1), // no_e1
			(-a.m_e1_e2*b.m_no_e1+a.m_e2_e3*b.m_no_e3-a.m_e3_e1*b.m_no_e1_e2_e3+a.m_no_e1*b.m_e1_e2+a.m_no_e1*b.m_no_e1_e2_ni-a.m_no_e1_e2_e3*b.m_e3_e1+a.m_no_e1_e2_e3*b.m_no_e1_e3_ni+a.m_no_e1_e2_ni*b.m_no_e1-a.m_no_e1_e3_ni*b.m_no_e1_e2_e3+a.m_no_e2*b.m_no_ni+a.m_no_e2*b.m_scalar-a.m_no_e2_e3_ni*b.m_no_e3-a.m_no_e3*b.m_e2_e3-a.m_no_e3*b.m_no_e2_e3_ni-a.m_no_ni*b.m_no_e2+a.m_scalar*b.m_no_e2), // no_e2
			(-a.m_e1_e2*b.m_no_e1_e2_e3-a.m_e2_e3*b.m_no_e2+a.m_e3_e1*b.m_no_e1-a.m_no_e1*b.m_e3_e1+a.m_no_e1*b.m_no_e1_e3_ni-a.m_no_e1_e2_e3*b.m_e1_e2-a.m_no_e1_e2_e3*b.m_no_e1_e2_ni+a.m_no_e1_e2_ni*b.m_no_e1_e2_e3+a.m_no_e1_e3_ni*b.m_no_e1+a.m_no_e2*b.m_e2_e3+a.m_no_e2*b.m_no_e2_e3_ni+a.m_no_e2_e3_ni*b.m_no_e2+a.m_no_e3*b.m_no_ni+a.m_no_e3*b.m_scalar-a.m_no_ni*b.m_no_e3+a.m_scalar*b.m_no_e3), // no_e3
			(a.m_e1_e2*b.m_scalar-a.m_e1_e2_e3_ni*b.m_no_e3-a.m_e1_ni*b.m_no_e2-a.m_e2_e3*b.m_e3_e1+a.m_e2_ni*b.m_no_e1+a.m_e3_e1*b.m_e2_e3-a.m_e3_ni*b.m_no_e1_e2_e3-a.m_no_e1*b.m_e2_ni-a.m_no_e1_e2_e3*b.m_e3_ni+a.m_no_e1_e2_ni*b.m_no_ni-a.m_no_e1_e3_ni*b.m_no_e2_e3_ni+a.m_no_e2*b.m_e1_ni+a.m_no_e2_e3_ni*b.m_no_e1_e3_ni-a.m_no_e3*b.m_e1_e2_e3_ni+a.m_no_ni*b.m_no_e1_e2_ni+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e1_e2_e3_ni*b.m_no_e1-a.m_e1_ni*b.m_no_e1_e2_e3+a.m_e2_e3*b.m_scalar-a.m_e2_ni*b.m_no_e3-a.m_e3_e1*b.m_e1_e2+a.m_e3_ni*b.m_no_e2-a.m_no_e1*b.m_e1_e2_e3_ni-a.m_no_e1_e2_e3*b.m_e1_ni-a.m_no_e1_e2_ni*b.m_no_e1_e3_ni+a.m_no_e1_e3_ni*b.m_no_e1_e2_ni-a.m_no_e2*b.m_e3_ni+a.m_no_e2_e3_ni*b.m_no_ni+a.m_no_e3*b.m_e2_ni+a.m_no_ni*b.m_no_e2_e3_ni+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3+a.m_e1_e2_e3_ni*b.m_no_e2-a.m_e1_ni*b.m_no_e3-a.m_e2_e3*b.m_e1_e2+a.m_e2_ni*b.m_no_e1_e2_e3-a.m_e3_e1*b.m_scalar+a.m_e3_ni*b.m_no_e1-a.m_no_e1*b.m_e3_ni+a.m_no_e1_e2_e3*b.m_e2_ni+a.m_no_e1_e2_ni*b.m_no_e2_e3_ni+a.m_no_e1_e3_ni*b.m_no_ni+a.m_no_e2*b.m_e1_e2_e3_ni-a.m_no_e2_e3_ni*b.m_no_e1_e2_ni+a.m_no_e3*b.m_e1_ni+a.m_no_ni*b.m_no_e1_e3_ni-a.m_scalar*b.m_e3_e1), // e3_e1
			(a.m_e1_e2*b.m_e2_ni-a.m_e1_e2_e3_ni*b.m_e2_e3+a.m_e1_e2_e3_ni*b.m_no_e2_e3_ni-a.m_e1_ni*b.m_no_ni+a.m_e1_ni*b.m_scalar-a.m_e2_e3*b.m_e1_e2_e3_ni-a.m_e2_ni*b.m_e1_e2+a.m_e2_ni*b.m_no_e1_e2_ni-a.m_e3_e1*b.m_e3_ni+a.m_e3_ni*b.m_e3_e1+a.m_e3_ni*b.m_no_e1_e3_ni+a.m_no_e1_e2_ni*b.m_e2_ni+a.m_no_e1_e3_ni*b.m_e3_ni-a.m_no_e2_e3_ni*b.m_e1_e2_e3_ni+a.m_no_ni*b.m_e1_ni+a.m_scalar*b.m_e1_ni), // e1_ni
			(-a.m_e1_e2*b.m_e1_ni-a.m_e1_e2_e3_ni*b.m_e3_e1-a.m_e1_e2_e3_ni*b.m_no_e1_e3_ni+a.m_e1_ni*b.m_e1_e2-a.m_e1_ni*b.m_no_e1_e2_ni+a.m_e2_e3*b.m_e3_ni-a.m_e2_ni*b.m_no_ni+a.m_e2_ni*b.m_scalar-a.m_e3_e1*b.m_e1_e2_e3_ni-a.m_e3_ni*b.m_e2_e3+a.m_e3_ni*b.m_no_e2_e3_ni-a.m_no_e1_e2_ni*b.m_e1_ni+a.m_no_e1_e3_ni*b.m_e1_e2_e3_ni+a.m_no_e2_e3_ni*b.m_e3_ni+a.m_no_ni*b.m_e2_ni+a.m_scalar*b.m_e2_ni), // e2_ni
			(-a.m_e1_e2*b.m_e1_e2_e3_ni-a.m_e1_e2_e3_ni*b.m_e1_e2+a.m_e1_e2_e3_ni*b.m_no_e1_e2_ni-a.m_e1_ni*b.m_e3_e1-a.m_e1_ni*b.m_no_e1_e3_ni-a.m_e2_e3*b.m_e2_ni+a.m_e2_ni*b.m_e2_e3-a.m_e2_ni*b.m_no_e2_e3_ni+a.m_e3_e1*b.m_e1_ni-a.m_e3_ni*b.m_no_ni+a.m_e3_ni*b.m_scalar-a.m_no_e1_e2_ni*b.m_e1_e2_e3_ni-a.m_no_e1_e3_ni*b.m_e1_ni-a.m_no_e2_e3_ni*b.m_e2_ni+a.m_no_ni*b.m_e3_ni+a.m_scalar*b.m_e3_ni), // e3_ni
			(-a.m_e1_e2*b.m_no_e1_e2_ni+a.m_e1_e2_e3_ni*b.m_no_e1_e2_e3-a.m_e1_ni*b.m_no_e1-a.m_e2_e3*b.m_no_e2_e3_ni-a.m_e2_ni*b.m_no_e2+a.m_e3_e1*b.m_no_e1_e3_ni-a.m_e3_ni*b.m_no_e3+a.m_no_e1*b.m_e1_ni-a.m_no_e1_e2_e3*b.m_e1_e2_e3_ni-a.m_no_e1_e2_ni*b.m_e1_e2+a.m_no_e1_e3_ni*b.m_e3_e1+a.m_no_e2*b.m_e2_ni-a.m_no_e2_e3_ni*b.m_e2_e3+a.m_no_e3*b.m_e3_ni+a.m_no_ni*b.m_scalar+a.m_scalar*b.m_no_ni), // no_ni
			(a.m_e1_e2*b.m_e3_ni-a.m_e1_e2_e3_ni*b.m_no_ni+a.m_e1_e2_e3_ni*b.m_scalar+a.m_e1_ni*b.m_e2_e3-a.m_e1_ni*b.m_no_e2_e3_ni+a.m_e2_e3*b.m_e1_ni+a.m_e2_ni*b.m_e3_e1+a.m_e2_ni*b.m_no_e1_e3_ni+a.m_e3_e1*b.m_e2_ni+a.m_e3_ni*b.m_e1_e2-a.m_e3_ni*b.m_no_e1_e2_ni+a.m_no_e1_e2_ni*b.m_e3_ni-a.m_no_e1_e3_ni*b.m_e2_ni+a.m_no_e2_e3_ni*b.m_e1_ni+a.m_no_ni*b.m_e1_e2_e3_ni+a.m_scalar*b.m_e1_e2_e3_ni), // e1_e2_e3_ni
			(-a.m_e1_e2*b.m_no_e1_e3_ni-a.m_e1_e2_e3_ni*b.m_no_e1-a.m_e1_ni*b.m_no_e1_e2_e3+a.m_e2_e3*b.m_no_ni-a.m_e2_ni*b.m_no_e3-a.m_e3_e1*b.m_no_e1_e2_ni+a.m_e3_ni*b.m_no_e2+a.m_no_e1*b.m_e1_e2_e3_ni+a.m_no_e1_e2_e3*b.m_e1_ni+a.m_no_e1_e2_ni*b.m_e3_e1+a.m_no_e1_e3_ni*b.m_e1_e2+a.m_no_e2*b.m_e3_ni+a.m_no_e2_e3_ni*b.m_scalar-a.m_no_e3*b.m_e2_ni+a.m_no_ni*b.m_e2_e3+a.m_scalar*b.m_no_e2_e3_ni), // no_e2_e3_ni
			(a.m_e1_e2*b.m_no_e2_e3_ni+a.m_e1_e2_e3_ni*b.m_no_e2-a.m_e1_ni*b.m_no_e3-a.m_e2_e3*b.m_no_e1_e2_ni+a.m_e2_ni*b.m_no_e1_e2_e3-a.m_e3_e1*b.m_no_ni+a.m_e3_ni*b.m_no_e1+a.m_no_e1*b.m_e3_ni-a.m_no_e1_e2_e3*b.m_e2_ni+a.m_no_e1_e2_ni*b.m_e2_e3+a.m_no_e1_e3_ni*b.m_scalar-a.m_no_e2*b.m_e1_e2_e3_ni-a.m_no_e2_e3_ni*b.m_e1_e2-a.m_no_e3*b.m_e1_ni-a.m_no_ni*b.m_e3_e1+a.m_scalar*b.m_no_e1_e3_ni), // no_e1_e3_ni
			(a.m_e1_e2*b.m_no_ni-a.m_e1_e2_e3_ni*b.m_no_e3-a.m_e1_ni*b.m_no_e2+a.m_e2_e3*b.m_no_e1_e3_ni+a.m_e2_ni*b.m_no_e1+a.m_e3_e1*b.m_no_e2_e3_ni-a.m_e3_ni*b.m_no_e1_e2_e3+a.m_no_e1*b.m_e2_ni+a.m_no_e1_e2_e3*b.m_e3_ni+a.m_no_e1_e2_ni*b.m_scalar-a.m_no_e1_e3_ni*b.m_e2_e3-a.m_no_e2*b.m_e1_ni-a.m_no_e2_e3_ni*b.m_e3_e1+a.m_no_e3*b.m_e1_e2_e3_ni+a.m_no_ni*b.m_e1_e2+a.m_scalar*b.m_no_e1_e2_ni), // no_e1_e2_ni
			(a.m_e1_e2*b.m_no_e3+a.m_e2_e3*b.m_no_e1+a.m_e3_e1*b.m_no_e2+a.m_no_e1*b.m_e2_e3+a.m_no_e1*b.m_no_e2_e3_ni+a.m_no_e1_e2_e3*b.m_no_ni+a.m_no_e1_e2_e3*b.m_scalar-a.m_no_e1_e2_ni*b.m_no_e3+a.m_no_e1_e3_ni*b.m_no_e2+a.m_no_e2*b.m_e3_e1-a.m_no_e2*b.m_no_e1_e3_ni-a.m_no_e2_e3_ni*b.m_no_e1+a.m_no_e3*b.m_e1_e2+a.m_no_e3*b.m_no_e1_e2_ni-a.m_no_ni*b.m_no_e1_e2_e3+a.m_scalar*b.m_no_e1_e2_e3) // no_e1_e2_e3
		);

}
inline evenVersor sas(const pointPair &a, const double b, const double c)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			c, // scalar
			a.m_no_e1*b, // no_e1
			a.m_no_e2*b, // no_e2
			a.m_no_e3*b, // no_e3
			a.m_e1_e2*b, // e1_e2
			a.m_e2_e3*b, // e2_e3
			a.m_e3_e1*b, // e3_e1
			a.m_e1_ni*b, // e1_ni
			a.m_e2_ni*b, // e2_ni
			a.m_e3_ni*b, // e3_ni
			a.m_no_ni*b, // no_ni
			0.0, // e1_e2_e3_ni
			0.0, // no_e2_e3_ni
			0.0, // no_e1_e3_ni
			0.0, // no_e1_e2_ni
			0.0 // no_e1_e2_e3
		);
}
inline evenVersor gp(const evenVersor &a, const double b)
{
	return evenVersor(evenVersor::coord_scalar_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni_e1e2e3ni_noe2e3ni_noe1e3ni_noe1e2ni_noe1e2e3,
			a.m_scalar*b, // scalar
			a.m_no_e1*b, // no_e1
			a.m_no_e2*b, // no_e2
			a.m_no_e3*b, // no_e3
			a.m_e1_e2*b, // e1_e2
			a.m_e2_e3*b, // e2_e3
			a.m_e3_e1*b, // e3_e1
			a.m_e1_ni*b, // e1_ni
			a.m_e2_ni*b, // e2_ni
			a.m_e3_ni*b, // e3_ni
			a.m_no_ni*b, // no_ni
			a.m_e1_e2_e3_ni*b, // e1_e2_e3_ni
			a.m_no_e2_e3_ni*b, // no_e2_e3_ni
			a.m_no_e1_e3_ni*b, // no_e1_e3_ni
			a.m_no_e1_e2_ni*b, // no_e1_e2_ni
			a.m_no_e1_e2_e3*b // no_e1_e2_e3
		);

}
inline pointPair gp(const pointPair &a, const double b)
{
	return pointPair(pointPair::coord_noe1_noe2_noe3_e1e2_e2e3_e3e1_e1ni_e2ni_e3ni_noni,
			a.m_no_e1*b, // no_e1
			a.m_no_e2*b, // no_e2
			a.m_no_e3*b, // no_e3
			a.m_e1_e2*b, // e1_e2
			a.m_e2_e3*b, // e2_e3
			a.m_e3_e1*b, // e3_e1
			a.m_e1_ni*b, // e1_ni
			a.m_e2_ni*b, // e2_ni
			a.m_e3_ni*b, // e3_ni
			a.m_no_ni*b // no_ni
		);

}


/** structure used by custom parser */
struct c3gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct c3gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace c3ga
#endif /* _C3GA_H_ */
