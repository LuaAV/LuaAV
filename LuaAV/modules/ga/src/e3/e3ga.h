/*
Gaigen 2.5 Test Suite
*/
/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage e3ga documentation
 *
 * e3ga implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _E3GA_H_
#define _E3GA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <time.h> /* used to seed random generator */
namespace e3ga {

// group: 1
#define GROUP_0 1
// group: e1, e2, e3
#define GROUP_1 2
// group: e1^e2, e1^e3, e2^e3
#define GROUP_2 4
// group: e1^e2^e3
#define GROUP_3 8
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8


/// The dimension of the space:
extern const int e3ga_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int e3ga_nbGroups;

/// The constants for the groups in an array:
extern const int e3ga_groups[];

/// The constants for the grades in an array:
extern const int e3ga_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool e3ga_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int e3ga_groupSize[4];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int e3ga_mvSize[16];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *e3ga_basisVectorNames[3];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int e3ga_basisElements[8][4];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double e3ga_basisElementSignByIndex[8];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double e3ga_basisElementSignByBitmap[8];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int e3ga_basisElementIndexByBitmap[8];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int e3ga_basisElementBitmapByIndex[8];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int e3ga_basisElementGradeByBitmap[8];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int e3ga_basisElementGroupByBitmap[8];
class mv;
class e1_t;
class e2_t;
class e3_t;
class I3_t;
class vector;
class bivector;
class trivector;
class rotor;
class oddVersor;
class om;
class grade1OM;
class grade2OM;
class grade3OM;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 4 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:e1, e2, e3  (grade 1).
/// group 2:e1^e2, e1^e3, e2^e3  (grade 2).
/// group 3:e1^e2^e3  (grade 3).
/// 
/// 8 doubles are allocated inside the struct.
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates
	double m_c[8]; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  {set();}

	/// Copy constructor.
	inline mv(const mv&A)  {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

	/// Converts a e1_t to a mv.
	inline mv(const e1_t&A)  {set(A);}
	/// Converts a e2_t to a mv.
	inline mv(const e2_t&A)  {set(A);}
	/// Converts a e3_t to a mv.
	inline mv(const e3_t&A)  {set(A);}
	/// Converts a I3_t to a mv.
	inline mv(const I3_t&A)  {set(A);}
	/// Converts a vector to a mv.
	inline mv(const vector&A)  {set(A);}
	/// Converts a bivector to a mv.
	inline mv(const bivector&A)  {set(A);}
	/// Converts a trivector to a mv.
	inline mv(const trivector&A)  {set(A);}
	/// Converts a rotor to a mv.
	inline mv(const rotor&A)  {set(A);}
	/// Converts a oddVersor to a mv.
	inline mv(const oddVersor&A)  {set(A);}


	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const e1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const e3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const trivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const rotor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const oddVersor &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of e1_t A
	void set(const e1_t &A);
	/// Sets this mv to the value of e2_t A
	void set(const e2_t &A);
	/// Sets this mv to the value of e3_t A
	void set(const e3_t &A);
	/// Sets this mv to the value of I3_t A
	void set(const I3_t &A);
	/// Sets this mv to the value of vector A
	void set(const vector &A);
	/// Sets this mv to the value of bivector A
	void set(const bivector &A);
	/// Sets this mv to the value of trivector A
	void set(const trivector &A);
	/// Sets this mv to the value of rotor A
	void set(const rotor &A);
	/// Sets this mv to the value of oddVersor A
	void set(const oddVersor &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[e3ga_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the e1 coordinate of this mv.
	inline double get_e1() const {
		return (m_gu & 2) ? m_c[e3ga_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the e2 coordinate of this mv.
	inline double get_e2() const {
		return (m_gu & 2) ? m_c[e3ga_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the e3 coordinate of this mv.
	inline double get_e3() const {
		return (m_gu & 2) ? m_c[e3ga_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the e1_e2 coordinate of this mv.
	inline double get_e1_e2() const {
		return (m_gu & 4) ? m_c[e3ga_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the e1_e3 coordinate of this mv.
	inline double get_e1_e3() const {
		return (m_gu & 4) ? m_c[e3ga_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the e2_e3 coordinate of this mv.
	inline double get_e2_e3() const {
		return (m_gu & 4) ? m_c[e3ga_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the e1_e2_e3 coordinate of this mv.
	inline double get_e1_e2_e3() const {
		return (m_gu & 8) ? m_c[e3ga_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[e3ga_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the e1 coordinate of this mv.
	inline void set_e1(double val)  {
		reserveGroup_1();
		m_c[e3ga_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the e2 coordinate of this mv.
	inline void set_e2(double val)  {
		reserveGroup_1();
		m_c[e3ga_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the e3 coordinate of this mv.
	inline void set_e3(double val)  {
		reserveGroup_1();
		m_c[e3ga_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the e1_e2 coordinate of this mv.
	inline void set_e1_e2(double val)  {
		reserveGroup_2();
		m_c[e3ga_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the e1_e3 coordinate of this mv.
	inline void set_e1_e3(double val)  {
		reserveGroup_2();
		m_c[e3ga_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the e2_e3 coordinate of this mv.
	inline void set_e2_e3(double val)  {
		reserveGroup_2();
		m_c[e3ga_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the e1_e2_e3 coordinate of this mv.
	inline void set_e1_e2_e3(double val)  {
		reserveGroup_3();
		m_c[e3ga_mvSize[m_gu & 7] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[4], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[8]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + e3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + e3ga_mvSize[groupUsageBelow];
			for (int i = e3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + e3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + e3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + e3ga_mvSize[groupUsageBelow];
			for (int i = e3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + e3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + e3ga_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + e3ga_mvSize[groupUsageBelow];
			for (int i = e3ga_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + e3ga_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + e3ga_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type e1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1 = 1
/// 
/// 
class e1_t
{
public:
public:

	/// Floating point type used by e1_t 
	typedef double Float;
	/// Array indices of e1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e1_t with variable coordinates set to 0.
	inline e1_t() {set();}

	/// Copy constructor.
	inline e1_t(const e1_t &A) {set(A);}



	/// Constructs a new e1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e1_t).
	inline e1_t &operator=(const e1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e1_t

/// This class can hold a specialized multivector of type e2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e2 = 1
/// 
/// 
class e2_t
{
public:
public:

	/// Floating point type used by e2_t 
	typedef double Float;
	/// Array indices of e2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e2_t with variable coordinates set to 0.
	inline e2_t() {set();}

	/// Copy constructor.
	inline e2_t(const e2_t &A) {set(A);}



	/// Constructs a new e2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e2_t).
	inline e2_t &operator=(const e2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e2 coordinate.
	inline double get_e2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e2_t

/// This class can hold a specialized multivector of type e3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e3 = 1
/// 
/// 
class e3_t
{
public:
public:

	/// Floating point type used by e3_t 
	typedef double Float;
	/// Array indices of e3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new e3_t with variable coordinates set to 0.
	inline e3_t() {set();}

	/// Copy constructor.
	inline e3_t(const e3_t &A) {set(A);}



	/// Constructs a new e3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline e3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (e3_t).
	inline e3_t &operator=(const e3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline e3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const e3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e3 coordinate.
	inline double get_e3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class e3_t

/// This class can hold a specialized multivector of type I3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - e1^e2^e3 = 1
/// 
/// 
class I3_t
{
public:
public:

	/// Floating point type used by I3_t 
	typedef double Float;
	/// Array indices of I3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I3_t with variable coordinates set to 0.
	inline I3_t() {set();}

	/// Copy constructor.
	inline I3_t(const I3_t &A) {set(A);}



	/// Constructs a new I3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I3_t).
	inline I3_t &operator=(const I3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I3_t

/// This class can hold a specialized multivector of type vector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vector
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
public:

	/// Floating point type used by vector 
	typedef double Float;
	/// Array indices of vector coordinates.
	typedef enum {
		/// index of coordinate for e1 in vector
		E1 = 0, 
		/// index of coordinate for e2 in vector
		E2 = 1, 
		/// index of coordinate for e3 in vector
		E3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3
	} CoordinateOrder;

	/// Constructs a new vector with variable coordinates set to 0.
	inline vector() {set();}

	/// Copy constructor.
	inline vector(const vector &A) {set(A);}



	/// Constructs a new vector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vector(mv &A, int filler) {set(A);}

	/// Constructs a new vector. Coordinate values come from 'A'.
	inline vector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new vector with each coordinate specified.
	inline vector(const CoordinateOrder co,  double e1, double e2, double e3) {
		set(co, e1, e2, e3);
	}

	/// Assignment operator (vector).
	inline vector &operator=(const vector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class vector

/// This class can hold a specialized multivector of type bivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2  (array index: E1_E2 = 0)
///   - coordinate e2^e3  (array index: E2_E3 = 1)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivector
{
public:
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by bivector 
	typedef double Float;
	/// Array indices of bivector coordinates.
	typedef enum {
		/// index of coordinate for e1^e2 in bivector
		E1_E2 = 0, 
		/// index of coordinate for e2^e3 in bivector
		E2_E3 = 1, 
		/// index of coordinate for -1*e1^e3 in bivector
		E3_E1 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new bivector with variable coordinates set to 0.
	inline bivector() {set();}

	/// Copy constructor.
	inline bivector(const bivector &A) {set(A);}



	/// Constructs a new bivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivector(mv &A, int filler) {set(A);}

	/// Constructs a new bivector. Coordinate values come from 'A'.
	inline bivector(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new bivector with each coordinate specified.
	inline bivector(const CoordinateOrder co,  double e1_e2, double e2_e3, double e3_e1) {
		set(co, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (bivector).
	inline bivector &operator=(const bivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class bivector

/// This class can hold a specialized multivector of type trivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 0)
/// 
/// The type has no constant coordinates.
/// 
/// 
class trivector
{
public:
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
public:

	/// Floating point type used by trivector 
	typedef double Float;
	/// Array indices of trivector coordinates.
	typedef enum {
		/// index of coordinate for e1^e2^e3 in trivector
		E1_E2_E3 = 0, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1e2e3
	} CoordinateOrder;

	/// Constructs a new trivector with variable coordinates set to 0.
	inline trivector() {set();}

	/// Copy constructor.
	inline trivector(const trivector &A) {set(A);}



	/// Constructs a new trivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline trivector(mv &A, int filler) {set(A);}

	/// Constructs a new trivector. Coordinate values come from 'A'.
	inline trivector(const CoordinateOrder co, const double A[1]) {set(co, A);}
	
	/// Constructs a new trivector with each coordinate specified.
	inline trivector(const CoordinateOrder co,  double e1_e2_e3) {
		set(co, e1_e2_e3);
	}

	/// Assignment operator (trivector).
	inline trivector &operator=(const trivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline trivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const trivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[1]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class trivector

/// This class can hold a specialized multivector of type rotor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate e1^e2  (array index: E1_E2 = 1)
///   - coordinate e2^e3  (array index: E2_E3 = 2)
///   - coordinate -1*e1^e3  (array index: E3_E1 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class rotor
{
public:
	/// The 1 coordinate.
	double m_scalar;
	/// The e1^e2 coordinate.
	double m_e1_e2;
	/// The e2^e3 coordinate.
	double m_e2_e3;
	/// The -1*e1^e3 coordinate.
	double m_e3_e1;
public:

	/// Floating point type used by rotor 
	typedef double Float;
	/// Array indices of rotor coordinates.
	typedef enum {
		/// index of coordinate for 1 in rotor
		SCALAR = 0, 
		/// index of coordinate for e1^e2 in rotor
		E1_E2 = 1, 
		/// index of coordinate for e2^e3 in rotor
		E2_E3 = 2, 
		/// index of coordinate for -1*e1^e3 in rotor
		E3_E1 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_e1e2_e2e3_e3e1
	} CoordinateOrder;

	/// Constructs a new rotor with variable coordinates set to 0.
	inline rotor() {set();}

	/// Copy constructor.
	inline rotor(const rotor &A) {set(A);}


	/// Constructs a new rotor with scalar value 'scalar'.
	inline rotor(double scalar) {set(scalar);}

	/// Constructs a new rotor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline rotor(mv &A, int filler) {set(A);}

	/// Constructs a new rotor. Coordinate values come from 'A'.
	inline rotor(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new rotor with each coordinate specified.
	inline rotor(const CoordinateOrder co,  double scalar, double e1_e2, double e2_e3, double e3_e1) {
		set(co, scalar, e1_e2, e2_e3, e3_e1);
	}

	/// Assignment operator (rotor).
	inline rotor &operator=(const rotor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline rotor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline rotor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const rotor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double e1_e2, double e2_e3, double e3_e1);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_scalar;}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_scalar = scalar;}
	/// Returns the e1^e2 coordinate.
	inline double get_e1_e2() const { return m_e1_e2;}
	/// Sets the e1^e2 coordinate.
	inline void set_e1_e2(double e1_e2) { m_e1_e2 = e1_e2;}
	/// Returns the e2^e3 coordinate.
	inline double get_e2_e3() const { return m_e2_e3;}
	/// Sets the e2^e3 coordinate.
	inline void set_e2_e3(double e2_e3) { m_e2_e3 = e2_e3;}
	/// Returns the -1*e1^e3 coordinate.
	inline double get_e3_e1() const { return m_e3_e1;}
	/// Sets the -1*e1^e3 coordinate.
	inline void set_e3_e1(double e3_e1) { m_e3_e1 = e3_e1;}
}; // end of class rotor

/// This class can hold a specialized multivector of type oddVersor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate e1  (array index: E1 = 0)
///   - coordinate e2  (array index: E2 = 1)
///   - coordinate e3  (array index: E3 = 2)
///   - coordinate e1^e2^e3  (array index: E1_E2_E3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class oddVersor
{
public:
	/// The e1 coordinate.
	double m_e1;
	/// The e2 coordinate.
	double m_e2;
	/// The e3 coordinate.
	double m_e3;
	/// The e1^e2^e3 coordinate.
	double m_e1_e2_e3;
public:

	/// Floating point type used by oddVersor 
	typedef double Float;
	/// Array indices of oddVersor coordinates.
	typedef enum {
		/// index of coordinate for e1 in oddVersor
		E1 = 0, 
		/// index of coordinate for e2 in oddVersor
		E2 = 1, 
		/// index of coordinate for e3 in oddVersor
		E3 = 2, 
		/// index of coordinate for e1^e2^e3 in oddVersor
		E1_E2_E3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_e1_e2_e3_e1e2e3
	} CoordinateOrder;

	/// Constructs a new oddVersor with variable coordinates set to 0.
	inline oddVersor() {set();}

	/// Copy constructor.
	inline oddVersor(const oddVersor &A) {set(A);}



	/// Constructs a new oddVersor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline oddVersor(mv &A, int filler) {set(A);}

	/// Constructs a new oddVersor. Coordinate values come from 'A'.
	inline oddVersor(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new oddVersor with each coordinate specified.
	inline oddVersor(const CoordinateOrder co,  double e1, double e2, double e3, double e1_e2_e3) {
		set(co, e1, e2, e3, e1_e2_e3);
	}

	/// Assignment operator (oddVersor).
	inline oddVersor &operator=(const oddVersor &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline oddVersor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const oddVersor &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double e1, double e2, double e3, double e1_e2_e3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::e3ga::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::e3ga::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the e1 coordinate.
	inline double get_e1() const { return m_e1;}
	/// Sets the e1 coordinate.
	inline void set_e1(double e1) { m_e1 = e1;}
	/// Returns the e2 coordinate.
	inline double get_e2() const { return m_e2;}
	/// Sets the e2 coordinate.
	inline void set_e2(double e2) { m_e2 = e2;}
	/// Returns the e3 coordinate.
	inline double get_e3() const { return m_e3;}
	/// Sets the e3 coordinate.
	inline void set_e3(double e3) { m_e3 = e3;}
	/// Returns the e1^e2^e3 coordinate.
	inline double get_e1_e2_e3() const { return m_e1_e2_e3;}
	/// Sets the e1^e2^e3 coordinate.
	inline void set_e1_e2_e3(double e1_e2_e3) { m_e1_e2_e3 = e1_e2_e3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class oddVersor

/// This class can hold a general outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 4 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2, e3.
/// Domain grade 2: e1^e2, e1^e3, e2^e3.
/// Domain grade 3: e1^e2^e3.
/// 
/// The range and domain are equal.
/// 
class om
{
public:
	/// Matrix for grade 1; the size is 3 x 3
	double m_m1[9];
	/// Matrix for grade 2; the size is 3 x 3
	double m_m2[9];
	/// Matrix for grade 3; the size is 1 x 1
	double m_m3[1];
public:

	/// Floating point type used by om 
	typedef double Float;

	/// Constructs a new om, set to identity
	inline om() { setIdentity(); }

	/// Copy constructor.
	inline om(const om&M) { set(M); }

	/// Constructor from matrix
	inline om(const double *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline om(const vector &ie1, const vector &ie2, const vector &ie3)
		{ set(ie1, ie2, ie3); }

	/// Converts a grade1OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade1OM &M) { set(M); }
	
	/// Converts a grade2OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade2OM &M) { set(M); }
	
	/// Converts a grade3OM to a om.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om(const grade3OM &M) { set(M); }
	

	/// Sets this to 'M'
	inline om &operator=(const om &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade1OM &M) { set(M); return *this; }
	
	/// Sets this om to grade2OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade2OM &M) { set(M); return *this; }
	
	/// Sets this om to grade3OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	inline om &operator=(const grade3OM &M) { set(M); return *this; }
	

	/// Sets this om to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const om &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vector &ie1, const vector &ie2, const vector &ie3);

	/// Sets this om to a grade1OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade1OM &M);
	
	/// Sets this om to a grade2OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade2OM &M);
	
	/// Sets this om to a grade3OM.
	/// Warning 1: coordinates which cannot be represented are silenty lost
	/// Warning 2: coordinates which are not present in 'src' are set to zero in 'dst'.
	void set(const grade3OM &M);
	
	private:
	void set_0();
	void set_1();
	void set_2();
	void set_grade_2_0();
	void set_grade_2_1();
	void set_grade_2_2();
	void set_grade_3_0();
	public:
}; // end of om

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 4 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: e1, e2, e3.
/// Domain grade 2: .
/// Domain grade 3: .
/// 
/// The range and domain are equal.
/// 
class grade1OM
{
public:
	/// Matrix for grade 1; the size is 3 x 3
	double m_m1[9];
public:

	/// Floating point type used by grade1OM 
	typedef double Float;

	/// Constructs a new grade1OM, set to identity
	inline grade1OM() { setIdentity(); }

	/// Copy constructor.
	inline grade1OM(const grade1OM&M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade1OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade1OM(const vector &ie1, const vector &ie2, const vector &ie3)
		{ set(ie1, ie2, ie3); }

	/// Converts a om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade1OM &operator=(const grade1OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade1OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade1OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade1OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade1OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vector &ie1, const vector &ie2, const vector &ie3);

	/// Sets this grade1OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade1OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 4 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: e1^e2, e2^e3, -1*e1^e3.
/// Domain grade 3: .
/// 
/// The range and domain are equal.
/// 
class grade2OM
{
public:
	/// Matrix for grade 2; the size is 3 x 3
	double m_m2[9];
public:

	/// Floating point type used by grade2OM 
	typedef double Float;

	/// Constructs a new grade2OM, set to identity
	inline grade2OM() { setIdentity(); }

	/// Copy constructor.
	inline grade2OM(const grade2OM&M) { set(M); }

	/// Constructor from matrix
	inline grade2OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade2OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade2OM(const vector &ie1, const vector &ie2, const vector &ie3)
		{ set(ie1, ie2, ie3); }

	/// Converts a om to a grade2OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade2OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade2OM &operator=(const grade2OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade2OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade2OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade2OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade2OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vector &ie1, const vector &ie2, const vector &ie3);

	/// Sets this grade2OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade2OM

/// This class can hold a specialized outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 4 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: .
/// Domain grade 2: .
/// Domain grade 3: e1^e2^e3.
/// 
/// The range and domain are equal.
/// 
class grade3OM
{
public:
	/// Matrix for grade 3; the size is 1 x 1
	double m_m3[1];
public:

	/// Floating point type used by grade3OM 
	typedef double Float;

	/// Constructs a new grade3OM, set to identity
	inline grade3OM() { setIdentity(); }

	/// Copy constructor.
	inline grade3OM(const grade3OM&M) { set(M); }

	/// Constructor from matrix
	inline grade3OM(const double *M) { set(M); }

	/// Constructor from matrix
	inline grade3OM(const double *M, bool transposed) { if (transposed) { setTranspose(M); } else { set(M); } }
	
	/// Constructor from images of basis vectors.
	inline grade3OM(const vector &ie1, const vector &ie2, const vector &ie3)
		{ set(ie1, ie2, ie3); }

	/// Converts a om to a grade3OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade3OM(const om &M) { set(M); }

	/// Sets this to 'M'
	inline grade3OM &operator=(const grade3OM &M) { if (this != &M) { set(M); } return *this; }

	/// Sets this om to a grade3OM.
	/// Warning: coordinates which cannot be represented are silenty lost
	inline grade3OM &operator=(const om &M) { set(M); return *this; }
	

	/// Sets this grade3OM to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const grade3OM &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transposed matrix.
	void setTranspose(const double *M);
	
	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vector &ie1, const vector &ie2, const vector &ie3);

	/// Sets this grade3OM to a om.
	/// Warning: coordinates which cannot be represented are silenty lost
	void set(const om &M);
	
}; // end of grade3OM
extern e1_t e1;
extern e2_t e2;
extern e3_t e3;
extern I3_t I3;
extern vector vectorE1;
extern vector vectorE2;
extern vector vectorE3;
extern bivector someBivectorConstant;
/** rotor which rotates by 90 degrees in e1^e2 plane. */
extern rotor rotor90;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 15);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  e1_t
double _double(const e1_t &x);
/// Returns scalar part of  e1_t
inline double _Float(const e1_t &x) {return _double(x); };
/// Returns scalar part of  e2_t
double _double(const e2_t &x);
/// Returns scalar part of  e2_t
inline double _Float(const e2_t &x) {return _double(x); };
/// Returns scalar part of  e3_t
double _double(const e3_t &x);
/// Returns scalar part of  e3_t
inline double _Float(const e3_t &x) {return _double(x); };
/// Returns scalar part of  I3_t
double _double(const I3_t &x);
/// Returns scalar part of  I3_t
inline double _Float(const I3_t &x) {return _double(x); };
/// Returns scalar part of  vector
double _double(const vector &x);
/// Returns scalar part of  vector
inline double _Float(const vector &x) {return _double(x); };
/// Returns scalar part of  bivector
double _double(const bivector &x);
/// Returns scalar part of  bivector
inline double _Float(const bivector &x) {return _double(x); };
/// Returns scalar part of  trivector
double _double(const trivector &x);
/// Returns scalar part of  trivector
inline double _Float(const trivector &x) {return _double(x); };
/// Returns scalar part of  rotor
double _double(const rotor &x);
/// Returns scalar part of  rotor
inline double _Float(const rotor &x) {return _double(x); };
/// Returns scalar part of  oddVersor
double _double(const oddVersor &x);
/// Returns scalar part of  oddVersor
inline double _Float(const oddVersor &x) {return _double(x); };
/** Converts rotor to bivector: dst = R.
Extracts the bivector part of a rotor */
bivector _bivector(const rotor &R);
/** Converts oddVersor to vector: dst = V.
Extracts the vector part of an oddVersor */
vector _vector(const oddVersor &V);
/** Converts oddVersor to trivector: dst = V.
Extracts the trivector part of an oddVersor */
trivector _trivector(const oddVersor &V);
/// Generates a random double in [0.0 1.0) interval using the c library rand() function
double genrand();
/// Seeds the random number generator for  double
void genrand_seed(unsigned int seed);
/// Seeds the random number generator for  double with the current time
void genrand_timeSeed();
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns vector + vector.
vector add(const vector &a, const vector &b);
/// Returns bivector + bivector.
bivector add(const bivector &a, const bivector &b);
/// Returns vector + trivector.
oddVersor add(const vector &a, const trivector &b);
/// Returns rotor + bivector.
rotor add(const rotor &a, const bivector &b);
/// Returns e1_t + e2_t.
vector add(const e1_t &a, const e2_t &b);
/// Returns e1_t + I3_t.
oddVersor add(const e1_t &a, const I3_t &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns vector - vector.
vector subtract(const vector &a, const vector &b);
/// Returns bivector - bivector.
bivector subtract(const bivector &a, const bivector &b);
/// Returns bivector - rotor.
rotor subtract(const bivector &a, const rotor &b);
/// Returns vector - trivector.
oddVersor subtract(const vector &a, const trivector &b);
/// Returns a * b * inverse(a) using default metric.
mv applyVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyUnitVersor(const mv &a, const mv &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
mv applyVersorWI(const mv &a, const mv &b, const mv &c);
/// Returns a * b * inverse(a) using default metric.
vector applyVersor(const rotor &a, const vector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyUnitVersor(const rotor &a, const vector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyVersorWI(const rotor &a, const vector &b, const rotor &c);
/// Returns a * b * inverse(a) using default metric.
bivector applyVersor(const rotor &a, const bivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivector applyUnitVersor(const rotor &a, const bivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
bivector applyVersorWI(const rotor &a, const bivector &b, const rotor &c);
/// Returns a * b * inverse(a) using default metric.
trivector applyVersor(const rotor &a, const trivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
trivector applyUnitVersor(const rotor &a, const trivector &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
trivector applyVersorWI(const rotor &a, const trivector &b, const rotor &c);
/// Returns a * b * inverse(a) using default metric.
vector applyVersor(const rotor &a, const e1_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector applyUnitVersor(const rotor &a, const e2_t &b);
/// Returns a * b * inverse(a) using default metric.
trivector applyVersor(const rotor &a, const I3_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
trivector applyUnitVersor(const rotor &a, const I3_t &b);
/// Returns a * b * reverse(a) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
trivector applyVersorWI(const rotor &a, const I3_t &b, const rotor &c);
/// Returns om * mv.
mv applyOM(const om &a, const mv &b);
/// Returns om * vector.
vector applyOM(const om &a, const vector &b);
/// Returns om * bivector.
bivector applyOM(const om &a, const bivector &b);
/// Returns om * trivector.
trivector applyOM(const om &a, const trivector &b);
/// Returns grade1OM * vector.
vector applyOM(const grade1OM &a, const vector &b);
/// Returns grade2OM * bivector.
bivector applyOM(const grade2OM &a, const bivector &b);
/// Returns grade3OM * trivector.
trivector applyOM(const grade3OM &a, const trivector &b);
/// Returns grade1OM * e1_t.
vector applyOM(const grade1OM &a, const e1_t &b);
/// Returns grade1OM * e2_t.
vector applyOM(const grade1OM &a, const e2_t &b);
/// Returns grade1OM * e3_t.
vector applyOM(const grade1OM &a, const e3_t &b);
/// Returns grade3OM * I3_t.
trivector applyOM(const grade3OM &a, const I3_t &b);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns a / b
vector div(const vector &a, const double b);
/// Returns a / b
bivector div(const bivector &a, const double b);
/// Returns a / b
trivector div(const trivector &a, const double b);
/// Returns a / b
rotor div(const rotor &a, const double b);
/// Returns a / b
vector div(const e1_t &a, const double b);
/// Returns a / b
trivector div(const I3_t &a, const double b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);
/// Returns dual of double using default metric.
trivector dual(const double a);
/// Returns undual of double using default metric.
trivector undual(const double a);
/// Returns dual of vector using default metric.
bivector dual(const vector &a);
/// Returns undual of vector using default metric.
bivector undual(const vector &a);
/// Returns dual of bivector using default metric.
vector dual(const bivector &a);
/// Returns undual of bivector using default metric.
vector undual(const bivector &a);
/// Returns dual of rotor using default metric.
oddVersor dual(const rotor &a);
/// Returns undual of rotor using default metric.
oddVersor undual(const rotor &a);
/// Returns dual of oddVersor using default metric.
rotor dual(const oddVersor &a);
/// Returns undual of oddVersor using default metric.
rotor undual(const oddVersor &a);
/// Returns dual of trivector using default metric.
double dual(const trivector &a);
/// Returns undual of trivector using default metric.
double undual(const trivector &a);
/// Returns dual of e1_t using default metric.
bivector dual(const e1_t &a);
/// Returns undual of e2_t using default metric.
bivector undual(const e2_t &a);
/// Returns dual of I3_t using default metric.
double dual(const I3_t &a);
/// Returns undual of I3_t using default metric.
double undual(const I3_t &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const vector &a, const vector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivector &a, const bivector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotor &a, const rotor &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const bivector &a, const rotor &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const trivector &a, const trivector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const rotor &a, const bivector &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const e1_t &a, const e1_t &b, const double c);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const e2_t &a, const I3_t &b, const double c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 0 of  rotor.
double extractGrade0(const rotor &a);
/// Returns grade 2 of  rotor.
bivector extractGrade2(const rotor &a);
/// Returns grade 0 of  oddVersor.
double extractGrade0(const oddVersor &a);
/// Returns grade 1 of  oddVersor.
vector extractGrade1(const oddVersor &a);
/// Returns grade 2 of  oddVersor.
double extractGrade2(const oddVersor &a);
/// Returns grade 3 of  oddVersor.
trivector extractGrade3(const oddVersor &a);
/// Returns grade 0 of  e1_t.
double extractGrade0(const e1_t &a);
/// Returns grade 1 of  e2_t.
e2_t extractGrade1(const e2_t &a);
/// Returns grade 2 of  e3_t.
double extractGrade2(const e3_t &a);
/// Returns grade 3 of  e1_t.
double extractGrade3(const e1_t &a);
/// Returns grade 0 of  I3_t.
double extractGrade0(const I3_t &a);
/// Returns grade 1 of  I3_t.
double extractGrade1(const I3_t &a);
/// Returns grade 2 of  I3_t.
double extractGrade2(const I3_t &a);
/// Returns grade 3 of  I3_t.
I3_t extractGrade3(const I3_t &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of vector and vector.
rotor gp(const vector &a, const vector &b);
/// Returns geometric product of rotor and vector.
oddVersor gp(const rotor &a, const vector &b);
/// Returns geometric product of vector and rotor.
oddVersor gp(const vector &a, const rotor &b);
/// Returns geometric product of rotor and rotor.
rotor gp(const rotor &a, const rotor &b);
/// Returns geometric product of bivector and bivector.
rotor gp(const bivector &a, const bivector &b);
/// Returns geometric product of e1_t and rotor.
oddVersor gp(const e1_t &a, const rotor &b);
/// Returns geometric product of I3_t and rotor.
oddVersor gp(const I3_t &a, const rotor &b);
/// Returns geometric product of bivector and e1_t.
oddVersor gp(const bivector &a, const e1_t &b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const mv &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const rotor &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const vector &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const bivector &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const trivector &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e1_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const e2_t &a, const double b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const I3_t &a, const double b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv hp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and vector.
vector hp(const vector &a, const vector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and bivector.
bivector hp(const bivector &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and rotor.
rotor hp(const rotor &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and rotor.
bivector hp(const bivector &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of trivector and trivector.
trivector hp(const trivector &a, const trivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of trivector and oddVersor.
trivector hp(const trivector &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and bivector.
bivector hp(const rotor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of e1_t and e1_t.
e1_t hp(const e1_t &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of e2_t and e3_t.
double hp(const e2_t &a, const e3_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of oddVersor and I3_t.
trivector hp(const oddVersor &a, const I3_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of mv and mv.
mv ihp(const mv &a, const mv &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and vector.
vector ihp(const vector &a, const vector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and bivector.
bivector ihp(const bivector &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and rotor.
rotor ihp(const rotor &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of bivector and rotor.
bivector ihp(const bivector &a, const rotor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of rotor and bivector.
bivector ihp(const rotor &a, const bivector &b);
/// Returns Hadamard product (coordinate-wise multiplication) of trivector and oddVersor.
trivector ihp(const trivector &a, const oddVersor &b);
/// Returns Hadamard product (coordinate-wise multiplication) of vector and e1_t.
vector ihp(const vector &a, const e1_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of e2_t and e3_t.
double ihp(const e2_t &a, const e3_t &b);
/// Returns Hadamard product (coordinate-wise multiplication) of trivector and I3_t.
trivector ihp(const trivector &a, const I3_t &b);
/// Returns (a + 1).
mv increment(const mv &a);
/// Returns (a + 1).
rotor increment(const bivector &a);
/// Returns (a + 1).
rotor increment(const rotor &a);
/// Returns (a - 1).
mv decrement(const mv &a);
/// Returns (a - 1).
rotor decrement(const bivector &a);
/// Returns (a - 1).
rotor decrement(const rotor &a);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns Hestenes inner product of mv and mv.
mv hip(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns scalar product of vector and vector.
double sp(const vector &a, const vector &b);
/// Returns left contraction of vector and vector.
double lc(const vector &a, const vector &b);
/// Returns right contraction of vector and vector.
double rc(const vector &a, const vector &b);
/// Returns Hestenes inner product of vector and vector.
double hip(const vector &a, const vector &b);
/// Returns Modified Hestenes inner product of vector and vector.
double mhip(const vector &a, const vector &b);
/// Returns scalar product of bivector and vector.
double sp(const bivector &a, const vector &b);
/// Returns left contraction of bivector and vector.
double lc(const bivector &a, const vector &b);
/// Returns right contraction of bivector and vector.
vector rc(const bivector &a, const vector &b);
/// Returns Hestenes inner product of bivector and vector.
vector hip(const bivector &a, const vector &b);
/// Returns Modified Hestenes inner product of bivector and vector.
vector mhip(const bivector &a, const vector &b);
/// Returns scalar product of trivector and trivector.
double sp(const trivector &a, const trivector &b);
/// Returns left contraction of trivector and trivector.
double lc(const trivector &a, const trivector &b);
/// Returns right contraction of trivector and trivector.
double rc(const trivector &a, const trivector &b);
/// Returns Hestenes inner product of trivector and trivector.
double hip(const trivector &a, const trivector &b);
/// Returns Modified Hestenes inner product of trivector and trivector.
double mhip(const trivector &a, const trivector &b);
/// Returns scalar product of vector and bivector.
double sp(const vector &a, const bivector &b);
/// Returns left contraction of vector and bivector.
vector lc(const vector &a, const bivector &b);
/// Returns right contraction of vector and bivector.
double rc(const vector &a, const bivector &b);
/// Returns Hestenes inner product of vector and bivector.
vector hip(const vector &a, const bivector &b);
/// Returns Modified Hestenes inner product of vector and bivector.
vector mhip(const vector &a, const bivector &b);
/// Returns scalar product of vector and rotor.
double sp(const vector &a, const rotor &b);
/// Returns left contraction of vector and rotor.
vector lc(const vector &a, const rotor &b);
/// Returns right contraction of vector and rotor.
vector rc(const vector &a, const rotor &b);
/// Returns Hestenes inner product of vector and rotor.
vector hip(const vector &a, const rotor &b);
/// Returns Modified Hestenes inner product of vector and rotor.
vector mhip(const vector &a, const rotor &b);
/// Returns scalar product of rotor and bivector.
double sp(const rotor &a, const bivector &b);
/// Returns left contraction of rotor and bivector.
rotor lc(const rotor &a, const bivector &b);
/// Returns right contraction of rotor and bivector.
double rc(const rotor &a, const bivector &b);
/// Returns Hestenes inner product of rotor and bivector.
double hip(const rotor &a, const bivector &b);
/// Returns Modified Hestenes inner product of rotor and bivector.
rotor mhip(const rotor &a, const bivector &b);
/// Returns scalar product of rotor and trivector.
double sp(const rotor &a, const trivector &b);
/// Returns left contraction of rotor and trivector.
oddVersor lc(const rotor &a, const trivector &b);
/// Returns right contraction of rotor and trivector.
double rc(const rotor &a, const trivector &b);
/// Returns Hestenes inner product of rotor and trivector.
vector hip(const rotor &a, const trivector &b);
/// Returns Modified Hestenes inner product of rotor and trivector.
oddVersor mhip(const rotor &a, const trivector &b);
/// Returns scalar product of e1_t and I3_t.
double sp(const e1_t &a, const I3_t &b);
/// Returns left contraction of I3_t and e3_t.
double lc(const I3_t &a, const e3_t &b);
/// Returns right contraction of e1_t and e1_t.
double rc(const e1_t &a, const e1_t &b);
/// Returns Hestenes inner product of e2_t and I3_t.
bivector hip(const e2_t &a, const I3_t &b);
/// Returns Modified Hestenes inner product of I3_t and I3_t.
double mhip(const I3_t &a, const I3_t &b);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm of vector using default metric.
double norm(const vector &a);
/// internal conversion function
double norm_returns_scalar(const vector &a);
/// Returns norm of bivector using default metric.
double norm(const bivector &a);
/// internal conversion function
double norm_returns_scalar(const bivector &a);
/// Returns norm of trivector using default metric.
double norm(const trivector &a);
/// internal conversion function
double norm_returns_scalar(const trivector &a);
/// Returns norm of rotor using default metric.
double norm(const rotor &a);
/// internal conversion function
double norm_returns_scalar(const rotor &a);
/// Returns norm of e1_t using default metric.
double norm(const e1_t &a);
/// internal conversion function
double norm_returns_scalar(const e1_t &a);
/// Returns norm of e3_t using default metric.
double norm(const e3_t &a);
/// internal conversion function
double norm_returns_scalar(const e3_t &a);
/// Returns norm of I3_t using default metric.
double norm(const I3_t &a);
/// internal conversion function
double norm_returns_scalar(const I3_t &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns norm2 of vector using default metric.
double norm2(const vector &a);
/// internal conversion function
double norm2_returns_scalar(const vector &a);
/// Returns norm2 of bivector using default metric.
double norm2(const bivector &a);
/// internal conversion function
double norm2_returns_scalar(const bivector &a);
/// Returns norm2 of trivector using default metric.
double norm2(const trivector &a);
/// internal conversion function
double norm2_returns_scalar(const trivector &a);
/// Returns norm2 of rotor using default metric.
double norm2(const rotor &a);
/// internal conversion function
double norm2_returns_scalar(const rotor &a);
/// Returns norm2 of e1_t using default metric.
double norm2(const e1_t &a);
/// internal conversion function
double norm2_returns_scalar(const e1_t &a);
/// Returns norm2 of e3_t using default metric.
double norm2(const e3_t &a);
/// internal conversion function
double norm2_returns_scalar(const e3_t &a);
/// Returns norm2 of I3_t using default metric.
double norm2(const I3_t &a);
/// internal conversion function
double norm2_returns_scalar(const I3_t &a);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vector and vector.
bivector op(const vector &a, const vector &b);
/// Returns outer product of bivector and bivector.
double op(const bivector &a, const bivector &b);
/// Returns outer product of vector and rotor.
oddVersor op(const vector &a, const rotor &b);
/// Returns outer product of vector and trivector.
double op(const vector &a, const trivector &b);
/// Returns outer product of e1_t and e1_t.
double op(const e1_t &a, const e1_t &b);
/// Returns outer product of e1_t and e2_t.
bivector op(const e1_t &a, const e2_t &b);
/// Returns outer product of e2_t and e3_t.
bivector op(const e2_t &a, const e3_t &b);
/// Returns geometric product of mv and double.
mv gp(const mv &a, const double b);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);
/// exp of bivector (uses fast special case)
rotor exp(const bivector &a);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);
/// cosh of bivector (uses fast special case)
double cosh(const bivector &a);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);
/// sinh of bivector (uses fast special case)
bivector sinh(const bivector &a);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);
/// cos of bivector (uses fast special case)
double cos(const bivector &a);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);
/// sin of bivector (uses fast special case)
bivector sin(const bivector &a);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns negation of vector.
vector negate(const vector &a);
/// Returns Clifford conjugate of vector.
vector cliffordConjugate(const vector &a);
/// Returns grade involution of vector.
vector gradeInvolution(const vector &a);
/// Returns reverse of vector.
vector reverse(const vector &a);
/// Returns negation of bivector.
bivector negate(const bivector &a);
/// Returns Clifford conjugate of bivector.
bivector cliffordConjugate(const bivector &a);
/// Returns grade involution of bivector.
bivector gradeInvolution(const bivector &a);
/// Returns reverse of bivector.
bivector reverse(const bivector &a);
/// Returns negation of trivector.
trivector negate(const trivector &a);
/// Returns Clifford conjugate of trivector.
trivector cliffordConjugate(const trivector &a);
/// Returns grade involution of trivector.
trivector gradeInvolution(const trivector &a);
/// Returns reverse of trivector.
trivector reverse(const trivector &a);
/// Returns negation of rotor.
rotor negate(const rotor &a);
/// Returns Clifford conjugate of rotor.
rotor cliffordConjugate(const rotor &a);
/// Returns grade involution of rotor.
rotor gradeInvolution(const rotor &a);
/// Returns reverse of rotor.
rotor reverse(const rotor &a);
/// Returns negation of e1_t.
vector negate(const e1_t &a);
/// Returns Clifford conjugate of e2_t.
vector cliffordConjugate(const e2_t &a);
/// Returns grade involution of e3_t.
vector gradeInvolution(const e3_t &a);
/// Returns reverse of I3_t.
trivector reverse(const I3_t &a);
/// Returns negation of double.
double negate(const double a);
/// Returns Clifford conjugate of double.
double cliffordConjugate(const double a);
/// Returns grade involution of double.
double gradeInvolution(const double a);
/// Returns reverse of double.
double reverse(const double a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns unit of vector using default metric.
vector unit(const vector &a);
/// Returns unit of bivector using default metric.
bivector unit(const bivector &a);
/// Returns unit of trivector using default metric.
trivector unit(const trivector &a);
/// Returns unit of rotor using default metric.
rotor unit(const rotor &a);
/// Returns unit of oddVersor using default metric.
oddVersor unit(const oddVersor &a);
/// Returns unit of e1_t using default metric.
e1_t unit(const e1_t &a);
/// Returns unit of e2_t using default metric.
e2_t unit(const e2_t &a);
/// Returns unit of I3_t using default metric.
I3_t unit(const I3_t &a);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns versor inverse of a using default metric.
vector versorInverse(const vector &a);
/// Returns versor inverse of a using default metric.
bivector versorInverse(const bivector &a);
/// Returns versor inverse of a using default metric.
trivector versorInverse(const trivector &a);
/// Returns versor inverse of a using default metric.
rotor versorInverse(const rotor &a);
/// Returns versor inverse of a using default metric.
e1_t versorInverse(const e1_t &a);
/// Returns versor inverse of a using default metric.
e3_t versorInverse(const e3_t &a);
/// Returns versor inverse of a using default metric.
trivector versorInverse(const I3_t &a);
/// Returns true if all coordinates of a are abs <= b
bool zero(const mv &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const vector &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const bivector &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const trivector &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const rotor &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const I3_t &a, const double b);
/// Returns true if all coordinates of a are abs <= b
bool zero(const e1_t &a, const double b);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vector operator+(const vector &a, const vector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline vector &operator+=(vector &a, const vector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline bivector operator+(const bivector &a, const bivector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline bivector &operator+=(bivector &a, const bivector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline oddVersor operator+(const vector &a, const trivector &b) {
	return add(a, b);
}
/// returns add(a, b)
inline rotor operator+(const rotor &a, const bivector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline rotor &operator+=(rotor &a, const bivector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vector operator+(const e1_t &a, const e2_t &b) {
	return add(a, b);
}
/// returns add(a, b)
inline oddVersor operator+(const e1_t &a, const I3_t &b) {
	return add(a, b);
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector operator-(const vector &a, const vector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector &operator-=(vector &a, const vector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector operator-(const bivector &a, const bivector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector &operator-=(bivector &a, const bivector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline rotor operator-(const bivector &a, const rotor &b) {
	return subtract(a, b);
}
/// returns subtract(a, b)
inline oddVersor operator-(const vector &a, const trivector &b) {
	return subtract(a, b);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns dual(a)
inline bivector operator*(const vector &a) {
	return dual(a);
}
/// returns dual(a)
inline vector operator*(const bivector &a) {
	return dual(a);
}
/// returns dual(a)
inline oddVersor operator*(const rotor &a) {
	return dual(a);
}
/// returns dual(a)
inline rotor operator*(const oddVersor &a) {
	return dual(a);
}
/// returns dual(a)
inline double operator*(const trivector &a) {
	return dual(a);
}
/// returns dual(a)
inline bivector operator*(const e1_t &a) {
	return dual(a);
}
/// returns dual(a)
inline double operator*(const I3_t &a) {
	return dual(a);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotor operator*(const vector &a, const vector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const rotor &a, const vector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const vector &a, const rotor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline rotor operator*(const rotor &a, const rotor &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline rotor &operator*=(rotor &a, const rotor &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline rotor operator*(const bivector &a, const bivector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const e1_t &a, const rotor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const I3_t &a, const rotor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline oddVersor operator*(const bivector &a, const e1_t &b) {
	return gp(a, b);
}
/// returns (a = increment(a))
inline mv &operator++(mv &a) {
	a = increment(a);
	return a;
}
/// returns (a = increment(a))
inline rotor operator++(const bivector &a) {
	return increment(a);
}
/// returns (a = increment(a))
inline rotor &operator++(rotor &a) {
	a = increment(a);
	return a;
}
/// returns (a = decrement(a))
inline mv &operator--(mv &a) {
	a = decrement(a);
	return a;
}
/// returns (a = decrement(a))
inline rotor operator--(const bivector &a) {
	return decrement(a);
}
/// returns (a = decrement(a))
inline rotor &operator--(rotor &a) {
	a = decrement(a);
	return a;
}
/// returns sp(a, b)
inline mv operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns (a = sp(a, b))
inline mv &operator%=(mv &a, const mv &b) {
	return (a = sp(a, b));
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline mv operator>>(const mv &a, const mv &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline mv &operator>>=(mv &a, const mv &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const vector &a, const vector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const vector &a, const vector &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const vector &a, const vector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector &a, const vector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const bivector &a, const vector &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline vector operator>>(const bivector &a, const vector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const trivector &a, const trivector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const trivector &a, const trivector &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const trivector &a, const trivector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector &a, const bivector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline vector operator<<(const vector &a, const bivector &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline vector &operator<<=(vector &a, const bivector &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline double operator>>(const vector &a, const bivector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector &a, const rotor &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline vector operator<<(const vector &a, const rotor &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline vector &operator<<=(vector &a, const rotor &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline vector operator>>(const vector &a, const rotor &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline vector &operator>>=(vector &a, const rotor &b) {
	return (a = rc(a, b));
}
/// returns sp(a, b)
inline double operator%(const rotor &a, const bivector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline rotor operator<<(const rotor &a, const bivector &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline rotor &operator<<=(rotor &a, const bivector &b) {
	return (a = lc(a, b));
}
/// returns rc(a, b)
inline double operator>>(const rotor &a, const bivector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const rotor &a, const trivector &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline oddVersor operator<<(const rotor &a, const trivector &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const rotor &a, const trivector &b) {
	return rc(a, b);
}
/// returns sp(a, b)
inline double operator%(const e1_t &a, const I3_t &b) {
	return sp(a, b);
}
/// returns lc(a, b)
inline double operator<<(const I3_t &a, const e3_t &b) {
	return lc(a, b);
}
/// returns rc(a, b)
inline double operator>>(const e1_t &a, const e1_t &b) {
	return rc(a, b);
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline bivector operator^(const vector &a, const vector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivector &a, const bivector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline oddVersor operator^(const vector &a, const rotor &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const vector &a, const trivector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const e1_t &a, const e1_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline bivector operator^(const e1_t &a, const e2_t &b) {
	return op(a, b);
}
/// returns op(a, b)
inline bivector operator^(const e2_t &a, const e3_t &b) {
	return op(a, b);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const double &b) {
	return (a = gp(a, b));
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns negate(a)
inline vector operator-(const vector &a) {
	return negate(a);
}
/// returns reverse(a)
inline vector operator~(const vector &a) {
	return reverse(a);
}
/// returns negate(a)
inline bivector operator-(const bivector &a) {
	return negate(a);
}
/// returns reverse(a)
inline bivector operator~(const bivector &a) {
	return reverse(a);
}
/// returns negate(a)
inline trivector operator-(const trivector &a) {
	return negate(a);
}
/// returns reverse(a)
inline trivector operator~(const trivector &a) {
	return reverse(a);
}
/// returns negate(a)
inline rotor operator-(const rotor &a) {
	return negate(a);
}
/// returns reverse(a)
inline rotor operator~(const rotor &a) {
	return reverse(a);
}
/// returns negate(a)
inline vector operator-(const e1_t &a) {
	return negate(a);
}
/// returns reverse(a)
inline trivector operator~(const I3_t &a) {
	return reverse(a);
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline vector operator!(const vector &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline bivector operator!(const bivector &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline trivector operator!(const trivector &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline rotor operator!(const rotor &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline e1_t operator!(const e1_t &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline e3_t operator!(const e3_t &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline trivector operator!(const I3_t &a) {
	return versorInverse(a);
}

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
}
inline void mv::set(double val) {
	setGroupUsage(1);
	m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
	setGroupUsage(gu);
	e3ga::copy_N(m_c, arr, e3ga_mvSize[gu]);

}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const double*srcC = src.getC();
	e3ga::copy_N(m_c, srcC, e3ga_mvSize[src.gu()]);

}
inline void e1_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void e3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void I3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 3;
	}
	if (src.gu() & 4) {
		ptr += 3;
	}
	if (src.gu() & 8) {
	}
	else {
	}
}
inline void vector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
	}
}
inline void bivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 3;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void trivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 3;
	}
	if (src.gu() & 4) {
		ptr += 3;
	}
	if (src.gu() & 8) {
		m_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e3 = 0.0;
	}
}
inline void rotor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_scalar = ptr[0];
		ptr += 1;
	}
	else {
		m_scalar = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 3;
	}
	if (src.gu() & 4) {
		m_e1_e2 = ptr[0];
		m_e2_e3 = ptr[2];
		m_e3_e1 = -ptr[1];
	}
	else {
		m_e1_e2 = 0.0;
		m_e2_e3 = 0.0;
		m_e3_e1 = 0.0;
	}
}
inline void oddVersor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_e1 = ptr[0];
		m_e2 = ptr[1];
		m_e3 = ptr[2];
		ptr += 3;
	}
	else {
		m_e1 = 0.0;
		m_e2 = 0.0;
		m_e3 = 0.0;
	}
	if (src.gu() & 4) {
		ptr += 3;
	}
	if (src.gu() & 8) {
		m_e1_e2_e3 = ptr[0];
	}
	else {
		m_e1_e2_e3 = 0.0;
	}
}
inline void mv::set(const e1_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = ptr[2] = 0.0;
}
inline void mv::set(const e2_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[2] = 0.0;
	ptr[1] = 1.0;
}
inline void mv::set(const e3_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const I3_t &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const vector &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
}
inline void mv::set(const bivector &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
}
inline void mv::set(const trivector &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = src.m_e1_e2_e3;
}
inline void mv::set(const rotor &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_scalar;
	ptr += 1;
	ptr[0] = src.m_e1_e2;
	ptr[1] = -src.m_e3_e1;
	ptr[2] = src.m_e2_e3;
}
inline void mv::set(const oddVersor &src) {
	setGroupUsage(10);
	double *ptr = m_c;
	ptr[0] = src.m_e1;
	ptr[1] = src.m_e2;
	ptr[2] = src.m_e3;
	ptr += 3;
	ptr[0] = src.m_e1_e2_e3;
}

inline double _double(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void vector::set()
{
	m_e1 = m_e2 = m_e3 = 0.0;

}
inline void bivector::set()
{
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void trivector::set()
{
	m_e1_e2_e3 = 0.0;

}
inline void rotor::set()
{
	m_scalar = m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}
inline void oddVersor::set()
{
	m_e1 = m_e2 = m_e3 = m_e1_e2_e3 = 0.0;

}

inline void rotor::set(const double scalarVal)
{
	m_scalar = scalarVal;
	m_e1_e2 = m_e2_e3 = m_e3_e1 = 0.0;

}

inline void vector::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;

}
inline void bivector::set(const CoordinateOrder co, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void trivector::set(const CoordinateOrder co, const double _e1_e2_e3)
{
	m_e1_e2_e3 = _e1_e2_e3;

}
inline void rotor::set(const CoordinateOrder co, const double _scalar, const double _e1_e2, const double _e2_e3, const double _e3_e1)
{
	m_scalar = _scalar;
	m_e1_e2 = _e1_e2;
	m_e2_e3 = _e2_e3;
	m_e3_e1 = _e3_e1;

}
inline void oddVersor::set(const CoordinateOrder co, const double _e1, const double _e2, const double _e3, const double _e1_e2_e3)
{
	m_e1 = _e1;
	m_e2 = _e2;
	m_e3 = _e3;
	m_e1_e2_e3 = _e1_e2_e3;

}

inline void vector::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];

}
inline void bivector::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2 = A[0];
	m_e2_e3 = A[1];
	m_e3_e1 = A[2];

}
inline void trivector::set(const CoordinateOrder co, const double *A)
{
	m_e1_e2_e3 = A[0];

}
inline void rotor::set(const CoordinateOrder co, const double *A)
{
	m_scalar = A[0];
	m_e1_e2 = A[1];
	m_e2_e3 = A[2];
	m_e3_e1 = A[3];

}
inline void oddVersor::set(const CoordinateOrder co, const double *A)
{
	m_e1 = A[0];
	m_e2 = A[1];
	m_e3 = A[2];
	m_e1_e2_e3 = A[3];

}

inline void e1_t::set(const e1_t &a)
{

}
inline void e2_t::set(const e2_t &a)
{

}
inline void e3_t::set(const e3_t &a)
{

}
inline void I3_t::set(const I3_t &a)
{

}
inline void vector::set(const vector &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;

}
inline void bivector::set(const bivector &a)
{
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void trivector::set(const trivector &a)
{
	m_e1_e2_e3 = a.m_e1_e2_e3;

}
inline void rotor::set(const rotor &a)
{
	m_scalar = a.m_scalar;
	m_e1_e2 = a.m_e1_e2;
	m_e2_e3 = a.m_e2_e3;
	m_e3_e1 = a.m_e3_e1;

}
inline void oddVersor::set(const oddVersor &a)
{
	m_e1 = a.m_e1;
	m_e2 = a.m_e2;
	m_e3 = a.m_e3;
	m_e1_e2_e3 = a.m_e1_e2_e3;

}


inline double e1_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e1_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	return maxValue;
}
inline double e2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 2;
	return maxValue;
}
inline double e3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double e3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 4;
	return maxValue;
}
inline double I3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 7;
	return maxValue;
}
inline double vector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	return maxValue;
}
inline double vector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	return maxValue;
}
inline double bivector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2);
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double bivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2);
	bm = 0;
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	return maxValue;
}
inline double trivector::largestCoordinate() const {
	double maxValue = ::fabs(m_e1_e2_e3);
	return maxValue;
}
inline double trivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1_e2_e3);
	bm = 0;
	return maxValue;
}
inline double rotor::largestCoordinate() const {
	double maxValue = ::fabs(m_scalar);
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); }
	return maxValue;
}
inline double rotor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_scalar);
	bm = 0;
	if (::fabs(m_e1_e2) > maxValue) { maxValue = ::fabs(m_e1_e2); bm = 3; }
	if (::fabs(m_e2_e3) > maxValue) { maxValue = ::fabs(m_e2_e3); bm = 6; }
	if (::fabs(m_e3_e1) > maxValue) { maxValue = ::fabs(m_e3_e1); bm = 5; }
	return maxValue;
}
inline double oddVersor::largestCoordinate() const {
	double maxValue = ::fabs(m_e1);
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); }
	return maxValue;
}
inline double oddVersor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_e1);
	bm = 0;
	if (::fabs(m_e2) > maxValue) { maxValue = ::fabs(m_e2); bm = 2; }
	if (::fabs(m_e3) > maxValue) { maxValue = ::fabs(m_e3); bm = 4; }
	if (::fabs(m_e1_e2_e3) > maxValue) { maxValue = ::fabs(m_e1_e2_e3); bm = 7; }
	return maxValue;
}

inline double _double(const e1_t &x) {
	return 0.0;
}
inline double _double(const e2_t &x) {
	return 0.0;
}
inline double _double(const e3_t &x) {
	return 0.0;
}
inline double _double(const I3_t &x) {
	return 0.0;
}
inline double _double(const vector &x) {
	return 0.0;
}
inline double _double(const bivector &x) {
	return 0.0;
}
inline double _double(const trivector &x) {
	return 0.0;
}
inline double _double(const rotor &x) {
	return x.m_scalar;
}
inline double _double(const oddVersor &x) {
	return 0.0;
}

inline void om::setIdentity() {
	e3ga::zero_9(m_m1);

	e3ga::zero_9(m_m2);

	e3ga::zero_1(m_m3);

	m_m1[0] = m_m1[4] = m_m1[8] = m_m2[0] = m_m2[4] = m_m2[8] = m_m3[0] = 1.0;
}

inline void om::set(const om &src) {
	e3ga::copy_9(m_m1, src.m_m1);

	e3ga::copy_9(m_m2, src.m_m2);

	e3ga::copy_1(m_m3, src.m_m3);

}
inline void grade1OM::set(const om &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
}
inline void grade2OM::set(const om &src) {
	m_m2[0] =  src.m_m2[0];
	m_m2[1] =  src.m_m2[2];
	m_m2[2] = -1.0 *  src.m_m2[1];
	m_m2[3] =  src.m_m2[6];
	m_m2[4] =  src.m_m2[8];
	m_m2[5] = -1.0 *  src.m_m2[7];
	m_m2[6] = -1.0 *  src.m_m2[3];
	m_m2[7] = -1.0 *  src.m_m2[5];
	m_m2[8] =  src.m_m2[4];
}
inline void grade3OM::set(const om &src) {
	m_m3[0] =  src.m_m3[0];
}
inline void om::set(const grade1OM &src) {
	m_m1[0] =  src.m_m1[0];
	m_m1[1] =  src.m_m1[1];
	m_m1[2] =  src.m_m1[2];
	m_m1[3] =  src.m_m1[3];
	m_m1[4] =  src.m_m1[4];
	m_m1[5] =  src.m_m1[5];
	m_m1[6] =  src.m_m1[6];
	m_m1[7] =  src.m_m1[7];
	m_m1[8] =  src.m_m1[8];
	m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = 
		m_m3[0] = 0.0;
}
inline void om::set(const grade2OM &src) {
	m_m2[0] =  src.m_m2[0];
	m_m2[1] = -1.0 *  src.m_m2[2];
	m_m2[2] =  src.m_m2[1];
	m_m2[3] = -1.0 *  src.m_m2[6];
	m_m2[4] =  src.m_m2[8];
	m_m2[5] = -1.0 *  src.m_m2[7];
	m_m2[6] =  src.m_m2[3];
	m_m2[7] = -1.0 *  src.m_m2[5];
	m_m2[8] =  src.m_m2[4];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m3[0] = 0.0;
}
inline void om::set(const grade3OM &src) {
	m_m3[0] =  src.m_m3[0];
	m_m1[0] = m_m1[1] = m_m1[2] = m_m1[3] = m_m1[4] = m_m1[5] = m_m1[6] = m_m1[7] = m_m1[8] = 
		m_m2[0] = m_m2[1] = m_m2[2] = m_m2[3] = m_m2[4] = m_m2[5] = m_m2[6] = m_m2[7] = m_m2[8] = 
		0.0;
}

inline void grade1OM::setIdentity()
{
	m_m1[0] = 1.0;
	m_m1[3] = m_m1[6] = 0.0;

	m_m1[1] = m_m1[7] = 0.0;
	m_m1[4] = 1.0;

	m_m1[2] = m_m1[5] = 0.0;
	m_m1[8] = 1.0;

}

inline void grade2OM::setIdentity()
{
	m_m2[0] = 1.0;
	m_m2[3] = m_m2[6] = 0.0;

	m_m2[1] = m_m2[7] = 0.0;
	m_m2[4] = 1.0;

	m_m2[2] = m_m2[5] = 0.0;
	m_m2[8] = 1.0;

}

inline void grade3OM::setIdentity()
{
	m_m3[0] = 1.0;

}

inline void grade1OM::set(const grade1OM &src)
{
	m_m1[0] = src.m_m1[0];
	m_m1[3] = src.m_m1[3];
	m_m1[6] = src.m_m1[6];

	m_m1[1] = src.m_m1[1];
	m_m1[4] = src.m_m1[4];
	m_m1[7] = src.m_m1[7];

	m_m1[2] = src.m_m1[2];
	m_m1[5] = src.m_m1[5];
	m_m1[8] = src.m_m1[8];

}

inline void grade2OM::set(const grade2OM &src)
{
	m_m2[0] = src.m_m2[0];
	m_m2[3] = src.m_m2[3];
	m_m2[6] = src.m_m2[6];

	m_m2[1] = src.m_m2[1];
	m_m2[4] = src.m_m2[4];
	m_m2[7] = src.m_m2[7];

	m_m2[2] = src.m_m2[2];
	m_m2[5] = src.m_m2[5];
	m_m2[8] = src.m_m2[8];

}

inline void grade3OM::set(const grade3OM &src)
{
	m_m3[0] = src.m_m3[0];

}
inline void grade1OM::set(const vector &ie1, const vector &ie2, const vector &ie3)
{
	// Set image of e1
	m_m1[0] = ie1.m_e1;
	m_m1[3] = ie1.m_e2;
	m_m1[6] = ie1.m_e3;

	// Set image of e2
	m_m1[1] = ie2.m_e1;
	m_m1[4] = ie2.m_e2;
	m_m1[7] = ie2.m_e3;

	// Set image of e3
	m_m1[2] = ie3.m_e1;
	m_m1[5] = ie3.m_e2;
	m_m1[8] = ie3.m_e3;

}
inline void grade2OM::set(const vector &ie1, const vector &ie2, const vector &ie3)
{
	// Set image of e1^e2
	m_m2[0] = (ie1.m_e1*ie2.m_e2-ie1.m_e2*ie2.m_e1);
	m_m2[3] = (ie1.m_e2*ie2.m_e3-ie1.m_e3*ie2.m_e2);
	m_m2[6] = -(ie1.m_e1*ie2.m_e3-ie1.m_e3*ie2.m_e1);

	// Set image of e2^e3
	m_m2[1] = (ie2.m_e1*ie3.m_e2-ie2.m_e2*ie3.m_e1);
	m_m2[4] = (ie2.m_e2*ie3.m_e3-ie2.m_e3*ie3.m_e2);
	m_m2[7] = -(ie2.m_e1*ie3.m_e3-ie2.m_e3*ie3.m_e1);

	// Set image of -1*e1^e3
	m_m2[2] = (-ie1.m_e1*ie3.m_e2+ie1.m_e2*ie3.m_e1);
	m_m2[5] = (-ie1.m_e2*ie3.m_e3+ie1.m_e3*ie3.m_e2);
	m_m2[8] = -(-ie1.m_e1*ie3.m_e3+ie1.m_e3*ie3.m_e1);

}
inline void grade3OM::set(const vector &ie1, const vector &ie2, const vector &ie3)
{
	// Set image of e1^e2^e3
	m_m3[0] = (ie1.m_e1*ie2.m_e2*ie3.m_e3-ie1.m_e1*ie2.m_e3*ie3.m_e2-ie1.m_e2*ie2.m_e1*ie3.m_e3+ie1.m_e2*ie2.m_e3*ie3.m_e1+ie1.m_e3*ie2.m_e1*ie3.m_e2-ie1.m_e3*ie2.m_e2*ie3.m_e1);

}
inline void grade1OM::set(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[3] = M[3];
	m_m1[6] = M[6];

	// Set image of e2
	m_m1[1] = M[1];
	m_m1[4] = M[4];
	m_m1[7] = M[7];

	// Set image of e3
	m_m1[2] = M[2];
	m_m1[5] = M[5];
	m_m1[8] = M[8];

}
inline void grade2OM::set(const double *M)
{
	// Set image of e1^e2
	m_m2[0] = (M[0]*M[4]-M[1]*M[3]);
	m_m2[3] = (M[3]*M[7]-M[4]*M[6]);
	m_m2[6] = -(M[0]*M[7]-M[1]*M[6]);

	// Set image of e2^e3
	m_m2[1] = (M[1]*M[5]-M[2]*M[4]);
	m_m2[4] = (M[4]*M[8]-M[5]*M[7]);
	m_m2[7] = -(M[1]*M[8]-M[2]*M[7]);

	// Set image of -1*e1^e3
	m_m2[2] = (-M[0]*M[5]+M[2]*M[3]);
	m_m2[5] = (-M[3]*M[8]+M[5]*M[6]);
	m_m2[8] = -(-M[0]*M[8]+M[2]*M[6]);

}
inline void grade3OM::set(const double *M)
{
	// Set image of e1^e2^e3
	m_m3[0] = (M[0]*M[4]*M[8]-M[0]*M[5]*M[7]-M[1]*M[3]*M[8]+M[1]*M[5]*M[6]+M[2]*M[3]*M[7]-M[2]*M[4]*M[6]);

}
inline void grade1OM::setTranspose(const double *M)
{
	// Set image of e1
	m_m1[0] = M[0];
	m_m1[3] = M[1];
	m_m1[6] = M[2];

	// Set image of e2
	m_m1[1] = M[3];
	m_m1[4] = M[4];
	m_m1[7] = M[5];

	// Set image of e3
	m_m1[2] = M[6];
	m_m1[5] = M[7];
	m_m1[8] = M[8];

}
inline void grade2OM::setTranspose(const double *M)
{
	// Set image of e1^e2
	m_m2[0] = (M[0]*M[4]-M[1]*M[3]);
	m_m2[3] = (M[1]*M[5]-M[2]*M[4]);
	m_m2[6] = -(M[0]*M[5]-M[2]*M[3]);

	// Set image of e2^e3
	m_m2[1] = (M[3]*M[7]-M[4]*M[6]);
	m_m2[4] = (M[4]*M[8]-M[5]*M[7]);
	m_m2[7] = -(M[3]*M[8]-M[5]*M[6]);

	// Set image of -1*e1^e3
	m_m2[2] = (-M[0]*M[7]+M[1]*M[6]);
	m_m2[5] = (-M[1]*M[8]+M[2]*M[7]);
	m_m2[8] = -(-M[0]*M[8]+M[2]*M[6]);

}
inline void grade3OM::setTranspose(const double *M)
{
	// Set image of e1^e2^e3
	m_m3[0] = (M[0]*M[4]*M[8]-M[0]*M[5]*M[7]-M[1]*M[3]*M[8]+M[1]*M[5]*M[6]+M[2]*M[3]*M[7]-M[2]*M[4]*M[6]);

}
inline bivector _bivector(const rotor &R)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			R.m_e1_e2, // e1_e2
			R.m_e2_e3, // e2_e3
			R.m_e3_e1 // e3_e1
		);

}
inline vector _vector(const oddVersor &V)
{
	return vector(vector::coord_e1_e2_e3,
			V.m_e1, // e1
			V.m_e2, // e2
			V.m_e3 // e3
		);

}
inline trivector _trivector(const oddVersor &V)
{
	return trivector(trivector::coord_e1e2e3,
			V.m_e1_e2_e3 // e1_e2_e3
		);

}
inline double genrand() {
return (double)((double)(rand() & 0x7FFF) / 32768.0) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0)) + 
	(double)((double)(rand() & 0x7FFF) / (32768.0 * 32768.0 * 32768.0 * 32768.0)); 
}
inline void genrand_seed(unsigned int seed) {
	srand(seed);
}

inline void genrand_timeSeed() {
	genrand_seed((unsigned int)time(NULL));
}

inline vector add(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1+b.m_e1), // e1
			(a.m_e2+b.m_e2), // e2
			(a.m_e3+b.m_e3) // e3
		);

}
inline bivector add(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1) // e3_e1
		);

}
inline oddVersor add(const vector &a, const trivector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor add(const rotor &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			(a.m_e1_e2+b.m_e1_e2), // e1_e2
			(a.m_e2_e3+b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1-b.m_e3_e1) // e3_e1
		);

}
inline vector add(const e1_t &a, const e2_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			1.0, // e1
			1.0, // e2
			0.0 // e3
		);

}
inline oddVersor add(const e1_t &a, const I3_t &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			1.0, // e1
			0.0, // e2
			0.0, // e3
			1.0 // e1_e2_e3
		);

}
inline vector subtract(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1-b.m_e1), // e1
			(a.m_e2-b.m_e2), // e2
			(a.m_e3-b.m_e3) // e3
		);

}
inline bivector subtract(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline rotor subtract(const bivector &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-b.m_scalar, // scalar
			(a.m_e1_e2-b.m_e1_e2), // e1_e2
			(a.m_e2_e3-b.m_e2_e3), // e2_e3
			-(-a.m_e3_e1+b.m_e3_e1) // e3_e1
		);

}
inline oddVersor subtract(const vector &a, const trivector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3, // e3
			-b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline vector applyVersor(const rotor &a, const vector &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return vector(vector::coord_e1_e2_e3,
			((-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1))/(_n2_), // e1
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2))/(_n2_), // e2
			((a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3))/(_n2_) // e3
		);
}
inline vector applyUnitVersor(const rotor &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e1_e2*a.m_e1_e2*b.m_e1+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e3+2.0*a.m_e1_e2*a.m_scalar*b.m_e2+a.m_e2_e3*a.m_e2_e3*b.m_e1+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e1+-2.0*a.m_e3_e1*a.m_scalar*b.m_e3+a.m_scalar*a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3+-2.0*a.m_e1_e2*a.m_scalar*b.m_e1-a.m_e2_e3*a.m_e2_e3*b.m_e2+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e1+2.0*a.m_e2_e3*a.m_scalar*b.m_e3+a.m_e3_e1*a.m_e3_e1*b.m_e2+a.m_scalar*a.m_scalar*b.m_e2), // e2
			(a.m_e1_e2*a.m_e1_e2*b.m_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e2-a.m_e2_e3*a.m_e2_e3*b.m_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3+2.0*a.m_e3_e1*a.m_scalar*b.m_e1+a.m_scalar*a.m_scalar*b.m_e3) // e3
		);
}
inline vector applyVersorWI(const rotor &a, const vector &b, const rotor &c)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e1*c.m_e1_e2+a.m_e1_e2*b.m_e2*c.m_scalar-a.m_e1_e2*b.m_e3*c.m_e2_e3-a.m_e2_e3*b.m_e1*c.m_e2_e3-a.m_e2_e3*b.m_e2*c.m_e3_e1-a.m_e2_e3*b.m_e3*c.m_e1_e2+a.m_e3_e1*b.m_e1*c.m_e3_e1-a.m_e3_e1*b.m_e2*c.m_e2_e3-a.m_e3_e1*b.m_e3*c.m_scalar+a.m_scalar*b.m_e1*c.m_scalar-a.m_scalar*b.m_e2*c.m_e1_e2+a.m_scalar*b.m_e3*c.m_e3_e1), // e1
			(-a.m_e1_e2*b.m_e1*c.m_scalar+a.m_e1_e2*b.m_e2*c.m_e1_e2-a.m_e1_e2*b.m_e3*c.m_e3_e1-a.m_e2_e3*b.m_e1*c.m_e3_e1+a.m_e2_e3*b.m_e2*c.m_e2_e3+a.m_e2_e3*b.m_e3*c.m_scalar-a.m_e3_e1*b.m_e1*c.m_e2_e3-a.m_e3_e1*b.m_e2*c.m_e3_e1-a.m_e3_e1*b.m_e3*c.m_e1_e2+a.m_scalar*b.m_e1*c.m_e1_e2+a.m_scalar*b.m_e2*c.m_scalar-a.m_scalar*b.m_e3*c.m_e2_e3), // e2
			(-a.m_e1_e2*b.m_e1*c.m_e2_e3-a.m_e1_e2*b.m_e2*c.m_e3_e1-a.m_e1_e2*b.m_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1*c.m_e1_e2-a.m_e2_e3*b.m_e2*c.m_scalar+a.m_e2_e3*b.m_e3*c.m_e2_e3+a.m_e3_e1*b.m_e1*c.m_scalar-a.m_e3_e1*b.m_e2*c.m_e1_e2+a.m_e3_e1*b.m_e3*c.m_e3_e1-a.m_scalar*b.m_e1*c.m_e3_e1+a.m_scalar*b.m_e2*c.m_e2_e3+a.m_scalar*b.m_e3*c.m_scalar) // e3
		);
}
inline bivector applyVersor(const rotor &a, const bivector &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2))/(_n2_), // e1_e2
			((-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3))/(_n2_), // e2_e3
			(-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1))/(_n2_) // e3_e1
		);
}
inline bivector applyUnitVersor(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e3_e1*b.m_e3_e1-a.m_e2_e3*a.m_e2_e3*b.m_e1_e2+-2.0*a.m_e2_e3*a.m_scalar*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e3_e1*a.m_scalar*b.m_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2), // e1_e2
			(-a.m_e1_e2*a.m_e1_e2*b.m_e2_e3+2.0*a.m_e1_e2*a.m_e2_e3*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e3_e1+a.m_e2_e3*a.m_e2_e3*b.m_e2_e3+2.0*a.m_e2_e3*a.m_e3_e1*b.m_e3_e1-a.m_e3_e1*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e3_e1*a.m_scalar*b.m_e1_e2+a.m_scalar*a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*a.m_e1_e2*b.m_e3_e1+-2.0*a.m_e1_e2*a.m_e3_e1*b.m_e1_e2+2.0*a.m_e1_e2*a.m_scalar*b.m_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e3_e1+-2.0*a.m_e2_e3*a.m_e3_e1*b.m_e2_e3+-2.0*a.m_e2_e3*a.m_scalar*b.m_e1_e2-a.m_e3_e1*a.m_e3_e1*b.m_e3_e1-a.m_scalar*a.m_scalar*b.m_e3_e1) // e3_e1
		);
}
inline bivector applyVersorWI(const rotor &a, const bivector &b, const rotor &c)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2*c.m_e1_e2-a.m_e1_e2*b.m_e2_e3*c.m_e2_e3-a.m_e1_e2*b.m_e3_e1*c.m_e3_e1+a.m_e2_e3*b.m_e1_e2*c.m_e2_e3-a.m_e2_e3*b.m_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e3_e1*c.m_scalar+a.m_e3_e1*b.m_e1_e2*c.m_e3_e1+a.m_e3_e1*b.m_e2_e3*c.m_scalar-a.m_e3_e1*b.m_e3_e1*c.m_e1_e2+a.m_scalar*b.m_e1_e2*c.m_scalar-a.m_scalar*b.m_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e3_e1*c.m_e2_e3), // e1_e2
			(-a.m_e1_e2*b.m_e1_e2*c.m_e2_e3+a.m_e1_e2*b.m_e2_e3*c.m_e1_e2+a.m_e1_e2*b.m_e3_e1*c.m_scalar-a.m_e2_e3*b.m_e1_e2*c.m_e1_e2-a.m_e2_e3*b.m_e2_e3*c.m_e2_e3-a.m_e2_e3*b.m_e3_e1*c.m_e3_e1-a.m_e3_e1*b.m_e1_e2*c.m_scalar+a.m_e3_e1*b.m_e2_e3*c.m_e3_e1-a.m_e3_e1*b.m_e3_e1*c.m_e2_e3+a.m_scalar*b.m_e1_e2*c.m_e3_e1+a.m_scalar*b.m_e2_e3*c.m_scalar-a.m_scalar*b.m_e3_e1*c.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e1_e2*c.m_e3_e1+a.m_e1_e2*b.m_e2_e3*c.m_scalar-a.m_e1_e2*b.m_e3_e1*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2*c.m_scalar+a.m_e2_e3*b.m_e2_e3*c.m_e3_e1-a.m_e2_e3*b.m_e3_e1*c.m_e2_e3+a.m_e3_e1*b.m_e1_e2*c.m_e1_e2+a.m_e3_e1*b.m_e2_e3*c.m_e2_e3+a.m_e3_e1*b.m_e3_e1*c.m_e3_e1+a.m_scalar*b.m_e1_e2*c.m_e2_e3-a.m_scalar*b.m_e2_e3*c.m_e1_e2-a.m_scalar*b.m_e3_e1*c.m_scalar) // e3_e1
		);
}
inline trivector applyVersor(const rotor &a, const trivector &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return trivector(trivector::coord_e1e2e3,
			((a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3))/(_n2_) // e1_e2_e3
		);
}
inline trivector applyUnitVersor(const rotor &a, const trivector &b)
{
	return trivector(trivector::coord_e1e2e3,
			(a.m_e1_e2*a.m_e1_e2*b.m_e1_e2_e3+a.m_e2_e3*a.m_e2_e3*b.m_e1_e2_e3+a.m_e3_e1*a.m_e3_e1*b.m_e1_e2_e3+a.m_scalar*a.m_scalar*b.m_e1_e2_e3) // e1_e2_e3
		);
}
inline trivector applyVersorWI(const rotor &a, const trivector &b, const rotor &c)
{
	return trivector(trivector::coord_e1e2e3,
			(-a.m_e1_e2*b.m_e1_e2_e3*c.m_e1_e2-a.m_e2_e3*b.m_e1_e2_e3*c.m_e2_e3-a.m_e3_e1*b.m_e1_e2_e3*c.m_e3_e1+a.m_scalar*b.m_e1_e2_e3*c.m_scalar) // e1_e2_e3
		);
}
inline vector applyVersor(const rotor &a, const e1_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return vector(vector::coord_e1_e2_e3,
			((-a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_), // e1
			((-2.0*a.m_e1_e2*a.m_scalar+2.0*a.m_e2_e3*a.m_e3_e1))/(_n2_), // e2
			((2.0*a.m_e1_e2*a.m_e2_e3+2.0*a.m_e3_e1*a.m_scalar))/(_n2_) // e3
		);
}
inline vector applyUnitVersor(const rotor &a, const e2_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			(2.0*a.m_e1_e2*a.m_scalar+2.0*a.m_e2_e3*a.m_e3_e1), // e1
			(-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar), // e2
			(2.0*a.m_e1_e2*a.m_e3_e1+-2.0*a.m_e2_e3*a.m_scalar) // e3
		);
}
inline trivector applyVersor(const rotor &a, const I3_t &b)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return trivector(trivector::coord_e1e2e3,
			((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar))/(_n2_) // e1_e2_e3
		);
}
inline trivector applyUnitVersor(const rotor &a, const I3_t &b)
{
	return trivector(trivector::coord_e1e2e3,
			(a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar) // e1_e2_e3
		);
}
inline trivector applyVersorWI(const rotor &a, const I3_t &b, const rotor &c)
{
	return trivector(trivector::coord_e1e2e3,
			(-a.m_e1_e2*c.m_e1_e2-a.m_e2_e3*c.m_e2_e3-a.m_e3_e1*c.m_e3_e1+a.m_scalar*c.m_scalar) // e1_e2_e3
		);
}
inline vector applyOM(const om &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_m1[0]*b.m_e1+a.m_m1[1]*b.m_e2+a.m_m1[2]*b.m_e3), // e1
			(a.m_m1[3]*b.m_e1+a.m_m1[4]*b.m_e2+a.m_m1[5]*b.m_e3), // e2
			(a.m_m1[6]*b.m_e1+a.m_m1[7]*b.m_e2+a.m_m1[8]*b.m_e3) // e3
		);

}
inline bivector applyOM(const om &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_m2[0]*b.m_e1_e2-a.m_m2[1]*b.m_e3_e1+a.m_m2[2]*b.m_e2_e3), // e1_e2
			(a.m_m2[6]*b.m_e1_e2-a.m_m2[7]*b.m_e3_e1+a.m_m2[8]*b.m_e2_e3), // e2_e3
			-(a.m_m2[3]*b.m_e1_e2-a.m_m2[4]*b.m_e3_e1+a.m_m2[5]*b.m_e2_e3) // e3_e1
		);

}
inline trivector applyOM(const om &a, const trivector &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_m3[0]*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline vector applyOM(const grade1OM &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_m1[0]*b.m_e1+a.m_m1[1]*b.m_e2+a.m_m1[2]*b.m_e3), // e1
			(a.m_m1[3]*b.m_e1+a.m_m1[4]*b.m_e2+a.m_m1[5]*b.m_e3), // e2
			(a.m_m1[6]*b.m_e1+a.m_m1[7]*b.m_e2+a.m_m1[8]*b.m_e3) // e3
		);

}
inline bivector applyOM(const grade2OM &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_m2[0]*b.m_e1_e2+a.m_m2[1]*b.m_e2_e3+a.m_m2[2]*b.m_e3_e1), // e1_e2
			(a.m_m2[3]*b.m_e1_e2+a.m_m2[4]*b.m_e2_e3+a.m_m2[5]*b.m_e3_e1), // e2_e3
			-(-a.m_m2[6]*b.m_e1_e2-a.m_m2[7]*b.m_e2_e3-a.m_m2[8]*b.m_e3_e1) // e3_e1
		);

}
inline trivector applyOM(const grade3OM &a, const trivector &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_m3[0]*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline vector applyOM(const grade1OM &a, const e1_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_m1[0], // e1
			a.m_m1[3], // e2
			a.m_m1[6] // e3
		);

}
inline vector applyOM(const grade1OM &a, const e2_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_m1[1], // e1
			a.m_m1[4], // e2
			a.m_m1[7] // e3
		);

}
inline vector applyOM(const grade1OM &a, const e3_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_m1[2], // e1
			a.m_m1[5], // e2
			a.m_m1[8] // e3
		);

}
inline trivector applyOM(const grade3OM &a, const I3_t &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_m3[0] // e1_e2_e3
		);

}
inline vector div(const vector &a, const double b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((b)), // e1
			a.m_e2/((b)), // e2
			a.m_e3/((b)) // e3
		);
}
inline bivector div(const bivector &a, const double b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline trivector div(const trivector &a, const double b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3/((b)) // e1_e2_e3
		);
}
inline rotor div(const rotor &a, const double b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((b)), // scalar
			a.m_e1_e2/((b)), // e1_e2
			a.m_e2_e3/((b)), // e2_e3
			a.m_e3_e1/((b)) // e3_e1
		);
}
inline vector div(const e1_t &a, const double b)
{
	return vector(vector::coord_e1_e2_e3,
			1.0 / (b), // e1
			0.0, // e2
			0.0 // e3
		);
}
inline trivector div(const I3_t &a, const double b)
{
	return trivector(trivector::coord_e1e2e3,
			1.0 / (b) // e1_e2_e3
		);
}
inline trivector dual(const double a)
{
	return trivector(trivector::coord_e1e2e3,
			-a // e1_e2_e3
		);

}
inline trivector undual(const double a)
{
	return trivector(trivector::coord_e1e2e3,
			a // e1_e2_e3
		);

}
inline bivector dual(const vector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e3, // e1_e2
			-a.m_e1, // e2_e3
			-a.m_e2 // e3_e1
		);

}
inline bivector undual(const vector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e3, // e1_e2
			a.m_e1, // e2_e3
			a.m_e2 // e3_e1
		);

}
inline vector dual(const bivector &a)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e2_e3, // e1
			a.m_e3_e1, // e2
			a.m_e1_e2 // e3
		);

}
inline vector undual(const bivector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e2_e3, // e1
			-a.m_e3_e1, // e2
			-a.m_e1_e2 // e3
		);

}
inline oddVersor dual(const rotor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			a.m_e2_e3, // e1
			a.m_e3_e1, // e2
			a.m_e1_e2, // e3
			-a.m_scalar // e1_e2_e3
		);

}
inline oddVersor undual(const rotor &a)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			-a.m_e2_e3, // e1
			-a.m_e3_e1, // e2
			-a.m_e1_e2, // e3
			a.m_scalar // e1_e2_e3
		);

}
inline rotor dual(const oddVersor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_e1_e2_e3, // scalar
			-a.m_e3, // e1_e2
			-a.m_e1, // e2_e3
			-a.m_e2 // e3_e1
		);

}
inline rotor undual(const oddVersor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-a.m_e1_e2_e3, // scalar
			a.m_e3, // e1_e2
			a.m_e1, // e2_e3
			a.m_e2 // e3_e1
		);

}
inline double dual(const trivector &a)
{
	return a.m_e1_e2_e3;

}
inline double undual(const trivector &a)
{
	return -a.m_e1_e2_e3;

}
inline bivector dual(const e1_t &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			0.0, // e1_e2
			-1.0, // e2_e3
			0.0 // e3_e1
		);

}
inline bivector undual(const e2_t &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			0.0, // e1_e2
			0.0, // e2_e3
			1.0 // e3_e1
		);

}
inline double dual(const I3_t &a)
{
	return 1.0;

}
inline double undual(const I3_t &a)
{
	return -1.0;

}
inline bool equals(const vector &a, const vector &b, const double c)
{
	double d;
	d = a.m_e1 - b.m_e1; if ((d < -c) || (d > c)) return false; /* e1 */
	d = a.m_e2 - b.m_e2; if ((d < -c) || (d > c)) return false; /* e2 */
	d = a.m_e3 - b.m_e3; if ((d < -c) || (d > c)) return false; /* e3 */
	return true;
}
inline bool equals(const bivector &a, const bivector &b, const double c)
{
	double d;
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const rotor &a, const rotor &b, const double c)
{
	double d;
	d = a.m_scalar - b.m_scalar; if ((d < -c) || (d > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const bivector &a, const rotor &b, const double c)
{
	double d;
	if ((b.m_scalar < -c) || (b.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const trivector &a, const trivector &b, const double c)
{
	double d;
	d = a.m_e1_e2_e3 - b.m_e1_e2_e3; if ((d < -c) || (d > c)) return false; /* e1^e2^e3 */
	return true;
}
inline bool equals(const rotor &a, const bivector &b, const double c)
{
	double d;
	if ((a.m_scalar < -c) || (a.m_scalar > c)) return false; /* 1 */
	d = a.m_e1_e2 - b.m_e1_e2; if ((d < -c) || (d > c)) return false; /* e1^e2 */
	d = -a.m_e3_e1 - -b.m_e3_e1; if ((d < -c) || (d > c)) return false; /* e1^e3 */
	d = a.m_e2_e3 - b.m_e2_e3; if ((d < -c) || (d > c)) return false; /* e2^e3 */
	return true;
}
inline bool equals(const e1_t &a, const e1_t &b, const double c)
{
	double d;
	d = 1.0 - 1.0; if ((d < -c) || (d > c)) return false; /* e1 */
	return true;
}
inline bool equals(const e2_t &a, const I3_t &b, const double c)
{
	if ((1.0 < -c) || (1.0 > c)) return false; /* e2 */
	if ((1.0 < -c) || (1.0 > c)) return false; /* e1^e2^e3 */
	return true;
}
inline double extractGrade0(const rotor &a)
{
	return a.m_scalar;
}
inline bivector extractGrade2(const rotor &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline double extractGrade0(const oddVersor &a)
{
	return 0.0;
}
inline vector extractGrade1(const oddVersor &a)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);
}
inline double extractGrade2(const oddVersor &a)
{
	return 0.0;
}
inline trivector extractGrade3(const oddVersor &a)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3 // e1_e2_e3
		);
}
inline double extractGrade0(const e1_t &a)
{
	return 0.0;
}
inline e2_t extractGrade1(const e2_t &a)
{
	return e2_t(		);
}
inline double extractGrade2(const e3_t &a)
{
	return 0.0;
}
inline double extractGrade3(const e1_t &a)
{
	return 0.0;
}
inline double extractGrade0(const I3_t &a)
{
	return 0.0;
}
inline double extractGrade1(const I3_t &a)
{
	return 0.0;
}
inline double extractGrade2(const I3_t &a)
{
	return 0.0;
}
inline I3_t extractGrade3(const I3_t &a)
{
	return I3_t(		);
}
inline rotor gp(const vector &a, const vector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3), // scalar
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline oddVersor gp(const rotor &a, const vector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3+a.m_scalar*b.m_e1), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3+a.m_scalar*b.m_e2), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1+a.m_scalar*b.m_e3), // e3
			(a.m_e1_e2*b.m_e3+a.m_e2_e3*b.m_e1+a.m_e3_e1*b.m_e2) // e1_e2_e3
		);

}
inline oddVersor gp(const vector &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar), // e3
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline rotor gp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1+a.m_scalar*b.m_scalar), // scalar
			(a.m_e1_e2*b.m_scalar-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3+a.m_scalar*b.m_e1_e2), // e1_e2
			(a.m_e1_e2*b.m_e3_e1+a.m_e2_e3*b.m_scalar-a.m_e3_e1*b.m_e1_e2+a.m_scalar*b.m_e2_e3), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2-a.m_e3_e1*b.m_scalar-a.m_scalar*b.m_e3_e1) // e3_e1
		);

}
inline rotor gp(const bivector &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			(-a.m_e2_e3*b.m_e3_e1+a.m_e3_e1*b.m_e2_e3), // e1_e2
			(a.m_e1_e2*b.m_e3_e1-a.m_e3_e1*b.m_e1_e2), // e2_e3
			-(a.m_e1_e2*b.m_e2_e3-a.m_e2_e3*b.m_e1_e2) // e3_e1
		);

}
inline oddVersor gp(const e1_t &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			b.m_scalar, // e1
			b.m_e1_e2, // e2
			-b.m_e3_e1, // e3
			b.m_e2_e3 // e1_e2_e3
		);

}
inline oddVersor gp(const I3_t &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			-b.m_e2_e3, // e1
			-b.m_e3_e1, // e2
			-b.m_e1_e2, // e3
			b.m_scalar // e1_e2_e3
		);

}
inline oddVersor gp(const bivector &a, const e1_t &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			0.0, // e1
			-a.m_e1_e2, // e2
			a.m_e3_e1, // e3
			a.m_e2_e3 // e1_e2_e3
		);

}
inline int gradeBitmap(const rotor &a, const double b)
{
	int bitmap = 0;
	if ((a.m_scalar < -b) || (a.m_scalar > b)) bitmap |= 1;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const vector &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1 < -b) || (a.m_e1 > b)) bitmap |= 2;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) bitmap |= 2;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const bivector &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) bitmap |= 4;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) bitmap |= 4;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) bitmap |= 4;
	return bitmap;
}
inline int gradeBitmap(const trivector &a, const double b)
{
	int bitmap = 0;
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) bitmap |= 8;
	return bitmap;
}
inline int gradeBitmap(const e1_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const e2_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 2;
	return bitmap;
}
inline int gradeBitmap(const I3_t &a, const double b)
{
	int bitmap = 0;
	if (1.0 > b) bitmap |= 8;
	return bitmap;
}
inline vector hp(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1*b.m_e1, // e1
			a.m_e2*b.m_e2, // e2
			a.m_e3*b.m_e3 // e3
		);

}
inline bivector hp(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline rotor hp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar*b.m_scalar, // scalar
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline bivector hp(const bivector &a, const rotor &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline trivector hp(const trivector &a, const trivector &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline trivector hp(const trivector &a, const oddVersor &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline bivector hp(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2*b.m_e1_e2, // e1_e2
			a.m_e2_e3*b.m_e2_e3, // e2_e3
			a.m_e3_e1*b.m_e3_e1 // e3_e1
		);

}
inline e1_t hp(const e1_t &a, const e1_t &b)
{
	return e1_t(		);

}
inline double hp(const e2_t &a, const e3_t &b)
{
	return 0.0;

}
inline trivector hp(const oddVersor &a, const I3_t &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline vector ihp(const vector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((b.m_e1)), // e1
			a.m_e2/((b.m_e2)), // e2
			a.m_e3/((b.m_e3)) // e3
		);

}
inline bivector ihp(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline rotor ihp(const rotor &a, const rotor &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((b.m_scalar)), // scalar
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline bivector ihp(const bivector &a, const rotor &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline bivector ihp(const rotor &a, const bivector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((b.m_e1_e2)), // e1_e2
			a.m_e2_e3/((b.m_e2_e3)), // e2_e3
			-a.m_e3_e1/((-b.m_e3_e1)) // e3_e1
		);

}
inline trivector ihp(const trivector &a, const oddVersor &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3/((b.m_e1_e2_e3)) // e1_e2_e3
		);

}
inline vector ihp(const vector &a, const e1_t &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline double ihp(const e2_t &a, const e3_t &b)
{
	return 0.0;

}
inline trivector ihp(const trivector &a, const I3_t &b)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor increment(const bivector &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotor increment(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotor decrement(const bivector &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-1.0, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline rotor decrement(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-1.0+a.m_scalar), // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);
}
inline double sp(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline double lc(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline double rc(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline double hip(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline double mhip(const vector &a, const vector &b)
{
	return (a.m_e1*b.m_e1+a.m_e2*b.m_e2+a.m_e3*b.m_e3);

}
inline double sp(const bivector &a, const vector &b)
{
	return 0.0;

}
inline double lc(const bivector &a, const vector &b)
{
	return 0.0;

}
inline vector rc(const bivector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1) // e3
		);

}
inline vector hip(const bivector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1) // e3
		);

}
inline vector mhip(const bivector &a, const vector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1_e2*b.m_e2-a.m_e3_e1*b.m_e3), // e1
			(-a.m_e1_e2*b.m_e1+a.m_e2_e3*b.m_e3), // e2
			(-a.m_e2_e3*b.m_e2+a.m_e3_e1*b.m_e1) // e3
		);

}
inline double sp(const trivector &a, const trivector &b)
{
	return -a.m_e1_e2_e3*b.m_e1_e2_e3;

}
inline double lc(const trivector &a, const trivector &b)
{
	return -a.m_e1_e2_e3*b.m_e1_e2_e3;

}
inline double rc(const trivector &a, const trivector &b)
{
	return -a.m_e1_e2_e3*b.m_e1_e2_e3;

}
inline double hip(const trivector &a, const trivector &b)
{
	return -a.m_e1_e2_e3*b.m_e1_e2_e3;

}
inline double mhip(const trivector &a, const trivector &b)
{
	return -a.m_e1_e2_e3*b.m_e1_e2_e3;

}
inline double sp(const vector &a, const bivector &b)
{
	return 0.0;

}
inline vector lc(const vector &a, const bivector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3) // e3
		);

}
inline double rc(const vector &a, const bivector &b)
{
	return 0.0;

}
inline vector hip(const vector &a, const bivector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3) // e3
		);

}
inline vector mhip(const vector &a, const bivector &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3) // e3
		);

}
inline double sp(const vector &a, const rotor &b)
{
	return 0.0;

}
inline vector lc(const vector &a, const rotor &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3) // e3
		);

}
inline vector rc(const vector &a, const rotor &b)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1*b.m_scalar, // e1
			a.m_e2*b.m_scalar, // e2
			a.m_e3*b.m_scalar // e3
		);

}
inline vector hip(const vector &a, const rotor &b)
{
	return vector(vector::coord_e1_e2_e3,
			(-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3) // e3
		);

}
inline vector mhip(const vector &a, const rotor &b)
{
	return vector(vector::coord_e1_e2_e3,
			(a.m_e1*b.m_scalar-a.m_e2*b.m_e1_e2+a.m_e3*b.m_e3_e1), // e1
			(a.m_e1*b.m_e1_e2+a.m_e2*b.m_scalar-a.m_e3*b.m_e2_e3), // e2
			(-a.m_e1*b.m_e3_e1+a.m_e2*b.m_e2_e3+a.m_e3*b.m_scalar) // e3
		);

}
inline double sp(const rotor &a, const bivector &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1);

}
inline rotor lc(const rotor &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1 // e3_e1
		);

}
inline double rc(const rotor &a, const bivector &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1);

}
inline double hip(const rotor &a, const bivector &b)
{
	return (-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1);

}
inline rotor mhip(const rotor &a, const bivector &b)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			(-a.m_e1_e2*b.m_e1_e2-a.m_e2_e3*b.m_e2_e3-a.m_e3_e1*b.m_e3_e1), // scalar
			a.m_scalar*b.m_e1_e2, // e1_e2
			a.m_scalar*b.m_e2_e3, // e2_e3
			a.m_scalar*b.m_e3_e1 // e3_e1
		);

}
inline double sp(const rotor &a, const trivector &b)
{
	return 0.0;

}
inline oddVersor lc(const rotor &a, const trivector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			-a.m_e2_e3*b.m_e1_e2_e3, // e1
			-a.m_e3_e1*b.m_e1_e2_e3, // e2
			-a.m_e1_e2*b.m_e1_e2_e3, // e3
			a.m_scalar*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline double rc(const rotor &a, const trivector &b)
{
	return 0.0;

}
inline vector hip(const rotor &a, const trivector &b)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e2_e3*b.m_e1_e2_e3, // e1
			-a.m_e3_e1*b.m_e1_e2_e3, // e2
			-a.m_e1_e2*b.m_e1_e2_e3 // e3
		);

}
inline oddVersor mhip(const rotor &a, const trivector &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			-a.m_e2_e3*b.m_e1_e2_e3, // e1
			-a.m_e3_e1*b.m_e1_e2_e3, // e2
			-a.m_e1_e2*b.m_e1_e2_e3, // e3
			a.m_scalar*b.m_e1_e2_e3 // e1_e2_e3
		);

}
inline double sp(const e1_t &a, const I3_t &b)
{
	return 0.0;

}
inline double lc(const I3_t &a, const e3_t &b)
{
	return 0.0;

}
inline double rc(const e1_t &a, const e1_t &b)
{
	return 1.0;

}
inline bivector hip(const e2_t &a, const I3_t &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			0.0, // e1_e2
			0.0, // e2_e3
			1.0 // e3_e1
		);

}
inline double mhip(const I3_t &a, const I3_t &b)
{
	return -1.0;

}
inline double norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline double norm(const vector &a)
{
	return ::fabs(::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3)));

}
inline double norm_returns_scalar(const vector &a) {
	return norm(a);
}
inline double norm(const bivector &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1)));

}
inline double norm_returns_scalar(const bivector &a) {
	return norm(a);
}
inline double norm(const trivector &a)
{
	return ::fabs(::sqrt(a.m_e1_e2_e3*a.m_e1_e2_e3));

}
inline double norm_returns_scalar(const trivector &a) {
	return norm(a);
}
inline double norm(const rotor &a)
{
	return ::fabs(::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar)));

}
inline double norm_returns_scalar(const rotor &a) {
	return norm(a);
}
inline double norm(const e1_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const e1_t &a) {
	return norm(a);
}
inline double norm(const e3_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const e3_t &a) {
	return norm(a);
}
inline double norm(const I3_t &a)
{
	return ::fabs(1.0);

}
inline double norm_returns_scalar(const I3_t &a) {
	return norm(a);
}
inline double norm2_returns_scalar(const mv &a) {
	return norm2(a);
}
inline double norm2(const vector &a)
{
	return (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

}
inline double norm2_returns_scalar(const vector &a) {
	return norm2(a);
}
inline double norm2(const bivector &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

}
inline double norm2_returns_scalar(const bivector &a) {
	return norm2(a);
}
inline double norm2(const trivector &a)
{
	return a.m_e1_e2_e3*a.m_e1_e2_e3;

}
inline double norm2_returns_scalar(const trivector &a) {
	return norm2(a);
}
inline double norm2(const rotor &a)
{
	return (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

}
inline double norm2_returns_scalar(const rotor &a) {
	return norm2(a);
}
inline double norm2(const e1_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const e1_t &a) {
	return norm2(a);
}
inline double norm2(const e3_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const e3_t &a) {
	return norm2(a);
}
inline double norm2(const I3_t &a)
{
	return 1.0;

}
inline double norm2_returns_scalar(const I3_t &a) {
	return norm2(a);
}
inline bivector op(const vector &a, const vector &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			(a.m_e1*b.m_e2-a.m_e2*b.m_e1), // e1_e2
			(a.m_e2*b.m_e3-a.m_e3*b.m_e2), // e2_e3
			-(a.m_e1*b.m_e3-a.m_e3*b.m_e1) // e3_e1
		);

}
inline double op(const bivector &a, const bivector &b)
{
	return 0.0;

}
inline oddVersor op(const vector &a, const rotor &b)
{
	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			a.m_e1*b.m_scalar, // e1
			a.m_e2*b.m_scalar, // e2
			a.m_e3*b.m_scalar, // e3
			(a.m_e1*b.m_e2_e3+a.m_e2*b.m_e3_e1+a.m_e3*b.m_e1_e2) // e1_e2_e3
		);

}
inline double op(const vector &a, const trivector &b)
{
	return 0.0;

}
inline double op(const e1_t &a, const e1_t &b)
{
	return 0.0;

}
inline bivector op(const e1_t &a, const e2_t &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			1.0, // e1_e2
			0.0, // e2_e3
			0.0 // e3_e1
		);

}
inline bivector op(const e2_t &a, const e3_t &b)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			0.0, // e1_e2
			1.0, // e2_e3
			0.0 // e3_e1
		);

}
inline rotor exp(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			::cos(_alpha), // scalar
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline double cosh(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	return ::cos(_alpha);
}
inline bivector sinh(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sin(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline double cos(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	return ::cosh(_alpha);
}
inline bivector sin(const bivector &a)
{
	double _alpha = ::sqrt(::fabs((-a.m_e1_e2*a.m_e1_e2-a.m_e2_e3*a.m_e2_e3-a.m_e3_e1*a.m_e3_e1)));

	double _mul;
	if (_alpha != 0.0) {
		_mul = ::sinh(_alpha)/((_alpha));

	}
	else {
		_mul = 0.0;

	}
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			_mul*a.m_e1_e2, // e1_e2
			_mul*a.m_e2_e3, // e2_e3
			_mul*a.m_e3_e1 // e3_e1
		);
}
inline vector negate(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline vector cliffordConjugate(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline vector gradeInvolution(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			-a.m_e1, // e1
			-a.m_e2, // e2
			-a.m_e3 // e3
		);

}
inline vector reverse(const vector &a)
{
	return vector(vector::coord_e1_e2_e3,
			a.m_e1, // e1
			a.m_e2, // e2
			a.m_e3 // e3
		);

}
inline bivector negate(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline bivector cliffordConjugate(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline bivector gradeInvolution(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline bivector reverse(const bivector &a)
{
	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline trivector negate(const trivector &a)
{
	return trivector(trivector::coord_e1e2e3,
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline trivector cliffordConjugate(const trivector &a)
{
	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline trivector gradeInvolution(const trivector &a)
{
	return trivector(trivector::coord_e1e2e3,
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline trivector reverse(const trivector &a)
{
	return trivector(trivector::coord_e1e2e3,
			-a.m_e1_e2_e3 // e1_e2_e3
		);

}
inline rotor negate(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			-a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline rotor cliffordConjugate(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline rotor gradeInvolution(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			a.m_e1_e2, // e1_e2
			a.m_e2_e3, // e2_e3
			a.m_e3_e1 // e3_e1
		);

}
inline rotor reverse(const rotor &a)
{
	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar, // scalar
			-a.m_e1_e2, // e1_e2
			-a.m_e2_e3, // e2_e3
			-a.m_e3_e1 // e3_e1
		);

}
inline vector negate(const e1_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			-1.0, // e1
			0.0, // e2
			0.0 // e3
		);

}
inline vector cliffordConjugate(const e2_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			0.0, // e1
			-1.0, // e2
			0.0 // e3
		);

}
inline vector gradeInvolution(const e3_t &a)
{
	return vector(vector::coord_e1_e2_e3,
			0.0, // e1
			0.0, // e2
			-1.0 // e3
		);

}
inline trivector reverse(const I3_t &a)
{
	return trivector(trivector::coord_e1e2e3,
			-1.0 // e1_e2_e3
		);

}
inline double negate(const double a)
{
	return -a;

}
inline double cliffordConjugate(const double a)
{
	return a;

}
inline double gradeInvolution(const double a)
{
	return a;

}
inline double reverse(const double a)
{
	return a;

}
inline vector unit(const vector &a)
{
	double _n_ = ::sqrt((a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)) // e3
		);
}
inline bivector unit(const bivector &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1));

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline trivector unit(const trivector &a)
{
	double _n_ = ::sqrt(a.m_e1_e2_e3*a.m_e1_e2_e3);

	return trivector(trivector::coord_e1e2e3,
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline rotor unit(const rotor &a)
{
	double _n_ = ::sqrt((a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar));

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n_)), // scalar
			a.m_e1_e2/((_n_)), // e1_e2
			a.m_e2_e3/((_n_)), // e2_e3
			a.m_e3_e1/((_n_)) // e3_e1
		);
}
inline oddVersor unit(const oddVersor &a)
{
	double _n_ = ::sqrt((a.m_e1*a.m_e1+a.m_e1_e2_e3*a.m_e1_e2_e3+a.m_e2*a.m_e2+a.m_e3*a.m_e3));

	return oddVersor(oddVersor::coord_e1_e2_e3_e1e2e3,
			a.m_e1/((_n_)), // e1
			a.m_e2/((_n_)), // e2
			a.m_e3/((_n_)), // e3
			a.m_e1_e2_e3/((_n_)) // e1_e2_e3
		);
}
inline e1_t unit(const e1_t &a)
{
	return e1_t(		);
}
inline e2_t unit(const e2_t &a)
{
	return e2_t(		);
}
inline I3_t unit(const I3_t &a)
{
	return I3_t(		);
}
inline vector versorInverse(const vector &a)
{
	double _n2_ = (a.m_e1*a.m_e1+a.m_e2*a.m_e2+a.m_e3*a.m_e3);

	return vector(vector::coord_e1_e2_e3,
			a.m_e1/((_n2_)), // e1
			a.m_e2/((_n2_)), // e2
			a.m_e3/((_n2_)) // e3
		);
}
inline bivector versorInverse(const bivector &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1);

	return bivector(bivector::coord_e1e2_e2e3_e3e1,
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline trivector versorInverse(const trivector &a)
{
	double _n2_ = a.m_e1_e2_e3*a.m_e1_e2_e3;

	return trivector(trivector::coord_e1e2e3,
			-a.m_e1_e2_e3/((_n2_)) // e1_e2_e3
		);
}
inline rotor versorInverse(const rotor &a)
{
	double _n2_ = (a.m_e1_e2*a.m_e1_e2+a.m_e2_e3*a.m_e2_e3+a.m_e3_e1*a.m_e3_e1+a.m_scalar*a.m_scalar);

	return rotor(rotor::coord_scalar_e1e2_e2e3_e3e1,
			a.m_scalar/((_n2_)), // scalar
			-a.m_e1_e2/((_n2_)), // e1_e2
			-a.m_e2_e3/((_n2_)), // e2_e3
			-a.m_e3_e1/((_n2_)) // e3_e1
		);
}
inline e1_t versorInverse(const e1_t &a)
{
	return e1_t(		);
}
inline e3_t versorInverse(const e3_t &a)
{
	return e3_t(		);
}
inline trivector versorInverse(const I3_t &a)
{
	return trivector(trivector::coord_e1e2e3,
			-1.0 // e1_e2_e3
		);
}
inline bool zero(const vector &a, const double b)
{
	if ((a.m_e1 < -b) || (a.m_e1 > b)) return false;
	if ((a.m_e2 < -b) || (a.m_e2 > b)) return false;
	if ((a.m_e3 < -b) || (a.m_e3 > b)) return false;
	return true;
}
inline bool zero(const bivector &a, const double b)
{
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	return true;
}
inline bool zero(const trivector &a, const double b)
{
	if ((a.m_e1_e2_e3 < -b) || (a.m_e1_e2_e3 > b)) return false;
	return true;
}
inline bool zero(const rotor &a, const double b)
{
	if ((a.m_scalar < -b) || (a.m_scalar > b)) return false;
	if ((a.m_e1_e2 < -b) || (a.m_e1_e2 > b)) return false;
	if ((a.m_e2_e3 < -b) || (a.m_e2_e3 > b)) return false;
	if ((a.m_e3_e1 < -b) || (a.m_e3_e1 > b)) return false;
	return true;
}
inline bool zero(const I3_t &a, const double b)
{
	if (1.0 > b) return false;
	return true;
}
inline bool zero(const e1_t &a, const double b)
{
	if (1.0 > b) return false;
	return true;
}


/** structure used by custom parser */
struct e3gaParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct e3gaParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace e3ga
#endif /* _E3GA_H_ */
