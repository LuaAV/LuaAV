// This file is generated by TableGen. Do not edi.

  switch (Kind) {
  default:
    assert(0 && "Unknown attribute!");
    break;
  case attr::Alias: {
    std::string aliasee= ReadString(Record, Idx);
    New = new (*Context) AliasAttr(Loc, *Context, aliasee);
    break;
  }
  case attr::AlignMac68k: {
    New = new (*Context) AlignMac68kAttr(Loc, *Context);
    break;
  }
  case attr::Aligned: {
    bool isalignmentExpr = Record[Idx++];
    void *alignmentPtr;
    if (isalignmentExpr)
      alignmentPtr = ReadExpr(DeclsCursor);
    else
      alignmentPtr = GetTypeSourceInfo(DeclsCursor, Record, Idx);
    New = new (*Context) AlignedAttr(Loc, *Context, isalignmentExpr, alignmentPtr);
    break;
  }
  case attr::AlwaysInline: {
    New = new (*Context) AlwaysInlineAttr(Loc, *Context);
    break;
  }
  case attr::AnalyzerNoReturn: {
    New = new (*Context) AnalyzerNoReturnAttr(Loc, *Context);
    break;
  }
  case attr::Annotate: {
    std::string annotation= ReadString(Record, Idx);
    New = new (*Context) AnnotateAttr(Loc, *Context, annotation);
    break;
  }
  case attr::AsmLabel: {
    std::string label= ReadString(Record, Idx);
    New = new (*Context) AsmLabelAttr(Loc, *Context, label);
    break;
  }
  case attr::BaseCheck: {
    New = new (*Context) BaseCheckAttr(Loc, *Context);
    break;
  }
  case attr::Blocks: {
    BlocksAttr::BlockType type(static_cast<BlocksAttr::BlockType>(Record[Idx++]));
    New = new (*Context) BlocksAttr(Loc, *Context, type);
    break;
  }
  case attr::CDecl: {
    New = new (*Context) CDeclAttr(Loc, *Context);
    break;
  }
  case attr::CFReturnsNotRetained: {
    New = new (*Context) CFReturnsNotRetainedAttr(Loc, *Context);
    break;
  }
  case attr::CFReturnsRetained: {
    New = new (*Context) CFReturnsRetainedAttr(Loc, *Context);
    break;
  }
  case attr::CarriesDependency: {
    New = new (*Context) CarriesDependencyAttr(Loc, *Context);
    break;
  }
  case attr::Cleanup: {
    FunctionDecl * functionDecl = cast_or_null<FunctionDecl >(GetDecl(Record[Idx++]));
    New = new (*Context) CleanupAttr(Loc, *Context, functionDecl);
    break;
  }
  case attr::Const: {
    New = new (*Context) ConstAttr(Loc, *Context);
    break;
  }
  case attr::Constructor: {
    int priority = Record[Idx++];
    New = new (*Context) ConstructorAttr(Loc, *Context, priority);
    break;
  }
  case attr::DLLExport: {
    New = new (*Context) DLLExportAttr(Loc, *Context);
    break;
  }
  case attr::DLLImport: {
    New = new (*Context) DLLImportAttr(Loc, *Context);
    break;
  }
  case attr::Deprecated: {
    New = new (*Context) DeprecatedAttr(Loc, *Context);
    break;
  }
  case attr::Destructor: {
    int priority = Record[Idx++];
    New = new (*Context) DestructorAttr(Loc, *Context, priority);
    break;
  }
  case attr::FastCall: {
    New = new (*Context) FastCallAttr(Loc, *Context);
    break;
  }
  case attr::Final: {
    New = new (*Context) FinalAttr(Loc, *Context);
    break;
  }
  case attr::Format: {
    std::string type= ReadString(Record, Idx);
    int formatIdx = Record[Idx++];
    int firstArg = Record[Idx++];
    New = new (*Context) FormatAttr(Loc, *Context, type, formatIdx, firstArg);
    break;
  }
  case attr::FormatArg: {
    int formatIdx = Record[Idx++];
    New = new (*Context) FormatArgAttr(Loc, *Context, formatIdx);
    break;
  }
  case attr::GNUInline: {
    New = new (*Context) GNUInlineAttr(Loc, *Context);
    break;
  }
  case attr::Hiding: {
    New = new (*Context) HidingAttr(Loc, *Context);
    break;
  }
  case attr::IBAction: {
    New = new (*Context) IBActionAttr(Loc, *Context);
    break;
  }
  case attr::IBOutlet: {
    New = new (*Context) IBOutletAttr(Loc, *Context);
    break;
  }
  case attr::IBOutletCollection: {
    QualType interface = ReadTypeRecord(Idx++);
    New = new (*Context) IBOutletCollectionAttr(Loc, *Context, interface);
    break;
  }
  case attr::InitPriority: {
    unsigned priority = Record[Idx++];
    New = new (*Context) InitPriorityAttr(Loc, *Context, priority);
    break;
  }
  case attr::MSP430Interrupt: {
    unsigned number = Record[Idx++];
    New = new (*Context) MSP430InterruptAttr(Loc, *Context, number);
    break;
  }
  case attr::Malloc: {
    New = new (*Context) MallocAttr(Loc, *Context);
    break;
  }
  case attr::MaxFieldAlignment: {
    unsigned alignment = Record[Idx++];
    New = new (*Context) MaxFieldAlignmentAttr(Loc, *Context, alignment);
    break;
  }
  case attr::NSReturnsNotRetained: {
    New = new (*Context) NSReturnsNotRetainedAttr(Loc, *Context);
    break;
  }
  case attr::NSReturnsRetained: {
    New = new (*Context) NSReturnsRetainedAttr(Loc, *Context);
    break;
  }
  case attr::NoDebug: {
    New = new (*Context) NoDebugAttr(Loc, *Context);
    break;
  }
  case attr::NoInline: {
    New = new (*Context) NoInlineAttr(Loc, *Context);
    break;
  }
  case attr::NoInstrumentFunction: {
    New = new (*Context) NoInstrumentFunctionAttr(Loc, *Context);
    break;
  }
  case attr::NoReturn: {
    New = new (*Context) NoReturnAttr(Loc, *Context);
    break;
  }
  case attr::NoThrow: {
    New = new (*Context) NoThrowAttr(Loc, *Context);
    break;
  }
  case attr::NonNull: {
  unsigned argsSize = Record[Idx++];
  llvm::SmallVector<unsigned, 4> args;
  args.reserve(argsSize);
  for (unsigned i = argsSize; i; --i)
    args.push_back(Record[Idx++]);
    New = new (*Context) NonNullAttr(Loc, *Context, args.data(), argsSize);
    break;
  }
  case attr::ObjCException: {
    New = new (*Context) ObjCExceptionAttr(Loc, *Context);
    break;
  }
  case attr::ObjCNSObject: {
    New = new (*Context) ObjCNSObjectAttr(Loc, *Context);
    break;
  }
  case attr::Overloadable: {
    New = new (*Context) OverloadableAttr(Loc, *Context);
    break;
  }
  case attr::Override: {
    New = new (*Context) OverrideAttr(Loc, *Context);
    break;
  }
  case attr::Ownership: {
    OwnershipAttr::OwnershipKind ownKind(static_cast<OwnershipAttr::OwnershipKind>(Record[Idx++]));
    std::string module= ReadString(Record, Idx);
  unsigned argsSize = Record[Idx++];
  llvm::SmallVector<unsigned, 4> args;
  args.reserve(argsSize);
  for (unsigned i = argsSize; i; --i)
    args.push_back(Record[Idx++]);
    New = new (*Context) OwnershipAttr(Loc, *Context, ownKind, module, args.data(), argsSize);
    break;
  }
  case attr::Packed: {
    New = new (*Context) PackedAttr(Loc, *Context);
    break;
  }
  case attr::Pascal: {
    New = new (*Context) PascalAttr(Loc, *Context);
    break;
  }
  case attr::Pure: {
    New = new (*Context) PureAttr(Loc, *Context);
    break;
  }
  case attr::Regparm: {
    unsigned numParams = Record[Idx++];
    New = new (*Context) RegparmAttr(Loc, *Context, numParams);
    break;
  }
  case attr::ReqdWorkGroupSize: {
    unsigned xDim = Record[Idx++];
    unsigned yDim = Record[Idx++];
    unsigned zDim = Record[Idx++];
    New = new (*Context) ReqdWorkGroupSizeAttr(Loc, *Context, xDim, yDim, zDim);
    break;
  }
  case attr::Section: {
    std::string name= ReadString(Record, Idx);
    New = new (*Context) SectionAttr(Loc, *Context, name);
    break;
  }
  case attr::Sentinel: {
    int sentinel = Record[Idx++];
    int nullPos = Record[Idx++];
    New = new (*Context) SentinelAttr(Loc, *Context, sentinel, nullPos);
    break;
  }
  case attr::StdCall: {
    New = new (*Context) StdCallAttr(Loc, *Context);
    break;
  }
  case attr::ThisCall: {
    New = new (*Context) ThisCallAttr(Loc, *Context);
    break;
  }
  case attr::TransparentUnion: {
    New = new (*Context) TransparentUnionAttr(Loc, *Context);
    break;
  }
  case attr::Unavailable: {
    New = new (*Context) UnavailableAttr(Loc, *Context);
    break;
  }
  case attr::Unused: {
    New = new (*Context) UnusedAttr(Loc, *Context);
    break;
  }
  case attr::Used: {
    New = new (*Context) UsedAttr(Loc, *Context);
    break;
  }
  case attr::VecReturn: {
    New = new (*Context) VecReturnAttr(Loc, *Context);
    break;
  }
  case attr::Visibility: {
    VisibilityAttr::VisibilityType visibility(static_cast<VisibilityAttr::VisibilityType>(Record[Idx++]));
    New = new (*Context) VisibilityAttr(Loc, *Context, visibility);
    break;
  }
  case attr::WarnUnusedResult: {
    New = new (*Context) WarnUnusedResultAttr(Loc, *Context);
    break;
  }
  case attr::Weak: {
    New = new (*Context) WeakAttr(Loc, *Context);
    break;
  }
  case attr::WeakImport: {
    New = new (*Context) WeakImportAttr(Loc, *Context);
    break;
  }
  case attr::WeakRef: {
    New = new (*Context) WeakRefAttr(Loc, *Context);
    break;
  }
  case attr::X86ForceAlignArgPointer: {
    New = new (*Context) X86ForceAlignArgPointerAttr(Loc, *Context);
    break;
  }
  }
